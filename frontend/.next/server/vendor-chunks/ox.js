"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ox";
exports.ids = ["vendor-chunks/ox"];
exports.modules = {

/***/ "(ssr)/./node_modules/ox/_esm/core/AbiParameters.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/AbiParameters.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayLengthMismatchError: () => (/* binding */ ArrayLengthMismatchError),\n/* harmony export */   BytesSizeMismatchError: () => (/* binding */ BytesSizeMismatchError),\n/* harmony export */   DataSizeTooSmallError: () => (/* binding */ DataSizeTooSmallError),\n/* harmony export */   InvalidArrayError: () => (/* binding */ InvalidArrayError),\n/* harmony export */   InvalidTypeError: () => (/* binding */ InvalidTypeError),\n/* harmony export */   LengthMismatchError: () => (/* binding */ LengthMismatchError),\n/* harmony export */   ZeroDataError: () => (/* binding */ ZeroDataError),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodePacked: () => (/* binding */ encodePacked),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! abitype */ \"(ssr)/./node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(parameters, data, options = {}) {\n    const { as = 'Array', checksumAddress = false } = options;\n    const bytes = typeof data === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(data) : data;\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__.create(bytes);\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) === 0 && parameters.length > 0)\n        throw new ZeroDataError();\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) && _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) < 32)\n        throw new DataSizeTooSmallError({\n            data: typeof data === 'string' ? data : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data),\n            parameters: parameters,\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n        });\n    let consumed = 0;\n    const values = as === 'Array' ? [] : {};\n    for (let i = 0; i < parameters.length; ++i) {\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        if (as === 'Array')\n            values.push(data);\n        else\n            values[param.name ?? i] = data;\n    }\n    return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nfunction encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: parameters.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParameters = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values,\n    });\n    const data = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encode(preparedParameters);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nfunction encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n}\n(function (encodePacked) {\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    function encode(type, value, isArray = false) {\n        if (type === 'address') {\n            const address = value;\n            _Address_js__WEBPACK_IMPORTED_MODULE_4__.assert(address);\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === 'string')\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n        if (type === 'bytes')\n            return value;\n        if (type === 'bool')\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = '256'] = intMatch;\n            const size = Number.parseInt(bits, 10) / 8;\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === 'int',\n            });\n        }\n        const bytesMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size, 10) !== (value.length - 2) / 2)\n                throw new BytesSizeMismatchError({\n                    expectedSize: Number.parseInt(size, 10),\n                    value: value,\n                });\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for (let i = 0; i < value.length; i++) {\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0)\n                return '0x';\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nfunction format(parameters) {\n    return abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nfunction from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n        return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    if (typeof parameters === 'string')\n        return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                             ↑ ❌ 2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nclass DataSizeTooSmallError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ data, parameters, size, }) {\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.DataSizeTooSmallError'\n        });\n    }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                           ↑ ❌ zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nclass ZeroDataError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ZeroDataError'\n        });\n    }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                               ↑ expected: 3  ↑ ❌ length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                         ↑ ✅ length: 3\n * ```\n */\nclass ArrayLengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ArrayLengthMismatchError'\n        });\n    }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                            ↑ expected: 8 bytes  ↑ ❌ size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                       ↑ ✅ size: 8 bytes\n * ```\n */\nclass BytesSizeMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedSize, value, }) {\n        super(`Size of bytes \"${value}\" (bytes${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.BytesSizeMismatchError'\n        });\n    }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nclass LengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding parameters/values length mismatch.',\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.LengthMismatchError'\n        });\n    }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nclass InvalidArrayError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidArrayError'\n        });\n    }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                             ↑ ❌ invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nclass InvalidTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(type) {\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidTypeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ0s7QUFDSjtBQUNFO0FBQ047QUFDd0I7QUFDVDtBQUNMO0FBQzFDO0FBQ08sOENBQThDO0FBQ3JELFlBQVksd0NBQXdDO0FBQ3BELDZDQUE2Qyw4Q0FBYTtBQUMxRCxtQkFBbUIsdURBQWE7QUFDaEMsUUFBUSwyQ0FBVTtBQUNsQjtBQUNBLFFBQVEsMkNBQVUsV0FBVywyQ0FBVTtBQUN2QztBQUNBLG9EQUFvRCw4Q0FBYTtBQUNqRTtBQUNBLGtCQUFrQiwyQ0FBVTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBLGtDQUFrQyx1RUFBd0I7QUFDMUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkMsU0FBUywyQkFBMkI7QUFDcEMsU0FBUywrQkFBK0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQix5RUFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiw4REFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtB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OEI7QUFDaEQ7QUFDQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVELHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGlEQUFnQjtBQUN2RDtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLGlEQUFnQjtBQUN0RDtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaVBhcmFtZXRlcnMuanM/ZWM1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhYml0eXBlIGZyb20gJ2FiaXR5cGUnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvYWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBDdXJzb3IgZnJvbSAnLi9pbnRlcm5hbC9jdXJzb3IuanMnO1xuaW1wb3J0ICogYXMgU29saWRpdHkgZnJvbSAnLi9Tb2xpZGl0eS5qcyc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1qc2RvY1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShwYXJhbWV0ZXJzLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0FycmF5JywgY2hlY2tzdW1BZGRyZXNzID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBCeXRlcy5mcm9tSGV4KGRhdGEpIDogZGF0YTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJ5dGVzKTtcbiAgICBpZiAoQnl0ZXMuc2l6ZShieXRlcykgPT09IDAgJiYgcGFyYW1ldGVycy5sZW5ndGggPiAwKVxuICAgICAgICB0aHJvdyBuZXcgWmVyb0RhdGFFcnJvcigpO1xuICAgIGlmIChCeXRlcy5zaXplKGJ5dGVzKSAmJiBCeXRlcy5zaXplKGJ5dGVzKSA8IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRGF0YVNpemVUb29TbWFsbEVycm9yKHtcbiAgICAgICAgICAgIGRhdGE6IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBIZXguZnJvbUJ5dGVzKGRhdGEpLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICB9KTtcbiAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgIGNvbnN0IHZhbHVlcyA9IGFzID09PSAnQXJyYXknID8gW10gOiB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbWV0ZXJzW2ldO1xuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oY29uc3VtZWQpO1xuICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGludGVybmFsLmRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgaWYgKGFzID09PSAnQXJyYXknKVxuICAgICAgICAgICAgdmFsdWVzLnB1c2goZGF0YSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbHVlc1twYXJhbS5uYW1lID8/IGldID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbi8qKlxuICogRW5jb2RlcyBwcmltaXRpdmUgdmFsdWVzIGludG8gQUJJIGVuY29kZWQgZGF0YSBhcyBwZXIgdGhlIFtBcHBsaWNhdGlvbiBCaW5hcnkgSW50ZXJmYWNlIChBQkkpIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC9hYmktc3BlYykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlKFxuICogICBBYmlQYXJhbWV0ZXJzLmZyb20oWydzdHJpbmcnLCAndWludCcsICdib29sJ10pLFxuICogICBbJ3dhZ21pJywgNDIwbiwgdHJ1ZV0sXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gUGFyYW1ldGVyc1xuICpcbiAqIFNwZWNpZnkgKipKU09OIEFCSSoqIFBhcmFtZXRlcnMgYXMgc2NoZW1hOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlKFxuICogICBbXG4gKiAgICAgeyB0eXBlOiAnc3RyaW5nJywgbmFtZTogJ25hbWUnIH0sXG4gKiAgICAgeyB0eXBlOiAndWludCcsIG5hbWU6ICdhZ2UnIH0sXG4gKiAgICAgeyB0eXBlOiAnYm9vbCcsIG5hbWU6ICdpc093bmVyJyB9LFxuICogICBdLFxuICogICBbJ3dhZ21pJywgNDIwbiwgdHJ1ZV0sXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIFRoZSBzZXQgb2YgQUJJIHBhcmFtZXRlcnMgdG8gZW5jb2RlLCBpbiB0aGUgc2hhcGUgb2YgdGhlIGBpbnB1dHNgIG9yIGBvdXRwdXRzYCBhdHRyaWJ1dGUgb2YgYW4gQUJJIEl0ZW0uIFRoZXNlIHBhcmFtZXRlcnMgbXVzdCBpbmNsdWRlIHZhbGlkIFtBQkkgdHlwZXNdKGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC90eXBlcy5odG1sKS5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgc2V0IG9mIHByaW1pdGl2ZSB2YWx1ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBBQkkgdHlwZXMgZGVmaW5lZCBpbiBgcGFyYW1ldGVyc2AuXG4gKiBAcmV0dXJucyBBQkkgZW5jb2RlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHBhcmFtZXRlcnMsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzID0gZmFsc2UgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgaWYgKHBhcmFtZXRlcnMubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgTGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogcGFyYW1ldGVycy5sZW5ndGgsXG4gICAgICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgLy8gUHJlcGFyZSB0aGUgcGFyYW1ldGVycyB0byBkZXRlcm1pbmUgZHluYW1pYyB0eXBlcyB0byBlbmNvZGUuXG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gaW50ZXJuYWwucHJlcGFyZVBhcmFtZXRlcnMoe1xuICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBpbnRlcm5hbC5lbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBFbmNvZGVzIGFuIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXMgdG8gYSBbcGFja2VkIEFCSSBlbmNvZGluZ10oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2FiaS1zcGVjLmh0bWwjbm9uLXN0YW5kYXJkLXBhY2tlZC1tb2RlKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbmNvZGVkID0gQWJpUGFyYW1ldGVycy5lbmNvZGVQYWNrZWQoXG4gKiAgIFsnYWRkcmVzcycsICdzdHJpbmcnXSxcbiAqICAgWycweGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDUnLCAnaGVsbG8gd29ybGQnXSxcbiAqIClcbiAqIC8vIEBsb2c6ICcweGQ4ZGE2YmYyNjk2NGFmOWQ3ZWVkOWUwM2U1MzQxNWQzN2FhOTYwNDU2ODY1NmM2YzZmMjA3NzZmNzI2YzY0J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHR5cGVzIC0gU2V0IG9mIEFCSSB0eXBlcyB0byBwYWNrIGVuY29kZS5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgc2V0IG9mIHByaW1pdGl2ZSB2YWx1ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBBQkkgdHlwZXMgZGVmaW5lZCBpbiBgdHlwZXNgLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQgcGFja2VkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVQYWNrZWQodHlwZXMsIHZhbHVlcykge1xuICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBMZW5ndGhNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoOiB0eXBlcy5sZW5ndGgsXG4gICAgICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgZGF0YS5wdXNoKGVuY29kZVBhY2tlZC5lbmNvZGUodHlwZSwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIEhleC5jb25jYXQoLi4uZGF0YSk7XG59XG4oZnVuY3Rpb24gKGVuY29kZVBhY2tlZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG4gICAgZnVuY3Rpb24gZW5jb2RlKHR5cGUsIHZhbHVlLCBpc0FycmF5ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHZhbHVlO1xuICAgICAgICAgICAgQWRkcmVzcy5hc3NlcnQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gSGV4LnBhZExlZnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBpc0FycmF5ID8gMzIgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gSGV4LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJylcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdib29sJylcbiAgICAgICAgICAgIHJldHVybiBIZXgucGFkTGVmdChIZXguZnJvbUJvb2xlYW4odmFsdWUpLCBpc0FycmF5ID8gMzIgOiAxKTtcbiAgICAgICAgY29uc3QgaW50TWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmludGVnZXJSZWdleCk7XG4gICAgICAgIGlmIChpbnRNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgW190eXBlLCBiYXNlVHlwZSwgYml0cyA9ICcyNTYnXSA9IGludE1hdGNoO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IE51bWJlci5wYXJzZUludChiaXRzLCAxMCkgLyA4O1xuICAgICAgICAgICAgcmV0dXJuIEhleC5mcm9tTnVtYmVyKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogaXNBcnJheSA/IDMyIDogc2l6ZSxcbiAgICAgICAgICAgICAgICBzaWduZWQ6IGJhc2VUeXBlID09PSAnaW50JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzTWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmJ5dGVzUmVnZXgpO1xuICAgICAgICBpZiAoYnl0ZXNNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgW190eXBlLCBzaXplXSA9IGJ5dGVzTWF0Y2g7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KHNpemUsIDEwKSAhPT0gKHZhbHVlLmxlbmd0aCAtIDIpIC8gMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHNpemUsIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEhleC5wYWRSaWdodCh2YWx1ZSwgaXNBcnJheSA/IDMyIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJyYXlNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuYXJyYXlSZWdleCk7XG4gICAgICAgIGlmIChhcnJheU1hdGNoICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBbX3R5cGUsIGNoaWxkVHlwZV0gPSBhcnJheU1hdGNoO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChlbmNvZGUoY2hpbGRUeXBlLCB2YWx1ZVtpXSwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAnMHgnO1xuICAgICAgICAgICAgcmV0dXJuIEhleC5jb25jYXQoLi4uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuICAgIGVuY29kZVBhY2tlZC5lbmNvZGUgPSBlbmNvZGU7XG59KShlbmNvZGVQYWNrZWQgfHwgKGVuY29kZVBhY2tlZCA9IHt9KSk7XG4vKipcbiAqIEZvcm1hdHMge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuQWJpUGFyYW1ldGVyc30gaW50byAqKkh1bWFuIFJlYWRhYmxlIEFCSSBQYXJhbWV0ZXJzKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9ybWF0dGVkID0gQWJpUGFyYW1ldGVycy5mb3JtYXQoW1xuICogICB7XG4gKiAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgfSxcbiAqICAge1xuICogICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgfSxcbiAqIF0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIFRoZSBBQkkgUGFyYW1ldGVycyB0byBmb3JtYXQuXG4gKiBAcmV0dXJucyBUaGUgZm9ybWF0dGVkIEFCSSBQYXJhbWV0ZXJzICAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQocGFyYW1ldGVycykge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG59XG4vKipcbiAqIFBhcnNlcyBhcmJpdHJhcnkgKipKU09OIEFCSSBQYXJhbWV0ZXJzKiogb3IgKipIdW1hbiBSZWFkYWJsZSBBQkkgUGFyYW1ldGVycyoqIGludG8gdHlwZWQge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuQWJpUGFyYW1ldGVyc30uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIFBhcmFtZXRlcnNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBhcmFtZXRlcnMgPSBBYmlQYXJhbWV0ZXJzLmZyb20oW1xuICogICB7XG4gKiAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgfSxcbiAqICAge1xuICogICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgIHR5cGU6ICd1aW50MjU2JyxcbiAqICAgfSxcbiAqIF0pXG4gKlxuICogcGFyYW1ldGVyc1xuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSHVtYW4gUmVhZGFibGUgUGFyYW1ldGVyc1xuICpcbiAqIEh1bWFuIFJlYWRhYmxlIEFCSSBQYXJhbWV0ZXJzIGNhbiBiZSBwYXJzZWQgaW50byBhIHR5cGVkIHtAbGluayBveCNBYmlQYXJhbWV0ZXJzLkFiaVBhcmFtZXRlcnN9OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcGFyYW1ldGVycyA9IEFiaVBhcmFtZXRlcnMuZnJvbSgnYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCcpXG4gKlxuICogcGFyYW1ldGVyc1xuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBzcGVjaWZ5IGBzdHJ1Y3RgcyBhbG9uZyB3aXRoIHlvdXIgZGVmaW5pdGlvbnM6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKFtcbiAqICAgJ3N0cnVjdCBGb28geyBhZGRyZXNzIHNwZW5kZXI7IHVpbnQyNTYgYW1vdW50OyB9JywgLy8gWyFjb2RlIGhsXVxuICogICAnRm9vIGZvbywgYWRkcmVzcyBiYXInLFxuICogXSlcbiAqXG4gKiBwYXJhbWV0ZXJzXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gVGhlIEFCSSBQYXJhbWV0ZXJzIHRvIHBhcnNlLlxuICogQHJldHVybnMgVGhlIHR5cGVkIEFCSSBQYXJhbWV0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShwYXJhbWV0ZXJzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykgJiYgdHlwZW9mIHBhcmFtZXRlcnNbMF0gPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gYWJpdHlwZS5wYXJzZUFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbWV0ZXJzID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB0aGUgZGF0YSBzaXplIGlzIHRvbyBzbWFsbCBmb3IgdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ3VpbnQyNTYnIH1dLCAnMHgwMTBmJylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKdjCAyIGJ5dGVzXG4gKiAvLyBAZXJyb3I6IEFiaVBhcmFtZXRlcnMuRGF0YVNpemVUb29TbWFsbEVycm9yOiBEYXRhIHNpemUgb2YgMiBieXRlcyBpcyB0b28gc21hbGwgZm9yIGdpdmVuIHBhcmFtZXRlcnMuXG4gKiAvLyBAZXJyb3I6IFBhcmFtczogKHVpbnQyNTYpXG4gKiAvLyBAZXJyb3I6IERhdGE6ICAgMHgwMTBmICgyIGJ5dGVzKVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhIHZhbGlkIGRhdGEgc2l6ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICd1aW50MjU2JyB9XSwgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmJylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKchSAzMiBieXRlc1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhU2l6ZVRvb1NtYWxsRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEsIHBhcmFtZXRlcnMsIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYERhdGEgc2l6ZSBvZiAke3NpemV9IGJ5dGVzIGlzIHRvbyBzbWFsbCBmb3IgZ2l2ZW4gcGFyYW1ldGVycy5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICBgUGFyYW1zOiAoJHthYml0eXBlLmZvcm1hdEFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyl9KWAsXG4gICAgICAgICAgICAgICAgYERhdGE6ICAgJHtkYXRhfSAoJHtzaXplfSBieXRlcylgLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkRhdGFTaXplVG9vU21hbGxFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB6ZXJvIGRhdGEgaXMgcHJvdmlkZWQsIGJ1dCBkYXRhIGlzIGV4cGVjdGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIEFiaVBhcmFtZXRlcnMuZGVjb2RlKFt7IHR5cGU6ICd1aW50MjU2JyB9XSwgJzB4JylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinYwgemVybyBkYXRhXG4gKiAvLyBAZXJyb3I6IEFiaVBhcmFtZXRlcnMuRGF0YVNpemVUb29TbWFsbEVycm9yOiBEYXRhIHNpemUgb2YgMiBieXRlcyBpcyB0b28gc21hbGwgZm9yIGdpdmVuIHBhcmFtZXRlcnMuXG4gKiAvLyBAZXJyb3I6IFBhcmFtczogKHVpbnQyNTYpXG4gKiAvLyBAZXJyb3I6IERhdGE6ICAgMHgwMTBmICgyIGJ5dGVzKVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyB2YWxpZCBkYXRhLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ3VpbnQyNTYnIH1dLCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMGYnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4pyFIDMyIGJ5dGVzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFplcm9EYXRhRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0Nhbm5vdCBkZWNvZGUgemVybyBkYXRhIChcIjB4XCIpIHdpdGggQUJJIHBhcmFtZXRlcnMuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLlplcm9EYXRhRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIGxlbmd0aCBzcGVjaWZpZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgQUJJIHBhcmFtZXRlci5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKCd1aW50MjU2WzNdJyksIFtbNjluLCA0MjBuXV0pXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIGV4cGVjdGVkOiAzICDihpEg4p2MIGxlbmd0aDogMlxuICogLy8gQGVycm9yOiBBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcjogQUJJIGVuY29kaW5nIGFycmF5IGxlbmd0aCBtaXNtYXRjaFxuICogLy8gQGVycm9yOiBmb3IgdHlwZSBgdWludDI1NlszXWAuIEV4cGVjdGVkOiBgM2AuIEdpdmVuOiBgMmAuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGFuIGFycmF5IG9mIHRoZSBjb3JyZWN0IGxlbmd0aC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWyd1aW50MjU2WzNdJ10pLCBbWzY5biwgNDIwbiwgNjluXV0pXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinIUgbGVuZ3RoOiAzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRMZW5ndGgsIGdpdmVuTGVuZ3RoLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBBcnJheSBsZW5ndGggbWlzbWF0Y2ggZm9yIHR5cGUgXFxgJHt0eXBlfVxcYC4gRXhwZWN0ZWQ6IFxcYCR7ZXhwZWN0ZWRMZW5ndGh9XFxgLiBHaXZlbjogXFxgJHtnaXZlbkxlbmd0aH1cXGAuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgc2l6ZSBvZiB0aGUgYnl0ZXMgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIHNpemUgc3BlY2lmaWVkIGluIHRoZSBjb3JyZXNwb25kaW5nIEFCSSBwYXJhbWV0ZXIuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbSgnYnl0ZXM4JyksIFtbJzB4ZGVhZGJlZWZkZWFkYmVlZmRlYWRiZWVmJ11dKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSBleHBlY3RlZDogOCBieXRlcyAg4oaRIOKdjCBzaXplOiAxMiBieXRlc1xuICogLy8gQGVycm9yOiBCeXRlc1NpemVNaXNtYXRjaEVycm9yOiBTaXplIG9mIGJ5dGVzIFwiMHhkZWFkYmVlZmRlYWRiZWVmZGVhZGJlZWZcIlxuICogLy8gQGVycm9yOiAoYnl0ZXMxMikgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgc2l6ZSAoYnl0ZXM4KS5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYSBieXRlcyB2YWx1ZSBvZiB0aGUgY29ycmVjdCBzaXplLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbShbJ2J5dGVzOCddKSwgWycweGRlYWRiZWVmZGVhZGJlZWYnXSlcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinIUgc2l6ZTogOCBieXRlc1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBCeXRlc1NpemVNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZFNpemUsIHZhbHVlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIG9mIGJ5dGVzIFwiJHt2YWx1ZX1cIiAoYnl0ZXMke0hleC5zaXplKHZhbHVlKX0pIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHNpemUgKGJ5dGVzJHtleHBlY3RlZFNpemV9KS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgbGVuZ3RoIG9mIHRoZSB2YWx1ZXMgdG8gZW5jb2RlIGRvZXMgbm90IG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIEFCSSBwYXJhbWV0ZXJzLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWydzdHJpbmcnLCAndWludDI1NiddKSwgWydoZWxsbyddKVxuICogLy8gQGVycm9yOiBMZW5ndGhNaXNtYXRjaEVycm9yOiBBQkkgZW5jb2RpbmcgcGFyYW1zL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2guXG4gKiAvLyBAZXJyb3I6IEV4cGVjdGVkIGxlbmd0aCAocGFyYW1zKTogMlxuICogLy8gQGVycm9yOiBHaXZlbiBsZW5ndGggKHZhbHVlcyk6IDFcbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIHZhbHVlcyB0byBlbmNvZGUuXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhIFt2YWxpZCBBQkkgdHlwZV0oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vZGV2ZWxvcC9hYmktc3BlYy5odG1sI3R5cGVzKS5cbiAqL1xuZXhwb3J0IGNsYXNzIExlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkTGVuZ3RoLCBnaXZlbkxlbmd0aCwgfSkge1xuICAgICAgICBzdXBlcihbXG4gICAgICAgICAgICAnQUJJIGVuY29kaW5nIHBhcmFtZXRlcnMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaC4nLFxuICAgICAgICAgICAgYEV4cGVjdGVkIGxlbmd0aCAocGFyYW1ldGVycyk6ICR7ZXhwZWN0ZWRMZW5ndGh9YCxcbiAgICAgICAgICAgIGBHaXZlbiBsZW5ndGggKHZhbHVlcyk6ICR7Z2l2ZW5MZW5ndGh9YCxcbiAgICAgICAgXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkxlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHZhbHVlIHByb3ZpZGVkIGlzIG5vdCBhIHZhbGlkIGFycmF5IGFzIHNwZWNpZmllZCBpbiB0aGUgY29ycmVzcG9uZGluZyBBQkkgcGFyYW1ldGVyLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oWyd1aW50MjU2WzNdJ10pLCBbNjldKVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhbiBhcnJheSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRBcnJheUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIG5vdCBhIHZhbGlkIGFycmF5LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5JbnZhbGlkQXJyYXlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB0aGUgQUJJIHBhcmFtZXRlciB0eXBlIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ2xvbCcgfV0sICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZicpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKdjCBpbnZhbGlkIHR5cGVcbiAqIC8vIEBlcnJvcjogQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yOiBUeXBlIGBsb2xgIGlzIG5vdCBhIHZhbGlkIEFCSSBUeXBlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBzdXBlcihgVHlwZSBcXGAke3R5cGV9XFxgIGlzIG5vdCBhIHZhbGlkIEFCSSBUeXBlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlQYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/AccessList.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/AccessList.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidStorageKeySizeError: () => (/* binding */ InvalidStorageKeySizeError),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */\nfunction fromTupleList(accessList) {\n    const list = [];\n    for (let i = 0; i < accessList.length; i++) {\n        const [address, storageKeys] = accessList[i];\n        if (address)\n            _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, { strict: false });\n        list.push({\n            address: address,\n            storageKeys: storageKeys.map((key) => _Hash_js__WEBPACK_IMPORTED_MODULE_1__.validate(key) ? key : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.trimLeft(key)),\n        });\n    }\n    return list;\n}\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */\nfunction toTupleList(accessList) {\n    if (!accessList || accessList.length === 0)\n        return [];\n    const tuple = [];\n    for (const { address, storageKeys } of accessList) {\n        for (let j = 0; j < storageKeys.length; j++)\n            if (_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKeys[j]) !== 32)\n                throw new InvalidStorageKeySizeError({\n                    storageKey: storageKeys[j],\n                });\n        if (address)\n            _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, { strict: false });\n        tuple.push([address, storageKeys]);\n    }\n    return tuple;\n}\n/** Thrown when the size of a storage key is invalid. */\nclass InvalidStorageKeySizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ storageKey }) {\n        super(`Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKey)} bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AccessList.InvalidStorageKeySizeError'\n        });\n    }\n}\n//# sourceMappingURL=AccessList.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FjY2Vzc0xpc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3QztBQUNGO0FBQ0o7QUFDRjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBLFlBQVksK0NBQWMsWUFBWSxlQUFlO0FBQ3JEO0FBQ0E7QUFDQSxrREFBa0QsOENBQWEsY0FBYyw2Q0FBWTtBQUN6RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEMsd0JBQXdCLHdCQUF3QjtBQUNoRCxnQkFBZ0IseUNBQVE7QUFDeEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFlBQVksK0NBQWMsWUFBWSxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUMsaURBQWdCO0FBQ2hFLGtCQUFrQixZQUFZO0FBQzlCLHVDQUF1QyxXQUFXLHVDQUF1Qyx5Q0FBUSxjQUFjO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FjY2Vzc0xpc3QuanM/ZWJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ29udmVydHMgYSBsaXN0IG9mIEFjY2VzcyBMaXN0IHR1cGxlcyBpbnRvIGEgb2JqZWN0LWZvcm1hdHRlZCBsaXN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWNjZXNzTGlzdCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoW1xuICogICBbXG4gKiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgICAgW1xuICogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJyxcbiAqICAgICBdLFxuICogICBdLFxuICogXSlcbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAge1xuICogLy8gQGxvZzogICAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICAgIHN0b3JhZ2VLZXlzOiBbXG4gKiAvLyBAbG9nOiAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqIC8vIEBsb2c6ICAgICAgICcweDYwZmRkMjlmZjkxMmNlODgwY2QzZWRhZjlmOTMyZGM2MWQzZGFlODIzZWE3N2UwMzIzZjk0YWRiOWY2YTcyZmUnLFxuICogLy8gQGxvZzogICAgIF0sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWNjZXNzTGlzdCAtIExpc3Qgb2YgdHVwbGVzLlxuICogQHJldHVybnMgQWNjZXNzIGxpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGVMaXN0KGFjY2Vzc0xpc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2Nlc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFthZGRyZXNzLCBzdG9yYWdlS2V5c10gPSBhY2Nlc3NMaXN0W2ldO1xuICAgICAgICBpZiAoYWRkcmVzcylcbiAgICAgICAgICAgIEFkZHJlc3MuYXNzZXJ0KGFkZHJlc3MsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICAgICAgbGlzdC5wdXNoKHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBzdG9yYWdlS2V5czogc3RvcmFnZUtleXMubWFwKChrZXkpID0+IEhhc2gudmFsaWRhdGUoa2V5KSA/IGtleSA6IEhleC50cmltTGVmdChrZXkpKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cnVjdHVyZWQgQWNjZXNzIExpc3QgaW50byBhIGxpc3Qgb2YgdHVwbGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWNjZXNzTGlzdCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LnRvVHVwbGVMaXN0KFtcbiAqICAge1xuICogICAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAgIHN0b3JhZ2VLZXlzOiBbXG4gKiAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqICAgICAgICcweDYwZmRkMjlmZjkxMmNlODgwY2QzZWRhZjlmOTMyZGM2MWQzZGFlODIzZWE3N2UwMzIzZjk0YWRiOWY2YTcyZmUnXSxcbiAqICAgfSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgICBbXG4gKiAvLyBAbG9nOiAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqIC8vIEBsb2c6ICAgICAgICcweDYwZmRkMjlmZjkxMmNlODgwY2QzZWRhZjlmOTMyZGM2MWQzZGFlODIzZWE3N2UwMzIzZjk0YWRiOWY2YTcyZmUnLFxuICogLy8gQGxvZzogICAgIF0sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWNjZXNzTGlzdCAtIEFjY2VzcyBsaXN0LlxuICogQHJldHVybnMgTGlzdCBvZiB0dXBsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlTGlzdChhY2Nlc3NMaXN0KSB7XG4gICAgaWYgKCFhY2Nlc3NMaXN0IHx8IGFjY2Vzc0xpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3QgdHVwbGUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgYWRkcmVzcywgc3RvcmFnZUtleXMgfSBvZiBhY2Nlc3NMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RvcmFnZUtleXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICBpZiAoSGV4LnNpemUoc3RvcmFnZUtleXNbal0pICE9PSAzMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5c1tqXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFkZHJlc3MpXG4gICAgICAgICAgICBBZGRyZXNzLmFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIHR1cGxlLnB1c2goW2FkZHJlc3MsIHN0b3JhZ2VLZXlzXSk7XG4gICAgfVxuICAgIHJldHVybiB0dXBsZTtcbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2l6ZSBvZiBhIHN0b3JhZ2Uga2V5IGlzIGludmFsaWQuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHN0b3JhZ2VLZXkgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBmb3Igc3RvcmFnZSBrZXkgXCIke3N0b3JhZ2VLZXl9XCIgaXMgaW52YWxpZC4gRXhwZWN0ZWQgMzIgYnl0ZXMuIEdvdCAke0hleC5zaXplKHN0b3JhZ2VLZXkpfSBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FjY2Vzc0xpc3QuSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjY2Vzc0xpc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/AccessList.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Address.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/Address.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAddressError: () => (/* binding */ InvalidAddressError),\n/* harmony export */   InvalidChecksumError: () => (/* binding */ InvalidChecksumError),\n/* harmony export */   InvalidInputError: () => (/* binding */ InvalidInputError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromPublicKey: () => (/* binding */ fromPublicKey),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Caches_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Caches.js */ \"(ssr)/./node_modules/ox/_esm/core/Caches.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nfunction assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value))\n        throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidInputError(),\n        });\n    if (strict) {\n        if (value.toLowerCase() === value)\n            return;\n        if (checksum(value) !== value)\n            throw new InvalidAddressError({\n                address: value,\n                cause: new InvalidChecksumError(),\n            });\n    }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nfunction checksum(address) {\n    if (_Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.has(address))\n        return _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.get(address);\n    assert(address, { strict: false });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromString(hexAddress), { as: 'Bytes' });\n    const characters = hexAddress.split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join('')}`;\n    _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.set(address, result);\n    return result;\n}\n/**\n * Converts a stringified address to a typed (optionally checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: true\n * })\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nfunction from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal)\n        return checksum(address);\n    return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nfunction fromPublicKey(publicKey, options = {}) {\n    const address = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(`0x${_PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nfunction isEqual(addressA, addressB) {\n    assert(addressA, { strict: false });\n    assert(addressB, { strict: false });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nfunction validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nclass InvalidAddressError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ address, cause }) {\n        super(`Address \"${address}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidAddressError'\n        });\n    }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nclass InvalidInputError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Address is not a 20 byte (40 hexadecimal character) value.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidInputError'\n        });\n    }\n}\n/** Thrown when an address does not match its checksum counterpart. */\nclass InvalidChecksumError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Address does not match its checksum counterpart.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidChecksumError'\n        });\n    }\n}\n//# sourceMappingURL=Address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FkZHJlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNBO0FBQ0o7QUFDVTtBQUM1QyxxQ0FBcUMsR0FBRztBQUN4QztBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsZ0RBQWU7QUFDdkIsZUFBZSxnREFBZTtBQUM5QixzQkFBc0IsZUFBZTtBQUNyQztBQUNBLGlCQUFpQiwrQ0FBYyxDQUFDLGlEQUFnQixnQkFBZ0IsYUFBYTtBQUM3RTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QyxJQUFJLGdEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSx5QkFBeUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQseUJBQXlCO0FBQ3RGO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNPLDhDQUE4QztBQUNyRCxvQkFBb0IsK0NBQWMsTUFBTSxnREFBZSxxQkFBcUI7QUFDNUUscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUJBQXVCLGVBQWU7QUFDdEMsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDO0FBQzlDLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLGlEQUFnQjtBQUN6RCxrQkFBa0IsZ0JBQWdCO0FBQ2xDLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGlEQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsaURBQWdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BZGRyZXNzLmpzPzY0ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBDYWNoZXMgZnJvbSAnLi9DYWNoZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIFB1YmxpY0tleSBmcm9tICcuL1B1YmxpY0tleS5qcyc7XG5jb25zdCBhZGRyZXNzUmVnZXggPSAvXjB4W2EtZkEtRjAtOV17NDB9JC87XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmFzc2VydCgnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJylcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuYXNzZXJ0KCcweGRlYWRiZWVmJylcbiAqIC8vIEBlcnJvcjogSW52YWxpZEFkZHJlc3NFcnJvcjogQWRkcmVzcyBcIjB4ZGVhZGJlZWZcIiBpcyBpbnZhbGlkLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYXNzZXJ0IGlmIGl0IGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQXNzZXJ0aW9uIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWFkZHJlc3NSZWdleC50ZXN0KHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3Ioe1xuICAgICAgICAgICAgYWRkcmVzczogdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogbmV3IEludmFsaWRJbnB1dEVycm9yKCksXG4gICAgICAgIH0pO1xuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoY2hlY2tzdW0odmFsdWUpICE9PSB2YWx1ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjYXVzZTogbmV3IEludmFsaWRDaGVja3N1bUVycm9yKCksXG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBjaGVja3N1bSBhZGRyZXNzIGZvciB0aGUgZ2l2ZW4ge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5jaGVja3N1bSgnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJylcbiAqIC8vIEBsb2c6ICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIGNvbXB1dGUgdGhlIGNoZWNrc3VtIGZvci5cbiAqIEByZXR1cm5zIFRoZSBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tzdW0oYWRkcmVzcykge1xuICAgIGlmIChDYWNoZXMuY2hlY2tzdW0uaGFzKGFkZHJlc3MpKVxuICAgICAgICByZXR1cm4gQ2FjaGVzLmNoZWNrc3VtLmdldChhZGRyZXNzKTtcbiAgICBhc3NlcnQoYWRkcmVzcywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGhleEFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGhhc2ggPSBIYXNoLmtlY2NhazI1NihCeXRlcy5mcm9tU3RyaW5nKGhleEFkZHJlc3MpLCB7IGFzOiAnQnl0ZXMnIH0pO1xuICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBoZXhBZGRyZXNzLnNwbGl0KCcnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKGhhc2hbaSA+PiAxXSA+PiA0ID49IDggJiYgY2hhcmFjdGVyc1tpXSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyc1tpXSA9IGNoYXJhY3RlcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hbaSA+PiAxXSAmIDB4MGYpID49IDggJiYgY2hhcmFjdGVyc1tpICsgMV0pIHtcbiAgICAgICAgICAgIGNoYXJhY3RlcnNbaSArIDFdID0gY2hhcmFjdGVyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBgMHgke2NoYXJhY3RlcnMuam9pbignJyl9YDtcbiAgICBDYWNoZXMuY2hlY2tzdW0uc2V0KGFkZHJlc3MsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmdpZmllZCBhZGRyZXNzIHRvIGEgdHlwZWQgKG9wdGlvbmFsbHkgY2hlY2tzdW1tZWQpIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJylcbiAqIC8vIEBsb2c6ICcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmZyb20oJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScsIHtcbiAqICAgY2hlY2tzdW06IHRydWVcbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5mcm9tKCdoZWxsbycpXG4gKiAvLyBAZXJyb3I6IEludmFsaWRBZGRyZXNzRXJyb3I6IEFkZHJlc3MgXCIweGFcIiBpcyBpbnZhbGlkLlxuICogYGBgXG4gKlxuICogQHBhcmFtIGFkZHJlc3MgLSBBbiBhZGRyZXNzIHN0cmluZyB0byBjb252ZXJ0IHRvIGEgdHlwZWQgQWRkcmVzcy5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQ29udmVyc2lvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHR5cGVkIEFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2hlY2tzdW06IGNoZWNrc3VtVmFsID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgYXNzZXJ0KGFkZHJlc3MpO1xuICAgIGlmIChjaGVja3N1bVZhbClcbiAgICAgICAgcmV0dXJuIGNoZWNrc3VtKGFkZHJlc3MpO1xuICAgIHJldHVybiBhZGRyZXNzO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBFQ0RTQSBwdWJsaWMga2V5IHRvIGFuIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcywgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oXG4gKiAgICcweDA0ODMxODUzNWI1NDEwNWQ0YTdhYWU2MGMwOGZjNDVmOTY4NzE4MWI0ZmRmYzYyNWJkMWE3NTNmYTczOTdmZWQ3NTM1NDdmMTFjYTg2OTY2NDZmMmYzYWNiMDhlMzEwMTZhZmFjMjNlNjMwYzVkMTFmNTlmNjFmZWY1N2IwZDJhYTUnLFxuICogKVxuICogY29uc3QgYWRkcmVzcyA9IEFkZHJlc3MuZnJvbVB1YmxpY0tleShwdWJsaWNLZXkpXG4gKiAvLyBAbG9nOiAnMHhmMzlmZDZlNTFhYWQ4OGY2ZjRjZTZhYjg4MjcyNzljZmZmYjkyMjY2J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBFQ0RTQSBwdWJsaWMga2V5IHRvIGNvbnZlcnQgdG8gYW4ge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbnZlcnNpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVB1YmxpY0tleShwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBIYXNoLmtlY2NhazI1NihgMHgke1B1YmxpY0tleS50b0hleChwdWJsaWNLZXkpLnNsaWNlKDQpfWApLnN1YnN0cmluZygyNik7XG4gICAgcmV0dXJuIGZyb20oYDB4JHthZGRyZXNzfWAsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9IGFyZSBlcXVhbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmlzRXF1YWwoXG4gKiAgICcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnLFxuICogICAnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJ1xuICogKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5pc0VxdWFsKFxuICogICAnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJyxcbiAqICAgJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZidcbiAqIClcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWRkcmVzc0EgLSBUaGUgZmlyc3QgYWRkcmVzcyB0byBjb21wYXJlLlxuICogQHBhcmFtIGFkZHJlc3NCIC0gVGhlIHNlY29uZCBhZGRyZXNzIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBhZGRyZXNzZXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbChhZGRyZXNzQSwgYWRkcmVzc0IpIHtcbiAgICBhc3NlcnQoYWRkcmVzc0EsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBhc3NlcnQoYWRkcmVzc0IsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICByZXR1cm4gYWRkcmVzc0EudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzc0IudG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhZGRyZXNzIGlzIGEgdmFsaWQge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy52YWxpZGF0ZSgnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MudmFsaWRhdGUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gVmFsdWUgdG8gY2hlY2sgaWYgaXQgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBDaGVjayBvcHRpb25zLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IHRydWUgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KGFkZHJlc3MsIHsgc3RyaWN0IH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhbiBhZGRyZXNzIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5mcm9tKCcweDEyMycpXG4gKiAvLyBAZXJyb3I6IEFkZHJlc3MuSW52YWxpZEFkZHJlc3NFcnJvcjogQWRkcmVzcyBgMHgxMjNgIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRBZGRyZXNzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGFkZHJlc3MsIGNhdXNlIH0pIHtcbiAgICAgICAgc3VwZXIoYEFkZHJlc3MgXCIke2FkZHJlc3N9XCIgaXMgaW52YWxpZC5gLCB7XG4gICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBZGRyZXNzLkludmFsaWRBZGRyZXNzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiBhbiBhZGRyZXNzIGlzIG5vdCBhIDIwIGJ5dGUgKDQwIGhleGFkZWNpbWFsIGNoYXJhY3RlcikgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZElucHV0RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0FkZHJlc3MgaXMgbm90IGEgMjAgYnl0ZSAoNDAgaGV4YWRlY2ltYWwgY2hhcmFjdGVyKSB2YWx1ZS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FkZHJlc3MuSW52YWxpZElucHV0RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiBhbiBhZGRyZXNzIGRvZXMgbm90IG1hdGNoIGl0cyBjaGVja3N1bSBjb3VudGVycGFydC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQ2hlY2tzdW1FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQWRkcmVzcyBkb2VzIG5vdCBtYXRjaCBpdHMgY2hlY2tzdW0gY291bnRlcnBhcnQuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBZGRyZXNzLkludmFsaWRDaGVja3N1bUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Authorization.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/Authorization.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcList: () => (/* binding */ fromRpcList),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcList: () => (/* binding */ toRpcList),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(ssr)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nfunction from(authorization, options = {}) {\n    if (typeof authorization.chainId === 'string')\n        return fromRpc(authorization);\n    return { ...authorization, ...options.signature };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */\nfunction fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature,\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */\nfunction fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nfunction fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    let args = {\n        address,\n        chainId: chainId === '0x' ? 0 : Number(chainId),\n        nonce: nonce === '0x' ? 0n : BigInt(nonce),\n    };\n    if (yParity && r && s)\n        args = { ...args, ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromTuple([yParity, r, s]) };\n    return from(args);\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */\nfunction fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)\n        list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */\nfunction getSignPayload(authorization) {\n    return hash(authorization, { presign: true });\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */\nfunction hash(authorization, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat('0x05', _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(presign\n        ? {\n            address: authorization.address,\n            chainId: authorization.chainId,\n            nonce: authorization.nonce,\n        }\n        : authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */\nfunction toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature),\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */\nfunction toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */\nfunction toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return [\n        chainId ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : '0x',\n        address,\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : '0x',\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.toTuple(signature) : []),\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */\nfunction toTupleList(list) {\n    if (!list || list.length === 0)\n        return [];\n    const tupleList = [];\n    for (const authorization of list)\n        tupleList.push(toTuple(authorization));\n    return tupleList;\n}\n//# sourceMappingURL=Authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0F1dGhvcml6YXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ0Y7QUFDQTtBQUNZO0FBQzVDO0FBQ0Esc0dBQXNHLHFDQUFxQztBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4QkFBOEI7QUFDcEMsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9FQUFvRSxXQUFXO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFDQUFxQztBQUN0RDtBQUNPLHlDQUF5QztBQUNoRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCLE9BQU8scUNBQXFDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNPO0FBQ1AsWUFBWSwwQkFBMEI7QUFDdEMsc0JBQXNCLGtEQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQyxPQUFPLDRCQUE0QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDTztBQUNQO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUNBQXFDO0FBQ3BFO0FBQ0E7QUFDTztBQUNQLFlBQVksMEJBQTBCO0FBQ3RDLHNCQUFzQixrREFBaUI7QUFDdkM7QUFDQSxrQkFBa0IsK0NBQWM7QUFDaEM7QUFDQSxnQkFBZ0IsK0NBQWM7QUFDOUIsd0JBQXdCLGtEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCLE9BQU8saUNBQWlDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQXV0aG9yaXphdGlvbi5qcz9kNDcwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBSbHAgZnJvbSAnLi9SbHAuanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlIGZyb20gJy4vU2lnbmF0dXJlLmpzJztcbi8qKlxuICogQ29udmVydHMgYW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gb2JqZWN0IGludG8gYSB0eXBlZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogQW4gQXV0aG9yaXphdGlvbiBjYW4gYmUgaW5zdGFudGlhdGVkIGZyb20gYW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgaW4gb2JqZWN0IGZvcm1hdC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogQSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gY2FuIGJlIGF0dGFjaGVkIHdpdGggdGhlIGBzaWduYXR1cmVgIG9wdGlvbi4gVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIHNpZ25pbmdcbiAqIGFuIEF1dGhvcml6YXRpb24gd2l0aCB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDQwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uX3NpZ25lZCA9IEF1dGhvcml6YXRpb24uZnJvbShhdXRob3JpemF0aW9uLCB7IHNpZ25hdHVyZSB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGluIG9iamVjdCBmb3JtYXQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEF1dGhvcml6YXRpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYXV0aG9yaXphdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBhdXRob3JpemF0aW9uLmNoYWluSWQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZnJvbVJwYyhhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4geyAuLi5hdXRob3JpemF0aW9uLCAuLi5vcHRpb25zLnNpZ25hdHVyZSB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5ScGN9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb21ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogJzB4MScsXG4gKiAgIG5vbmNlOiAnMHgxJyxcbiAqICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICB5UGFyaXR5OiAnMHgwJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBIHNpZ25lZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMoYXV0aG9yaXphdGlvbikge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCwgbm9uY2UgfSA9IGF1dGhvcml6YXRpb247XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3QoYXV0aG9yaXphdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZTogQmlnSW50KG5vbmNlKSxcbiAgICAgICAgLi4uc2lnbmF0dXJlLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3RScGN9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi5mcm9tUnBjTGlzdChbe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogJzB4MScsXG4gKiAgIG5vbmNlOiAnMHgxJyxcbiAqICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICB5UGFyaXR5OiAnMHgwJyxcbiAqIH1dKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb25MaXN0IC0gVGhlIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbiBsaXN0LlxuICogQHJldHVybnMgQSBzaWduZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjTGlzdChhdXRob3JpemF0aW9uTGlzdCkge1xuICAgIHJldHVybiBhdXRob3JpemF0aW9uTGlzdC5tYXAoZnJvbVJwYyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tVHVwbGUoW1xuICogICAnMHgxJyxcbiAqICAgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgICcweDMnXG4gKiBdKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDNuXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhcHBlbmQgYSBTaWduYXR1cmUgdHVwbGUgdG8gdGhlIGVuZCBvZiBhbiBBdXRob3JpemF0aW9uIHR1cGxlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlKFtcbiAqICAgJzB4MScsXG4gKiAgICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICAnMHgzJyxcbiAqICAgJzB4MScsXG4gKiAgICcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnLFxuICogICAnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyxcbiAqIF0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBub25jZTogM25cbiAqIC8vIEBsb2c6ICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgczogQmlnSW50KCcweDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnKSxcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZSAtIFRoZSBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZSh0dXBsZSkge1xuICAgIGNvbnN0IFtjaGFpbklkLCBhZGRyZXNzLCBub25jZSwgeVBhcml0eSwgciwgc10gPSB0dXBsZTtcbiAgICBsZXQgYXJncyA9IHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogY2hhaW5JZCA9PT0gJzB4JyA/IDAgOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBub25jZSA9PT0gJzB4JyA/IDBuIDogQmlnSW50KG5vbmNlKSxcbiAgICB9O1xuICAgIGlmICh5UGFyaXR5ICYmIHIgJiYgcylcbiAgICAgICAgYXJncyA9IHsgLi4uYXJncywgLi4uU2lnbmF0dXJlLmZyb21UdXBsZShbeVBhcml0eSwgciwgc10pIH07XG4gICAgcmV0dXJuIGZyb20oYXJncyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlTGlzdH0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZUxpc3QoW1xuICogICBbJzB4MScsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgzJ10sXG4gKiAgIFsnMHgzJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDE0J10sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogM24sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhcHBlbmQgYSBTaWduYXR1cmUgdHVwbGUgdG8gdGhlIGVuZCBvZiBhbiBBdXRob3JpemF0aW9uIHR1cGxlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZUxpc3QoW1xuICogICBbJzB4MScsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgzJywgJzB4MScsICcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnLCAnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0J10sXG4gKiAgIFsnMHgzJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDE0JywgJzB4MScsICcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnLCAnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0J10sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogM24sXG4gKiAvLyBAbG9nOiAgICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGVMaXN0IC0gVGhlIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGxpc3QuXG4gKiBAcmV0dXJucyBBbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZUxpc3QodHVwbGVMaXN0KSB7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgdHVwbGUgb2YgdHVwbGVMaXN0KVxuICAgICAgICBsaXN0LnB1c2goZnJvbVR1cGxlKHR1cGxlKSk7XG4gICAgcmV0dXJuIGxpc3Q7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBzaWduIHBheWxvYWQgZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IGluIFtFSVAtNzcwMiBmb3JtYXRdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMik6IGBrZWNjYWsyNTYoJzB4MDUnIHx8IHJscChbY2hhaW5faWQsIGFkZHJlc3MsIG5vbmNlXSkpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGNvbXB1dGluZyB0aGUgc2lnbiBwYXlsb2FkIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS4gVGhpcyBwYXlsb2FkXG4gKiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8gc2lnbmluZyBmdW5jdGlvbnMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZCxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSB7XG4gICAgcmV0dXJuIGhhc2goYXV0aG9yaXphdGlvbiwgeyBwcmVzaWduOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgaGFzaCBmb3IgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0gaW4gW0VJUC03NzAyIGZvcm1hdF0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKTogYGtlY2NhazI1NignMHgwNScgfHwgcmxwKFtjaGFpbl9pZCwgYWRkcmVzcywgbm9uY2VdKSlgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IEF1dGhvcml6YXRpb24uaGFzaChhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIFRoZSBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChhdXRob3JpemF0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHByZXNpZ24gfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KEhleC5jb25jYXQoJzB4MDUnLCBSbHAuZnJvbUhleCh0b1R1cGxlKHByZXNpZ25cbiAgICAgICAgPyB7XG4gICAgICAgICAgICBhZGRyZXNzOiBhdXRob3JpemF0aW9uLmFkZHJlc3MsXG4gICAgICAgICAgICBjaGFpbklkOiBhdXRob3JpemF0aW9uLmNoYWluSWQsXG4gICAgICAgICAgICBub25jZTogYXV0aG9yaXphdGlvbi5ub25jZSxcbiAgICAgICAgfVxuICAgICAgICA6IGF1dGhvcml6YXRpb24pKSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLnRvUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAxbixcbiAqICAgcjogNDQ5NDQ2Mjc4MTMwMDc3NzI4OTczOTE1MzEyMzAwODE2OTUxMDI3MDMyODkxMjMzMzIxODc2OTYxMTUxODExMDQ3MzkyMzkxOTc1MTduLFxuICogICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgIHlQYXJpdHk6IDAsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBBbiBBdXRob3JpemF0aW9uLlxuICogQHJldHVybnMgQW4gUlBDLWZvcm1hdHRlZCBBdXRob3JpemF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoYXV0aG9yaXphdGlvbikge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCwgbm9uY2UsIC4uLnNpZ25hdHVyZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IEhleC5mcm9tTnVtYmVyKG5vbmNlKSxcbiAgICAgICAgLi4uU2lnbmF0dXJlLnRvUnBjKHNpZ25hdHVyZSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdFJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24udG9ScGNMaXN0KFt7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMW4sXG4gKiAgIHI6IDQ0OTQ0NjI3ODEzMDA3NzcyODk3MzkxNTMxMjMwMDgxNjk1MTAyNzAzMjg5MTIzMzMyMTg3Njk2MTE1MTgxMTA0NzM5MjM5MTk3NTE3bixcbiAqICAgczogMzY1Mjg1MDM1MDUxOTI0MzgzMDczNTUxNjQ0NDExMDQwMDEzMTA1NjY1MDUzNTE5ODAzNjkwODUyMDgxNzg3MTI2Nzg3OTkxODExMjBuLFxuICogICB5UGFyaXR5OiAwLFxuICogfV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbkxpc3QgLSBBbiBBdXRob3JpemF0aW9uIExpc3QuXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24gTGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjTGlzdChhdXRob3JpemF0aW9uTGlzdCkge1xuICAgIHJldHVybiBhdXRob3JpemF0aW9uTGlzdC5tYXAodG9ScGMpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5UdXBsZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCB0dXBsZSA9IEF1dGhvcml6YXRpb24udG9UdXBsZShhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBub25jZTogNjluLFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKiBAcmV0dXJucyBBbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGUoYXV0aG9yaXphdGlvbikge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCwgbm9uY2UgfSA9IGF1dGhvcml6YXRpb247XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3QoYXV0aG9yaXphdGlvbik7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY2hhaW5JZCA/IEhleC5mcm9tTnVtYmVyKGNoYWluSWQpIDogJzB4JyxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLnRvVHVwbGUoc2lnbmF0dXJlKSA6IFtdKSxcbiAgICBdO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5UdXBsZUxpc3R9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fMSA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fMiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAzLFxuICogICBub25jZTogMjBuLFxuICogfSlcbiAqXG4gKiBjb25zdCB0dXBsZSA9IEF1dGhvcml6YXRpb24udG9UdXBsZUxpc3QoW2F1dGhvcml6YXRpb25fMSwgYXV0aG9yaXphdGlvbl8yXSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICBbXG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogNjluLFxuICogLy8gQGxvZzogICBdLFxuICogLy8gQGxvZzogICBbXG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMyxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogMjBuLFxuICogLy8gQGxvZzogICBdLFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGxpc3QgLSBBbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqIEByZXR1cm5zIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGxpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlTGlzdChsaXN0KSB7XG4gICAgaWYgKCFsaXN0IHx8IGxpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3QgdHVwbGVMaXN0ID0gW107XG4gICAgZm9yIChjb25zdCBhdXRob3JpemF0aW9uIG9mIGxpc3QpXG4gICAgICAgIHR1cGxlTGlzdC5wdXNoKHRvVHVwbGUoYXV0aG9yaXphdGlvbikpO1xuICAgIHJldHVybiB0dXBsZUxpc3Q7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRob3JpemF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Authorization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Base64.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Base64.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toString: () => (/* binding */ toString)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst integerToCharacter = /*#__PURE__*/ Object.fromEntries(Array.from('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').map((a, i) => [i, a.charCodeAt(0)]));\nconst characterToInteger = /*#__PURE__*/ {\n    ...Object.fromEntries(Array.from('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').map((a, i) => [a.charCodeAt(0), i])),\n    ['='.charCodeAt(0)]: 0,\n    ['-'.charCodeAt(0)]: 62,\n    ['_'.charCodeAt(0)]: 63,\n};\n/**\n * Encodes a {@link ox#Bytes.Bytes} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The byte array to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nfunction fromBytes(value, options = {}) {\n    const { pad = true, url = false } = options;\n    const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4);\n    for (let i = 0, j = 0; j < value.length; i += 4, j += 3) {\n        const y = (value[j] << 16) + (value[j + 1] << 8) + (value[j + 2] | 0);\n        encoded[i] = integerToCharacter[y >> 18];\n        encoded[i + 1] = integerToCharacter[(y >> 12) & 0x3f];\n        encoded[i + 2] = integerToCharacter[(y >> 6) & 0x3f];\n        encoded[i + 3] = integerToCharacter[y & 0x3f];\n    }\n    const k = value.length % 3;\n    const end = Math.floor(value.length / 3) * 4 + (k && k + 1);\n    let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, end));\n    if (pad && k === 1)\n        base64 += '==';\n    if (pad && k === 2)\n        base64 += '=';\n    if (url)\n        base64 = base64.replaceAll('+', '-').replaceAll('/', '_');\n    return base64;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The hex value to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nfunction fromHex(value, options = {}) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(value), options);\n}\n/**\n * Encodes a string to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world')\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world', { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello wod', { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The string to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nfunction fromString(value, options = {}) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromString(value), options);\n}\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.toBytes('aGVsbG8gd29ybGQ=')\n * // @log: Uint8Array([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Bytes.Bytes}.\n */\nfunction toBytes(value) {\n    const base64 = value.replace(/=+$/, '');\n    const size = base64.length;\n    const decoded = new Uint8Array(size + 3);\n    encoder.encodeInto(base64 + '===', decoded);\n    for (let i = 0, j = 0; i < base64.length; i += 4, j += 3) {\n        const x = (characterToInteger[decoded[i]] << 18) +\n            (characterToInteger[decoded[i + 1]] << 12) +\n            (characterToInteger[decoded[i + 2]] << 6) +\n            characterToInteger[decoded[i + 3]];\n        decoded[j] = x >> 16;\n        decoded[j + 1] = (x >> 8) & 0xff;\n        decoded[j + 2] = x & 0xff;\n    }\n    const decodedSize = (size >> 2) * 3 + (size % 4 && (size % 4) - 1);\n    return new Uint8Array(decoded.buffer, 0, decodedSize);\n}\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.toHex('aGVsbG8gd29ybGQ=')\n * // @log: 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Hex.Hex}.\n */\nfunction toHex(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(toBytes(value));\n}\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to a string.\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.toString('aGVsbG8gd29ybGQ=')\n * // @log: 'hello world'\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded string.\n */\nfunction toString(value) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.toString(toBytes(value));\n}\n//# sourceMappingURL=Base64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Jhc2U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvQztBQUNKO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EscUVBQXFFLFlBQVk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0Esb0VBQW9FLFdBQVc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0EsaUVBQWlFLFlBQVk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBLGdFQUFnRSxXQUFXO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sb0NBQW9DO0FBQzNDLHFCQUFxQiw4Q0FBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QztBQUM5QyxxQkFBcUIsaURBQWdCO0FBQ3JDO0FBQ0E7QUFDQSwwRkFBMEYscUJBQXFCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsaUJBQWlCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ087QUFDUCxXQUFXLDhDQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLCtDQUFjO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQmFzZTY0LmpzPzIyYjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuY29uc3QgZW5jb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHRFbmNvZGVyKCk7XG5jb25zdCBkZWNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGludGVnZXJUb0NoYXJhY3RlciA9IC8qI19fUFVSRV9fKi8gT2JqZWN0LmZyb21FbnRyaWVzKEFycmF5LmZyb20oJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKS5tYXAoKGEsIGkpID0+IFtpLCBhLmNoYXJDb2RlQXQoMCldKSk7XG5jb25zdCBjaGFyYWN0ZXJUb0ludGVnZXIgPSAvKiNfX1BVUkVfXyovIHtcbiAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoQXJyYXkuZnJvbSgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLm1hcCgoYSwgaSkgPT4gW2EuY2hhckNvZGVBdCgwKSwgaV0pKSxcbiAgICBbJz0nLmNoYXJDb2RlQXQoMCldOiAwLFxuICAgIFsnLScuY2hhckNvZGVBdCgwKV06IDYyLFxuICAgIFsnXycuY2hhckNvZGVBdCgwKV06IDYzLFxufTtcbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgKHdpdGggb3B0aW9uYWwgcGFkZGluZyBhbmQvb3IgVVJMLXNhZmUgY2hhcmFjdGVycykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCYXNlNjQsIEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQuZnJvbUJ5dGVzKEJ5dGVzLmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJykpXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRPSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgTm8gUGFkZGluZ1xuICpcbiAqIFR1cm4gb2ZmIFtwYWRkaW5nIG9mIGVuY29kZWQgZGF0YV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tMy4yKSB3aXRoIHRoZSBgcGFkYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC5mcm9tQnl0ZXMoQnl0ZXMuZnJvbVN0cmluZygnaGVsbG8gd29ybGQnKSwgeyBwYWQ6IGZhbHNlIH0pXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRJ1xuICogYGBgXG4gKlxuICogIyMjIFVSTC1zYWZlIEVuY29kaW5nXG4gKlxuICogVHVybiBvbiBbVVJMLXNhZmUgZW5jb2RpbmddKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTUpIChCYXNlNjQgVVJMKSB3aXRoIHRoZSBgdXJsYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC5mcm9tQnl0ZXMoQnl0ZXMuZnJvbVN0cmluZygnaGVsbG8gd29/ZCcpLCB7IHVybDogdHJ1ZSB9KVxuICogLy8gQGxvZzogJ2FHVnNiRzhnZDI5Xzc3LTlaQT09J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGJ5dGUgYXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIEJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwYWQgPSB0cnVlLCB1cmwgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbmNvZGVkID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMpICogNCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBpICs9IDQsIGogKz0gMykge1xuICAgICAgICBjb25zdCB5ID0gKHZhbHVlW2pdIDw8IDE2KSArICh2YWx1ZVtqICsgMV0gPDwgOCkgKyAodmFsdWVbaiArIDJdIHwgMCk7XG4gICAgICAgIGVuY29kZWRbaV0gPSBpbnRlZ2VyVG9DaGFyYWN0ZXJbeSA+PiAxOF07XG4gICAgICAgIGVuY29kZWRbaSArIDFdID0gaW50ZWdlclRvQ2hhcmFjdGVyWyh5ID4+IDEyKSAmIDB4M2ZdO1xuICAgICAgICBlbmNvZGVkW2kgKyAyXSA9IGludGVnZXJUb0NoYXJhY3RlclsoeSA+PiA2KSAmIDB4M2ZdO1xuICAgICAgICBlbmNvZGVkW2kgKyAzXSA9IGludGVnZXJUb0NoYXJhY3Rlclt5ICYgMHgzZl07XG4gICAgfVxuICAgIGNvbnN0IGsgPSB2YWx1ZS5sZW5ndGggJSAzO1xuICAgIGNvbnN0IGVuZCA9IE1hdGguZmxvb3IodmFsdWUubGVuZ3RoIC8gMykgKiA0ICsgKGsgJiYgayArIDEpO1xuICAgIGxldCBiYXNlNjQgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShlbmNvZGVkLmJ1ZmZlciwgMCwgZW5kKSk7XG4gICAgaWYgKHBhZCAmJiBrID09PSAxKVxuICAgICAgICBiYXNlNjQgKz0gJz09JztcbiAgICBpZiAocGFkICYmIGsgPT09IDIpXG4gICAgICAgIGJhc2U2NCArPSAnPSc7XG4gICAgaWYgKHVybClcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnJlcGxhY2VBbGwoJysnLCAnLScpLnJlcGxhY2VBbGwoJy8nLCAnXycpO1xuICAgIHJldHVybiBiYXNlNjQ7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdG8gYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgKHdpdGggb3B0aW9uYWwgcGFkZGluZyBhbmQvb3IgVVJMLXNhZmUgY2hhcmFjdGVycykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCYXNlNjQsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LmZyb21IZXgoSGV4LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJykpXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRPSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgTm8gUGFkZGluZ1xuICpcbiAqIFR1cm4gb2ZmIFtwYWRkaW5nIG9mIGVuY29kZWQgZGF0YV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tMy4yKSB3aXRoIHRoZSBgcGFkYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQuZnJvbUhleChIZXguZnJvbVN0cmluZygnaGVsbG8gd29ybGQnKSwgeyBwYWQ6IGZhbHNlIH0pXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRJ1xuICogYGBgXG4gKlxuICogIyMjIFVSTC1zYWZlIEVuY29kaW5nXG4gKlxuICogVHVybiBvbiBbVVJMLXNhZmUgZW5jb2RpbmddKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTUpIChCYXNlNjQgVVJMKSB3aXRoIHRoZSBgdXJsYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsdWUgPSBCYXNlNjQuZnJvbUhleChIZXguZnJvbVN0cmluZygnaGVsbG8gd29/ZCcpLCB7IHVybDogdHJ1ZSB9KVxuICogLy8gQGxvZzogJ2FHVnNiRzhnZDI5Xzc3LTlaQT09J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGhleCB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhCeXRlcy5mcm9tSGV4KHZhbHVlKSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgdG8gYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgKHdpdGggb3B0aW9uYWwgcGFkZGluZyBhbmQvb3IgVVJMLXNhZmUgY2hhcmFjdGVycykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCYXNlNjQgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC5mcm9tU3RyaW5nKCdoZWxsbyB3b3JsZCcpXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRPSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgTm8gUGFkZGluZ1xuICpcbiAqIFR1cm4gb2ZmIFtwYWRkaW5nIG9mIGVuY29kZWQgZGF0YV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjQ4I3NlY3Rpb24tMy4yKSB3aXRoIHRoZSBgcGFkYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJywgeyBwYWQ6IGZhbHNlIH0pXG4gKiAvLyBAbG9nOiAnYUdWc2JHOGdkMjl5YkdRJ1xuICogYGBgXG4gKlxuICogIyMjIFVSTC1zYWZlIEVuY29kaW5nXG4gKlxuICogVHVybiBvbiBbVVJMLXNhZmUgZW5jb2RpbmddKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTUpIChCYXNlNjQgVVJMKSB3aXRoIHRoZSBgdXJsYCBvcHRpb246XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LmZyb21TdHJpbmcoJ2hlbGxvIHdvf2QnLCB7IHVybDogdHJ1ZSB9KVxuICogLy8gQGxvZzogJ2FHVnNiRzhnZDI5Xzc3LTlaQT09J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhCeXRlcy5mcm9tU3RyaW5nKHZhbHVlKSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgKHdpdGggb3B0aW9uYWwgcGFkZGluZyBhbmQvb3IgVVJMLXNhZmUgY2hhcmFjdGVycykgdG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCwgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWx1ZSA9IEJhc2U2NC50b0J5dGVzKCdhR1ZzYkc4Z2QyOXliR1E9JylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZywgaGV4IHZhbHVlLCBvciBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBCYXNlNjQgZGVjb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSkge1xuICAgIGNvbnN0IGJhc2U2NCA9IHZhbHVlLnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBjb25zdCBzaXplID0gYmFzZTY0Lmxlbmd0aDtcbiAgICBjb25zdCBkZWNvZGVkID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSArIDMpO1xuICAgIGVuY29kZXIuZW5jb2RlSW50byhiYXNlNjQgKyAnPT09JywgZGVjb2RlZCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgYmFzZTY0Lmxlbmd0aDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICAgICAgY29uc3QgeCA9IChjaGFyYWN0ZXJUb0ludGVnZXJbZGVjb2RlZFtpXV0gPDwgMTgpICtcbiAgICAgICAgICAgIChjaGFyYWN0ZXJUb0ludGVnZXJbZGVjb2RlZFtpICsgMV1dIDw8IDEyKSArXG4gICAgICAgICAgICAoY2hhcmFjdGVyVG9JbnRlZ2VyW2RlY29kZWRbaSArIDJdXSA8PCA2KSArXG4gICAgICAgICAgICBjaGFyYWN0ZXJUb0ludGVnZXJbZGVjb2RlZFtpICsgM11dO1xuICAgICAgICBkZWNvZGVkW2pdID0geCA+PiAxNjtcbiAgICAgICAgZGVjb2RlZFtqICsgMV0gPSAoeCA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGRlY29kZWRbaiArIDJdID0geCAmIDB4ZmY7XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZWRTaXplID0gKHNpemUgPj4gMikgKiAzICsgKHNpemUgJSA0ICYmIChzaXplICUgNCkgLSAxKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZC5idWZmZXIsIDAsIGRlY29kZWRTaXplKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyAod2l0aCBvcHRpb25hbCBwYWRkaW5nIGFuZC9vciBVUkwtc2FmZSBjaGFyYWN0ZXJzKSB0byB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCYXNlNjQsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LnRvSGV4KCdhR1ZzYkc4Z2QyOXliR1E9JylcbiAqIC8vIEBsb2c6IDB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZywgaGV4IHZhbHVlLCBvciBieXRlIGFycmF5IHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBCYXNlNjQgZGVjb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleCh2YWx1ZSkge1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHRvQnl0ZXModmFsdWUpKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyAod2l0aCBvcHRpb25hbCBwYWRkaW5nIGFuZC9vciBVUkwtc2FmZSBjaGFyYWN0ZXJzKSB0byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJhc2U2NCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbHVlID0gQmFzZTY0LnRvU3RyaW5nKCdhR1ZzYkc4Z2QyOXliR1E9JylcbiAqIC8vIEBsb2c6ICdoZWxsbyB3b3JsZCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcsIGhleCB2YWx1ZSwgb3IgYnl0ZSBhcnJheSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgQmFzZTY0IGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gQnl0ZXMudG9TdHJpbmcodG9CeXRlcyh2YWx1ZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Base64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/BlockOverrides.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/BlockOverrides.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Withdrawal.js */ \"(ssr)/./node_modules/ox/_esm/core/Withdrawal.js\");\n\n\n/**\n * Converts an {@link ox#BlockOverrides.Rpc} to an {@link ox#BlockOverrides.BlockOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.fromRpc({\n *   baseFeePerGas: '0x1',\n *   blobBaseFee: '0x2',\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: '0x4',\n *   number: '0x5',\n *   prevRandao: '0x6',\n *   time: '0x1234567890',\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: '0x1',\n *       index: '0x0',\n *       validatorIndex: '0x1',\n *     },\n *   ],\n * })\n * ```\n *\n * @param rpcBlockOverrides - The RPC block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.BlockOverrides}.\n */\nfunction fromRpc(rpcBlockOverrides) {\n    return {\n        ...(rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas),\n        }),\n        ...(rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee),\n        }),\n        ...(rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient,\n        }),\n        ...(rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit),\n        }),\n        ...(rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number),\n        }),\n        ...(rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao),\n        }),\n        ...(rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time),\n        }),\n        ...(rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc),\n        }),\n    };\n}\n/**\n * Converts an {@link ox#BlockOverrides.BlockOverrides} to an {@link ox#BlockOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.toRpc({\n *   baseFeePerGas: 1n,\n *   blobBaseFee: 2n,\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: 4n,\n *   number: 5n,\n *   prevRandao: 6n,\n *   time: 78187493520n,\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: 1n,\n *       index: 0,\n *       validatorIndex: 1,\n *     },\n *   ],\n * })\n * ```\n *\n * @param blockOverrides - The block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.Rpc}.\n */\nfunction toRpc(blockOverrides) {\n    return {\n        ...(typeof blockOverrides.baseFeePerGas === 'bigint' && {\n            baseFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.baseFeePerGas),\n        }),\n        ...(typeof blockOverrides.blobBaseFee === 'bigint' && {\n            blobBaseFee: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.blobBaseFee),\n        }),\n        ...(typeof blockOverrides.feeRecipient === 'string' && {\n            feeRecipient: blockOverrides.feeRecipient,\n        }),\n        ...(typeof blockOverrides.gasLimit === 'bigint' && {\n            gasLimit: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.gasLimit),\n        }),\n        ...(typeof blockOverrides.number === 'bigint' && {\n            number: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.number),\n        }),\n        ...(typeof blockOverrides.prevRandao === 'bigint' && {\n            prevRandao: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.prevRandao),\n        }),\n        ...(typeof blockOverrides.time === 'bigint' && {\n            time: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.time),\n        }),\n        ...(blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.toRpc),\n        }),\n    };\n}\n//# sourceMappingURL=BlockOverrides.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Jsb2NrT3ZlcnJpZGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0M7QUFDYztBQUM5QztBQUNBLGdCQUFnQiw2QkFBNkIsT0FBTyx1Q0FBdUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUM7QUFDcEU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDJEQUEyRCxtREFBa0I7QUFDN0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3Q0FBd0MsT0FBTyw0QkFBNEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0QkFBNEI7QUFDekQ7QUFDTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkIsK0NBQWM7QUFDekMsU0FBUztBQUNUO0FBQ0EseUJBQXlCLCtDQUFjO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLCtDQUFjO0FBQ3BDLFNBQVM7QUFDVDtBQUNBLG9CQUFvQiwrQ0FBYztBQUNsQyxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IsK0NBQWM7QUFDdEMsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLCtDQUFjO0FBQ2hDLFNBQVM7QUFDVDtBQUNBLHdEQUF3RCxpREFBZ0I7QUFDeEUsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbG9ja092ZXJyaWRlcy5qcz85MmE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBXaXRoZHJhd2FsIGZyb20gJy4vV2l0aGRyYXdhbC5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5ScGN9IHRvIGFuIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5CbG9ja092ZXJyaWRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbG9ja092ZXJyaWRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2NrT3ZlcnJpZGVzID0gQmxvY2tPdmVycmlkZXMuZnJvbVJwYyh7XG4gKiAgIGJhc2VGZWVQZXJHYXM6ICcweDEnLFxuICogICBibG9iQmFzZUZlZTogJzB4MicsXG4gKiAgIGZlZVJlY2lwaWVudDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGdhc0xpbWl0OiAnMHg0JyxcbiAqICAgbnVtYmVyOiAnMHg1JyxcbiAqICAgcHJldlJhbmRhbzogJzB4NicsXG4gKiAgIHRpbWU6ICcweDEyMzQ1Njc4OTAnLFxuICogICB3aXRoZHJhd2FsczogW1xuICogICAgIHtcbiAqICAgICAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAgICAgYW1vdW50OiAnMHgxJyxcbiAqICAgICAgIGluZGV4OiAnMHgwJyxcbiAqICAgICAgIHZhbGlkYXRvckluZGV4OiAnMHgxJyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBycGNCbG9ja092ZXJyaWRlcyAtIFRoZSBSUEMgYmxvY2sgb3ZlcnJpZGVzIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLkJsb2NrT3ZlcnJpZGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMocnBjQmxvY2tPdmVycmlkZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyAmJiB7XG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUgJiYge1xuICAgICAgICAgICAgYmxvYkJhc2VGZWU6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50ICYmIHtcbiAgICAgICAgICAgIGZlZVJlY2lwaWVudDogcnBjQmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50LFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0ICYmIHtcbiAgICAgICAgICAgIGdhc0xpbWl0OiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMuZ2FzTGltaXQpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLm51bWJlciAmJiB7XG4gICAgICAgICAgICBudW1iZXI6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5udW1iZXIpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8gJiYge1xuICAgICAgICAgICAgcHJldlJhbmRhbzogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8pLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLnRpbWUgJiYge1xuICAgICAgICAgICAgdGltZTogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLnRpbWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzICYmIHtcbiAgICAgICAgICAgIHdpdGhkcmF3YWxzOiBycGNCbG9ja092ZXJyaWRlcy53aXRoZHJhd2Fscy5tYXAoV2l0aGRyYXdhbC5mcm9tUnBjKSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLkJsb2NrT3ZlcnJpZGVzfSB0byBhbiB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJsb2NrT3ZlcnJpZGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYmxvY2tPdmVycmlkZXMgPSBCbG9ja092ZXJyaWRlcy50b1JwYyh7XG4gKiAgIGJhc2VGZWVQZXJHYXM6IDFuLFxuICogICBibG9iQmFzZUZlZTogMm4sXG4gKiAgIGZlZVJlY2lwaWVudDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGdhc0xpbWl0OiA0bixcbiAqICAgbnVtYmVyOiA1bixcbiAqICAgcHJldlJhbmRhbzogNm4sXG4gKiAgIHRpbWU6IDc4MTg3NDkzNTIwbixcbiAqICAgd2l0aGRyYXdhbHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICAgIGFtb3VudDogMW4sXG4gKiAgICAgICBpbmRleDogMCxcbiAqICAgICAgIHZhbGlkYXRvckluZGV4OiAxLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJsb2NrT3ZlcnJpZGVzIC0gVGhlIGJsb2NrIG92ZXJyaWRlcyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gaW5zdGFudGlhdGVkIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5ScGN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoYmxvY2tPdmVycmlkZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgYmxvYkJhc2VGZWU6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50ID09PSAnc3RyaW5nJyAmJiB7XG4gICAgICAgICAgICBmZWVSZWNpcGllbnQ6IGJsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuZ2FzTGltaXQgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGdhc0xpbWl0OiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5nYXNMaW1pdCksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLm51bWJlciA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgbnVtYmVyOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5udW1iZXIpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMudGltZSA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgdGltZTogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMudGltZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMgJiYge1xuICAgICAgICAgICAgd2l0aGRyYXdhbHM6IGJsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzLm1hcChXaXRoZHJhd2FsLnRvUnBjKSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb2NrT3ZlcnJpZGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/BlockOverrides.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Bytes.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidBytesBooleanError: () => (/* binding */ InvalidBytesBooleanError),\n/* harmony export */   InvalidBytesTypeError: () => (/* binding */ InvalidBytesTypeError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n\n\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nfunction assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nfunction concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize(value, size);\n        hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = (nibbleLeft << 4) | nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromNumber(value, options) {\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nfunction isEqual(bytesA, bytesB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.equalBytes)(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padLeft(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padRight(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nfunction random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nfunction size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nfunction toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nfunction toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value, options = {}) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nfunction toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nfunction toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimLeft(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimRight(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nclass InvalidBytesBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nclass InvalidBytesTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNwQjtBQUNOO0FBQ2dCO0FBQ0U7QUFDaEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFx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QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBDQUEwQyxpREFBZ0I7QUFDakUsa0JBQWtCLHlCQUF5QjtBQUMzQyxpQkFBaUIsNkJBQTZCLEVBQUU7QUFDaEQ7QUFDQSw0QkFBNEIsVUFBVSxLQUFLLDhCQUE4QixXQUFXO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0J5dGVzLmpzPzZlN2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXF1YWxCeXRlcyB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsX2hleCBmcm9tICcuL2ludGVybmFsL2hleC5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vSnNvbi5qcyc7XG5jb25zdCBkZWNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGVuY29kZXIgPSAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RW5jb2RlcigpO1xuLyoqXG4gKiBBc3NlcnRzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5hc3NlcnQoJ2FiYycpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLkludmFsaWRCeXRlc1R5cGVFcnJvcjpcbiAqIC8vIEBlcnJvcjogVmFsdWUgYFwiYWJjXCJgIG9mIHR5cGUgYHN0cmluZ2AgaXMgYW4gaW52YWxpZCBCeXRlcyB2YWx1ZS5cbiAqIC8vIEBlcnJvcjogQnl0ZXMgdmFsdWVzIG11c3QgYmUgb2YgdHlwZSBgVWludDhBcnJheWAuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICghKCdCWVRFU19QRVJfRUxFTUVOVCcgaW4gdmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodmFsdWUuQllURVNfUEVSX0VMRU1FTlQgIT09IDEgfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSAhPT0gJ1VpbnQ4QXJyYXknKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGVzIHR3byBvciBtb3JlIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJ5dGVzID0gQnl0ZXMuY29uY2F0KFxuICogICBCeXRlcy5mcm9tKFsxXSksXG4gKiAgIEJ5dGVzLmZyb20oWzY5XSksXG4gKiAgIEJ5dGVzLmZyb20oWzQyMCwgNjldKSxcbiAqIClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWyAxLCA2OSwgNDIwLCA2OSBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMgQ29uY2F0ZW5hdGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoLi4udmFsdWVzKSB7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBhcnIgb2YgdmFsdWVzKSB7XG4gICAgICAgIGxlbmd0aCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbmRleCA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gdmFsdWVzW2ldO1xuICAgICAgICByZXN1bHQuc2V0KGFyciwgaW5kZXgpO1xuICAgICAgICBpbmRleCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGZyb20gYSBgVWludDhBcnJheWAsIGEgaGV4IHN0cmluZywgb3IgYW4gYXJyYXkgb2YgdW5zaWduZWQgOC1iaXQgaW50ZWdlcnMuXG4gKlxuICogOjo6dGlwXG4gKlxuICogVG8gaW5zdGFudGlhdGUgZnJvbSBhICoqQm9vbGVhbioqLCAqKlN0cmluZyoqLCBvciAqKk51bWJlcioqLCB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogLSBgQnl0ZXMuZnJvbUJvb2xlYW5gXG4gKlxuICogLSBgQnl0ZXMuZnJvbVN0cmluZ2BcbiAqXG4gKiAtIGBCeXRlcy5mcm9tTnVtYmVyYFxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tKFsyNTUsIDEyNCwgNSwgNF0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsyNTUsIDEyNCwgNSwgNF0pXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb20oJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMjIyLCAxNzMsIDE5MCwgMjM5XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZnJvbUhleCh2YWx1ZSk7XG4gICAgcmV0dXJuIGZyb21BcnJheSh2YWx1ZSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIHVuc2lnbmVkIDgtYml0IGludGVnZXJzIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21BcnJheShbMjU1LCAxMjQsIDUsIDRdKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMjU1LCAxMjQsIDUsIDRdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyB2YWx1ZSA6IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIGJvb2xlYW4gdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUJvb2xlYW4odHJ1ZSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzFdKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tQm9vbGVhbih0cnVlLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEJvb2xlYW4gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRW5jb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJvb2xlYW4odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgIGJ5dGVzWzBdID0gTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICByZXR1cm4gcGFkTGVmdChieXRlcywgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tSGV4KCcweDQ4NjU2YzZjNmYyMDc3NmY3MjZjNjQyMScpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tSGV4KCcweDQ4NjU2YzZjNmYyMDc3NmY3MjZjNjQyMScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzMywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRW5jb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGxldCBoZXggPSB2YWx1ZTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpbnRlcm5hbF9oZXguYXNzZXJ0U2l6ZSh2YWx1ZSwgc2l6ZSk7XG4gICAgICAgIGhleCA9IEhleC5wYWRSaWdodCh2YWx1ZSwgc2l6ZSk7XG4gICAgfVxuICAgIGxldCBoZXhTdHJpbmcgPSBoZXguc2xpY2UoMik7XG4gICAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyKVxuICAgICAgICBoZXhTdHJpbmcgPSBgMCR7aGV4U3RyaW5nfWA7XG4gICAgY29uc3QgbGVuZ3RoID0gaGV4U3RyaW5nLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMCwgaiA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IG5pYmJsZUxlZnQgPSBpbnRlcm5hbC5jaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xuICAgICAgICBjb25zdCBuaWJibGVSaWdodCA9IGludGVybmFsLmNoYXJDb2RlVG9CYXNlMTYoaGV4U3RyaW5nLmNoYXJDb2RlQXQoaisrKSk7XG4gICAgICAgIGlmIChuaWJibGVMZWZ0ID09PSB1bmRlZmluZWQgfHwgbmliYmxlUmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoYEludmFsaWQgYnl0ZSBzZXF1ZW5jZSAoXCIke2hleFN0cmluZ1tqIC0gMl19JHtoZXhTdHJpbmdbaiAtIDFdfVwiIGluIFwiJHtoZXhTdHJpbmd9XCIpLmApO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzW2luZGV4XSA9IChuaWJibGVMZWZ0IDw8IDQpIHwgbmliYmxlUmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogRW5jb2RlcyBhIG51bWJlciB2YWx1ZSBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tTnVtYmVyKDQyMClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDE2NF0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21OdW1iZXIoNDIwLCB7IHNpemU6IDQgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzAsIDAsIDEsIDE2NF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRW5jb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGhleCA9IEhleC5mcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnJvbUhleChoZXgpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgc3RyaW5nIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21TdHJpbmcoJ0hlbGxvIHdvcmxkIScpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gd29ybGQhJywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBFbmNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZFJpZ2h0KGJ5dGVzLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWVzIGFyZSBlcXVhbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuaXNFcXVhbChCeXRlcy5mcm9tKFsxXSksIEJ5dGVzLmZyb20oWzFdKSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqXG4gKiBCeXRlcy5pc0VxdWFsKEJ5dGVzLmZyb20oWzFdKSwgQnl0ZXMuZnJvbShbMl0pKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlc0EgLSBGaXJzdCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHBhcmFtIGJ5dGVzQiAtIFNlY29uZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB0d28gdmFsdWVzIGFyZSBlcXVhbCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKGJ5dGVzQSwgYnl0ZXNCKSB7XG4gICAgcmV0dXJuIGVxdWFsQnl0ZXMoYnl0ZXNBLCBieXRlc0IpO1xufVxuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byB0aGUgbGVmdCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnBhZExlZnQoQnl0ZXMuZnJvbShbMV0pLCA0KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMCwgMV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gU2l6ZSB0byBwYWQgdGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8uXG4gKiBAcmV0dXJucyBQYWRkZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZExlZnQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ2xlZnQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byB0aGUgcmlnaHQgd2l0aCB6ZXJvIGJ5dGVzIHVudGlsIGl0IHJlYWNoZXMgdGhlIGdpdmVuIGBzaXplYCAoZGVmYXVsdDogMzIgYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5wYWRSaWdodChCeXRlcy5mcm9tKFsxXSksIDQpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxLCAwLCAwLCAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gcGFkLlxuICogQHBhcmFtIHNpemUgLSBTaXplIHRvIHBhZCB0aGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0by5cbiAqIEByZXR1cm5zIFBhZGRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkUmlnaHQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ3JpZ2h0Jywgc2l6ZSB9KTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIHJhbmRvbSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBieXRlcyA9IEJ5dGVzLnJhbmRvbSgzMilcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWy4uLiB4MzJdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGxlbmd0aCAtIExlbmd0aCBvZiB0aGUgcmFuZG9tIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyBSYW5kb20ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShsZW5ndGgpIHtcbiAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShsZW5ndGgpKTtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuc2l6ZShCeXRlcy5mcm9tKFsxLCAyLCAzLCA0XSkpXG4gKiAvLyBAbG9nOiA0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHJldHVybnMgU2l6ZSBvZiB0aGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc2VjdGlvbiBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgZ2l2ZW4gYSBzdGFydC9lbmQgYnl0ZXMgb2Zmc2V0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5zbGljZShcbiAqICAgQnl0ZXMuZnJvbShbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV0pLFxuICogICAxLFxuICogICA0LFxuICogKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMiwgMywgNF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEBwYXJhbSBzdGFydCAtIFN0YXJ0IG9mZnNldC5cbiAqIEBwYXJhbSBlbmQgLSBFbmQgb2Zmc2V0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBTbGljZSBvcHRpb25zLlxuICogQHJldHVybnMgU2xpY2VkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGljZSh2YWx1ZSwgc3RhcnQsIGVuZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgfSA9IG9wdGlvbnM7XG4gICAgaW50ZXJuYWwuYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KTtcbiAgICBjb25zdCB2YWx1ZV8gPSB2YWx1ZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICBpZiAoc3RyaWN0KVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRFbmRPZmZzZXQodmFsdWVfLCBzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gdmFsdWVfO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnRvIGEgYmlnaW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50b0JpZ0ludChCeXRlcy5mcm9tKFsxLCAxNjRdKSlcbiAqIC8vIEBsb2c6IDQyMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRGVjb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQgYmlnaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbUJ5dGVzKGJ5dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gSGV4LnRvQmlnSW50KGhleCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBib29sZWFuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50b0Jvb2xlYW4oQnl0ZXMuZnJvbShbMV0pKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBEZWNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRGVjb2RlZCBib29sZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Cb29sZWFuKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzXyA9IGJ5dGVzO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlc18sIHNpemUpO1xuICAgICAgICBieXRlc18gPSB0cmltTGVmdChieXRlc18pO1xuICAgIH1cbiAgICBpZiAoYnl0ZXNfLmxlbmd0aCA+IDEgfHwgYnl0ZXNfWzBdID4gMSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcihieXRlc18pO1xuICAgIHJldHVybiBCb29sZWFuKGJ5dGVzX1swXSk7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvSGV4KEJ5dGVzLmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgRGVjb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXModmFsdWUsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnRvIGEgbnVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50b051bWJlcihCeXRlcy5mcm9tKFsxLCAxNjRdKSlcbiAqIC8vIEBsb2c6IDQyMFxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcihieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgIGNvbnN0IGhleCA9IEhleC5mcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBIZXgudG9OdW1iZXIoaGV4LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLnRvU3RyaW5nKEJ5dGVzLmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gQGxvZzogJ0hlbGxvIHdvcmxkJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgRGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGxldCBieXRlc18gPSBieXRlcztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXNfLCBzaXplKTtcbiAgICAgICAgYnl0ZXNfID0gdHJpbVJpZ2h0KGJ5dGVzXyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShieXRlc18pO1xufVxuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50cmltTGVmdChCeXRlcy5mcm9tKFswLCAwLCAwLCAwLCAxLCAyLCAzXSkpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBUcmltbWVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltTGVmdCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ2xlZnQnIH0pO1xufVxuLyoqXG4gKiBUcmltcyB0cmFpbGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudHJpbVJpZ2h0KEJ5dGVzLmZyb20oWzEsIDIsIDMsIDAsIDAsIDAsIDBdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIFRyaW1tZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1SaWdodCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ3JpZ2h0JyB9KTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy52YWxpZGF0ZSgnMHgnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqXG4gKiBCeXRlcy52YWxpZGF0ZShCeXRlcy5mcm9tKFsxLCAyLCAzXSkpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBieXRlcyB2YWx1ZSBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBib29sZWFuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50b0Jvb2xlYW4oQnl0ZXMuZnJvbShbNV0pKVxuICogLy8gQGVycm9yOiBCeXRlcy5JbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3I6IEJ5dGVzIHZhbHVlIGBbNV1gIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uXG4gKiAvLyBAZXJyb3I6IFRoZSBieXRlcyBhcnJheSBtdXN0IGNvbnRhaW4gYSBzaW5nbGUgYnl0ZSBvZiBlaXRoZXIgYSBgMGAgb3IgYDFgIHZhbHVlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihieXRlcykge1xuICAgICAgICBzdXBlcihgQnl0ZXMgdmFsdWUgXFxgJHtieXRlc31cXGAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnVGhlIGJ5dGVzIGFycmF5IG11c3QgY29udGFpbiBhIHNpbmdsZSBieXRlIG9mIGVpdGhlciBhIGAwYCBvciBgMWAgdmFsdWUuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBieXRlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5mcm9tKCdmb28nKVxuICogLy8gQGVycm9yOiBCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3I6IFZhbHVlIGBmb29gIG9mIHR5cGUgYHN0cmluZ2AgaXMgYW4gaW52YWxpZCBCeXRlcyB2YWx1ZS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEJ5dGVzVHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IEpzb24uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlfVxcYCBvZiB0eXBlIFxcYCR7dHlwZW9mIHZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIEJ5dGVzIHZhbHVlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydCeXRlcyB2YWx1ZXMgbXVzdCBiZSBvZiB0eXBlIGBCeXRlc2AuJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuSW52YWxpZEJ5dGVzVHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgc2l6ZSBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJywgeyBzaXplOiA4IH0pXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLlNpemVPdmVyZmxvd0Vycm9yOiBTaXplIGNhbm5vdCBleGNlZWQgYDhgIGJ5dGVzLiBHaXZlbiBzaXplOiBgMTJgIGJ5dGVzLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTaXplT3ZlcmZsb3dFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZ2l2ZW5TaXplLCBtYXhTaXplIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpemUgY2Fubm90IGV4Y2VlZCBcXGAke21heFNpemV9XFxgIGJ5dGVzLiBHaXZlbiBzaXplOiBcXGAke2dpdmVuU2l6ZX1cXGAgYnl0ZXMuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHNsaWNlIG9mZnNldCBpcyBvdXQtb2YtYm91bmRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5zbGljZShCeXRlcy5mcm9tKFsxLCAyLCAzXSksIDQpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcjogU2xpY2Ugc3RhcnRpbmcgYXQgb2Zmc2V0IGA0YCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBgM2ApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCwgcG9zaXRpb24sIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09ICdzdGFydCcgPyAnc3RhcnRpbmcnIDogJ2VuZGluZyd9IGF0IG9mZnNldCBcXGAke29mZnNldH1cXGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogXFxgJHtzaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB0aGUgcGFkZGluZyBzaXplIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5wYWRMZWZ0KEJ5dGVzLmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScpLCA4KVxuICogLy8gQGVycm9yOiBbQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yOiBCeXRlcyBzaXplIChgMTJgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoYDhgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaXplLCB0YXJnZXRTaXplLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlXG4gICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfSBzaXplIChcXGAke3NpemV9XFxgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoXFxgJHt0YXJnZXRTaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Caches.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Caches.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   clear: () => (/* binding */ clear)\n/* harmony export */ });\n/* harmony import */ var _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/lru.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/lru.js\");\n\nconst caches = {\n    checksum: /*#__PURE__*/ new _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__.LruMap(8192),\n};\nconst checksum = caches.checksum;\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nfunction clear() {\n    for (const cache of Object.values(caches))\n        cache.clear();\n}\n//# sourceMappingURL=Caches.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0NhY2hlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkM7QUFDM0M7QUFDQSxnQ0FBZ0Msb0RBQU07QUFDdEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9DYWNoZXMuanM/Yjg2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMcnVNYXAgfSBmcm9tICcuL2ludGVybmFsL2xydS5qcyc7XG5jb25zdCBjYWNoZXMgPSB7XG4gICAgY2hlY2tzdW06IC8qI19fUFVSRV9fKi8gbmV3IExydU1hcCg4MTkyKSxcbn07XG5leHBvcnQgY29uc3QgY2hlY2tzdW0gPSBjYWNoZXMuY2hlY2tzdW07XG4vKipcbiAqIENsZWFycyBhbGwgZ2xvYmFsIGNhY2hlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENhY2hlcyB9IGZyb20gJ294J1xuICogQ2FjaGVzLmNsZWFyKClcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZSBvZiBPYmplY3QudmFsdWVzKGNhY2hlcykpXG4gICAgICAgIGNhY2hlLmNsZWFyKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Caches.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/errors.js\");\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nclass BaseError extends Error {\n    static setStaticOptions(options) {\n        BaseError.prototype.docsOrigin = options.docsOrigin;\n        BaseError.prototype.showVersion = options.showVersion;\n        BaseError.prototype.version = options.version;\n    }\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause &&\n                'details' in options.cause &&\n                typeof options.cause.details === 'string')\n                return options.cause.details;\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = options.docsOrigin ?? BaseError.prototype.docsOrigin;\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const showVersion = Boolean(options.version ?? BaseError.prototype.showVersion);\n        const version = options.version ?? BaseError.prototype.version;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath || showVersion\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                    showVersion ? `Version: ${version}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsOrigin\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"showVersion\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsOrigin = docsBaseUrl;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n        this.showVersion = showVersion;\n        this.version = version;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nObject.defineProperty(BaseError, \"defaultStaticOptions\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        docsOrigin: 'https://oxlib.sh',\n        showVersion: false,\n        version: `ox@${(0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)()}`,\n    }\n});\n(() => {\n    BaseError.setStaticOptions(BaseError.defaultStaticOptions);\n})();\n/** @internal */\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLFlBQVksRUFBRSxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRCx1Q0FBdUMsS0FBSztBQUM1Qyw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtEQUFVLEdBQUc7QUFDcEM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvRXJyb3JzLmpzPzRjN2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VmVyc2lvbiB9IGZyb20gJy4vaW50ZXJuYWwvZXJyb3JzLmpzJztcbi8qKlxuICogQmFzZSBlcnJvciBjbGFzcyBpbmhlcml0ZWQgYnkgYWxsIGVycm9ycyB0aHJvd24gYnkgb3guXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBFcnJvcnMgfSBmcm9tICdveCdcbiAqIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBzdGF0aWMgc2V0U3RhdGljT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUuZG9jc09yaWdpbiA9IG9wdGlvbnMuZG9jc09yaWdpbjtcbiAgICAgICAgQmFzZUVycm9yLnByb3RvdHlwZS5zaG93VmVyc2lvbiA9IG9wdGlvbnMuc2hvd1ZlcnNpb247XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUudmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2hvcnRNZXNzYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlLmRldGFpbHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRldGFpbHM7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2Uuc2hvcnRNZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5zaG9ydE1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSAmJlxuICAgICAgICAgICAgICAgICdkZXRhaWxzJyBpbiBvcHRpb25zLmNhdXNlICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuY2F1c2UuZGV0YWlscyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZGV0YWlscztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlPy5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLm1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kZXRhaWxzO1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBkb2NzUGF0aCA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5kb2NzUGF0aCB8fCBvcHRpb25zLmRvY3NQYXRoO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZG9jc1BhdGg7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGRvY3NCYXNlVXJsID0gb3B0aW9ucy5kb2NzT3JpZ2luID8/IEJhc2VFcnJvci5wcm90b3R5cGUuZG9jc09yaWdpbjtcbiAgICAgICAgY29uc3QgZG9jcyA9IGAke2RvY3NCYXNlVXJsfSR7ZG9jc1BhdGggPz8gJyd9YDtcbiAgICAgICAgY29uc3Qgc2hvd1ZlcnNpb24gPSBCb29sZWFuKG9wdGlvbnMudmVyc2lvbiA/PyBCYXNlRXJyb3IucHJvdG90eXBlLnNob3dWZXJzaW9uKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbiA/PyBCYXNlRXJyb3IucHJvdG90eXBlLnZlcnNpb247XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2UgfHwgJ0FuIGVycm9yIG9jY3VycmVkLicsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5tZXRhTWVzc2FnZXMgPyBbJycsIC4uLm9wdGlvbnMubWV0YU1lc3NhZ2VzXSA6IFtdKSxcbiAgICAgICAgICAgIC4uLihkZXRhaWxzIHx8IGRvY3NQYXRoIHx8IHNob3dWZXJzaW9uXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID8gYERldGFpbHM6ICR7ZGV0YWlsc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBkb2NzUGF0aCA/IGBTZWU6ICR7ZG9jc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBzaG93VmVyc2lvbiA/IGBWZXJzaW9uOiAke3ZlcnNpb259YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgIF1cbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucy5jYXVzZSA/IHsgY2F1c2U6IG9wdGlvbnMuY2F1c2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRldGFpbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzT3JpZ2luXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NQYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG93VmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCYXNlRXJyb3InXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgdGhpcy5kb2NzID0gZG9jcztcbiAgICAgICAgdGhpcy5kb2NzT3JpZ2luID0gZG9jc0Jhc2VVcmw7XG4gICAgICAgIHRoaXMuZG9jc1BhdGggPSBkb2NzUGF0aDtcbiAgICAgICAgdGhpcy5zaG9ydE1lc3NhZ2UgPSBzaG9ydE1lc3NhZ2U7XG4gICAgICAgIHRoaXMuc2hvd1ZlcnNpb24gPSBzaG93VmVyc2lvbjtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG4gICAgd2Fsayhmbikge1xuICAgICAgICByZXR1cm4gd2Fsayh0aGlzLCBmbik7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvciwgXCJkZWZhdWx0U3RhdGljT3B0aW9uc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHtcbiAgICAgICAgZG9jc09yaWdpbjogJ2h0dHBzOi8vb3hsaWIuc2gnLFxuICAgICAgICBzaG93VmVyc2lvbjogZmFsc2UsXG4gICAgICAgIHZlcnNpb246IGBveEAke2dldFZlcnNpb24oKX1gLFxuICAgIH1cbn0pO1xuKCgpID0+IHtcbiAgICBCYXNlRXJyb3Iuc2V0U3RhdGljT3B0aW9ucyhCYXNlRXJyb3IuZGVmYXVsdFN0YXRpY09wdGlvbnMpO1xufSkoKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHdhbGsoZXJyLCBmbikge1xuICAgIGlmIChmbj8uKGVycikpXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgaWYgKGVyciAmJiB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyAmJiAnY2F1c2UnIGluIGVyciAmJiBlcnIuY2F1c2UpXG4gICAgICAgIHJldHVybiB3YWxrKGVyci5jYXVzZSwgZm4pO1xuICAgIHJldHVybiBmbiA/IG51bGwgOiBlcnI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hash.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hash.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nfunction keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nfunction ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nfunction sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nfunction validate(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(value) && _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value) === 32;\n}\n//# sourceMappingURL=Hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ0o7QUFDTDtBQUMxQjtBQUNKO0FBQ2hDO0FBQ0EsOEVBQThFLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLG1EQUFtRDtBQUMvRCxrQkFBa0IsOERBQWUsQ0FBQywyQ0FBVTtBQUM1QztBQUNBO0FBQ0EsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0EsK0VBQStFLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLG1EQUFtRDtBQUMvRCxrQkFBa0Isa0VBQWUsQ0FBQywyQ0FBVTtBQUM1QztBQUNBO0FBQ0EsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0EsNkVBQTZFLHNCQUFzQixJQUFJLGtCQUFrQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLG1EQUFtRDtBQUMvRCxrQkFBa0IsNERBQVksQ0FBQywyQ0FBVTtBQUN6QztBQUNBO0FBQ0EsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyw2Q0FBWSxXQUFXLHlDQUFRO0FBQzFDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSGFzaC5qcz8wMzkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJpcGVtZDE2MCBhcyBub2JsZV9yaXBlbWQxNjAgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3JpcGVtZDE2MCc7XG5pbXBvcnQgeyBrZWNjYWtfMjU2IGFzIG5vYmxlX2tlY2NhazI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5pbXBvcnQgeyBzaGEyNTYgYXMgbm9ibGVfc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbS2VjY2FrMjU2XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TSEEtMykgaGFzaCBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSByZS1leHBvcnQgb2YgYGtlY2Nha18yNTZgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogJzB4ZDRmZDRlMTg5MTMyMjczMDM2NDQ5ZmM5ZTExMTk4YzczOTE2MWI0YzAxMTZhOWEyZGNjZGZhMWM0OTIwMDZmMSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ2FsY3VsYXRlIEhhc2ggb2YgYSBTdHJpbmdcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJykpXG4gKiAvLyBAbG9nOiAnMHgzZWEyZjFkMGFiZjNmYzY2Y2YyOWVlYmI3MGNiZDRlN2ZlNzYyZWY4YTA5YmNjMDZjOGVkZjY0MTIzMGFmZWMwJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb25maWd1cmUgUmV0dXJuIFR5cGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gua2VjY2FrMjU2KCcweGRlYWRiZWVmJywgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheSBbLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBLZWNjYWsyNTYgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1Nih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBub2JsZV9rZWNjYWsyNTYoQnl0ZXMuZnJvbSh2YWx1ZSkpO1xuICAgIGlmIChhcyA9PT0gJ0J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgW1JpcGVtZDE2MF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUklQRU1EKSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBgcmlwZW1kMTYwYCBmcm9tIFtgQG5vYmxlL2hhc2hlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtaGFzaGVzKSwgYW4gYXVkaXRlZCAmIG1pbmltYWwgSlMgaGFzaGluZyBsaWJyYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gucmlwZW1kMTYwKCcweGRlYWRiZWVmJylcbiAqIC8vICcweDIyNjgyMWMyZjU0MjNlMTFmZTlhZjY4YmQyODVjMjQ5ZGIyZTRiNWEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFJpcGVtZDE2MCBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmlwZW1kMTYwKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX3JpcGVtZDE2MChCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbU2hhMjU2XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TSEEtMjU2KSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBgc2hhMjU2YCBmcm9tIFtgQG5vYmxlL2hhc2hlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtaGFzaGVzKSwgYW4gYXVkaXRlZCAmIG1pbmltYWwgSlMgaGFzaGluZyBsaWJyYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2guc2hhMjU2KCcweGRlYWRiZWVmJylcbiAqIC8vICcweDVmNzhjMzMyNzRlNDNmYTlkZTU2NTkyNjVjMWQ5MTdlMjVjMDM3MjJkY2IwYjhkMjdkYjhkNWZlYWE4MTM5NTMnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFNoYTI1NiBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX3NoYTI1NihCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoYXNoIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gudmFsaWRhdGUoJzB4JylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKlxuICogSGFzaC52YWxpZGF0ZSgnMHgzZWEyZjFkMGFiZjNmYzY2Y2YyOWVlYmI3MGNiZDRlN2ZlNzYyZWY4YTA5YmNjMDZjOGVkZjY0MTIzMGFmZWMwJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiBIZXguc2l6ZSh2YWx1ZSkgPT09IDMyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hex.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hex.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegerOutOfRangeError: () => (/* binding */ IntegerOutOfRangeError),\n/* harmony export */   InvalidHexBooleanError: () => (/* binding */ InvalidHexBooleanError),\n/* harmony export */   InvalidHexTypeError: () => (/* binding */ InvalidHexTypeError),\n/* harmony export */   InvalidHexValueError: () => (/* binding */ InvalidHexValueError),\n/* harmony export */   InvalidLengthError: () => (/* binding */ InvalidLengthError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nfunction assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nfunction concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? BigInt.asUintN(size * 8, BigInt(value_)) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nfunction isEqual(hexA, hexB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexA), _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padLeft(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padRight(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nfunction random(length) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nfunction size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimLeft(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimRight(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nfunction toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nfunction toBoolean(hex, options = {}) {\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === '0x')\n        return false;\n    if (hex_ === '0x1')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nfunction toBytes(hex, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nfunction toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nfunction toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex);\n    if (size) {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__.assertSize(bytes, size);\n        bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nfunction validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nclass IntegerOutOfRangeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nclass InvalidHexBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nclass InvalidHexTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nclass InvalidHexValueError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nclass InvalidLengthError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUN0QjtBQUNFO0FBQ2dCO0FBQ1I7QUFDWjtBQUNsQztBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDTztBQUNQLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0IsNEJBQTRCLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0MseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7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TyxpQ0FBaUMsaURBQWdCO0FBQ3hEO0FBQ0EsOEJBQThCLE1BQU0sd0JBQXdCLGtCQUFrQjtBQUM5RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGlEQUFnQjtBQUN2RCxrQkFBa0Isb0JBQW9CO0FBQ3RDLHNDQUFzQyxRQUFRLDBCQUEwQixVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBDQUEwQyxpREFBZ0I7QUFDakUsa0JBQWtCLHlCQUF5QjtBQUMzQyx1QkFBdUIsOENBQThDLGNBQWMsT0FBTywrQkFBK0IsS0FBSztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMsaURBQWdCO0FBQ2pFLGtCQUFrQix5QkFBeUI7QUFDM0MsaUJBQWlCLDZCQUE2QixFQUFFO0FBQ2hEO0FBQ0EsNEJBQTRCLFVBQVUsS0FBSyw4QkFBOEIsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9IZXguanM/MTNiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9ieXRlcyBmcm9tICcuL2ludGVybmFsL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvaGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbmNvbnN0IGVuY29kZXIgPSAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgaGV4ZXMgPSAvKiNfX1BVUkVfXyovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBBc3NlcnRzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkSGV4VmFsdWVUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuXG4gKiAvLyBAZXJyb3I6IEhleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4XFwke3N0cmluZ31cImAuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKCEvXjB4WzAtOWEtZkEtRl0qJC8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFZhbHVlRXJyb3IodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguY29uY2F0KCcweDEyMycsICcweDQ1NicpXG4gKiAvLyBAbG9nOiAnMHgxMjM0NTYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdCguLi52YWx1ZXMpIHtcbiAgICByZXR1cm4gYDB4JHt2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgucmVwbGFjZSgnMHgnLCAnJyksICcnKX1gO1xufVxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgZnJvbSBhIGhleCBzdHJpbmcgb3Ige0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUbyBpbnN0YW50aWF0ZSBmcm9tIGEgKipCb29sZWFuKiosICoqU3RyaW5nKiosIG9yICoqTnVtYmVyKiosIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIGBIZXguZnJvbUJvb2xlYW5gXG4gKlxuICogLSBgSGV4LmZyb21TdHJpbmdgXG4gKlxuICogLSBgSGV4LmZyb21OdW1iZXJgXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb20oJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6ICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqXG4gKiBIZXguZnJvbShCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKHZhbHVlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmcm9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4odHJ1ZSlcbiAqIC8vIEBsb2c6ICcweDEnXG4gKlxuICogSGV4LmZyb21Cb29sZWFuKGZhbHNlKVxuICogLy8gQGxvZzogJzB4MCdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4odHJ1ZSwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBib29sZWFuIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBoZXggPSBgMHgke051bWJlcih2YWx1ZSl9YDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbUJ5dGVzKEJ5dGVzLmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyaW5nICs9IGhleGVzW3ZhbHVlW2ldXTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ31gO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZFJpZ2h0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIG51bWJlciBvciBiaWdpbnQgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMClcbiAqIC8vIEBsb2c6ICcweDFhNCdcbiAqXG4gKiBIZXguZnJvbU51bWJlcig0MjAsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIG9yIGJpZ2ludCB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZV8gPSBCaWdJbnQodmFsdWUpO1xuICAgIGxldCBtYXhWYWx1ZTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpZiAoc2lnbmVkKVxuICAgICAgICAgICAgbWF4VmFsdWUgPSAoMW4gPDwgKEJpZ0ludChzaXplKSAqIDhuIC0gMW4pKSAtIDFuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXhWYWx1ZSA9IDJuICoqIChCaWdJbnQoc2l6ZSkgKiA4bikgLSAxbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXhWYWx1ZSA9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG4gICAgfVxuICAgIGNvbnN0IG1pblZhbHVlID0gdHlwZW9mIG1heFZhbHVlID09PSAnYmlnaW50JyAmJiBzaWduZWQgPyAtbWF4VmFsdWUgLSAxbiA6IDA7XG4gICAgaWYgKChtYXhWYWx1ZSAmJiB2YWx1ZV8gPiBtYXhWYWx1ZSkgfHwgdmFsdWVfIDwgbWluVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/ICduJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgSW50ZWdlck91dE9mUmFuZ2VFcnJvcih7XG4gICAgICAgICAgICBtYXg6IG1heFZhbHVlID8gYCR7bWF4VmFsdWV9JHtzdWZmaXh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1pbjogYCR7bWluVmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICB2YWx1ZTogYCR7dmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gKHNpZ25lZCAmJiB2YWx1ZV8gPCAwID8gQmlnSW50LmFzVWludE4oc2l6ZSAqIDgsIEJpZ0ludCh2YWx1ZV8pKSA6IHZhbHVlXykudG9TdHJpbmcoMTYpO1xuICAgIGNvbnN0IGhleCA9IGAweCR7c3RyaW5nVmFsdWV9YDtcbiAgICBpZiAoc2l6ZSlcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoaGV4LCBzaXplKTtcbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgc3RyaW5nIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqIEhleC5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnKVxuICogLy8gJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICpcbiAqIEhleC5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVzKGVuY29kZXIuZW5jb2RlKHZhbHVlKSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlcyBhcmUgZXF1YWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguaXNFcXVhbCgnMHhkZWFkYmVlZicsICcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqXG4gKiBIZXguaXNFcXVhbCgnMHhkYScsICcweGJhJylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4QSAtIFRoZSBmaXJzdCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcGFyYW0gaGV4QiAtIFRoZSBzZWNvbmQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB0d28ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlcyBhcmUgZXF1YWwsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbChoZXhBLCBoZXhCKSB7XG4gICAgcmV0dXJuIGVxdWFsQnl0ZXMoQnl0ZXMuZnJvbUhleChoZXhBKSwgQnl0ZXMuZnJvbUhleChoZXhCKSk7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdGhlIGxlZnQgd2l0aCB6ZXJvIGJ5dGVzIHVudGlsIGl0IHJlYWNoZXMgdGhlIGdpdmVuIGBzaXplYCAoZGVmYXVsdDogMzIgYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnBhZExlZnQoJzB4MTIzNCcsIDQpXG4gKiAvLyBAbG9nOiAnMHgwMDAwMTIzNCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gcGFkLlxuICogQHBhcmFtIHNpemUgLSBUaGUgc2l6ZSAoaW4gYnl0ZXMpIG9mIHRoZSBvdXRwdXQgaGV4IHZhbHVlLlxuICogQHJldHVybnMgVGhlIHBhZGRlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRMZWZ0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdsZWZ0Jywgc2l6ZSB9KTtcbn1cbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byB0aGUgcmlnaHQgd2l0aCB6ZXJvIGJ5dGVzIHVudGlsIGl0IHJlYWNoZXMgdGhlIGdpdmVuIGBzaXplYCAoZGVmYXVsdDogMzIgYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnBhZFJpZ2h0KCcweDEyMzQnLCA0KVxuICogLy8gQGxvZzogJzB4MTIzNDAwMDAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgKGluIGJ5dGVzKSBvZiB0aGUgb3V0cHV0IGhleCB2YWx1ZS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkUmlnaHQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ3JpZ2h0Jywgc2l6ZSB9KTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGhleCA9IEhleC5yYW5kb20oMzIpXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBSYW5kb20ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKGxlbmd0aCkge1xuICAgIHJldHVybiBmcm9tQnl0ZXMoQnl0ZXMucmFuZG9tKGxlbmd0aCkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc2VjdGlvbiBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgZ2l2ZW4gYSBzdGFydC9lbmQgYnl0ZXMgb2Zmc2V0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnNsaWNlKCcweDAxMjM0NTY3ODknLCAxLCA0KVxuICogLy8gQGxvZzogJzB4MjM0NTY3J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBzbGljZS5cbiAqIEBwYXJhbSBzdGFydCAtIFRoZSBzdGFydCBvZmZzZXQgKGluIGJ5dGVzKS5cbiAqIEBwYXJhbSBlbmQgLSBUaGUgZW5kIG9mZnNldCAoaW4gYnl0ZXMpLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIHNsaWNlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGljZSh2YWx1ZSwgc3RhcnQsIGVuZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgfSA9IG9wdGlvbnM7XG4gICAgaW50ZXJuYWwuYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KTtcbiAgICBjb25zdCB2YWx1ZV8gPSBgMHgke3ZhbHVlXG4gICAgICAgIC5yZXBsYWNlKCcweCcsICcnKVxuICAgICAgICAuc2xpY2UoKHN0YXJ0ID8/IDApICogMiwgKGVuZCA/PyB2YWx1ZS5sZW5ndGgpICogMil9YDtcbiAgICBpZiAoc3RyaWN0KVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRFbmRPZmZzZXQodmFsdWVfLCBzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gdmFsdWVfO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHNpemUgb2YgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgKGluIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5zaXplKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IDRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZ2V0IHRoZSBzaXplIG9mLlxuICogQHJldHVybnMgVGhlIHNpemUgb2YgdGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSAoaW4gYnl0ZXMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMik7XG59XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50cmltTGVmdCgnMHgwMDAwMDAwMGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6ICcweGRlYWRiZWVmJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byB0cmltLlxuICogQHJldHVybnMgVGhlIHRyaW1tZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbUxlZnQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdsZWZ0JyB9KTtcbn1cbi8qKlxuICogVHJpbXMgdHJhaWxpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50cmltUmlnaHQoJzB4ZGVhZGJlZWYwMDAwMDAwMCcpXG4gKiAvLyBAbG9nOiAnMHhkZWFkYmVlZidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdHJpbS5cbiAqIEByZXR1cm5zIFRoZSB0cmltbWVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1SaWdodCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ3JpZ2h0JyB9KTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgQmlnSW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvQmlnSW50KCcweDFhNCcpXG4gKiAvLyBAbG9nOiA0MjBuXG4gKlxuICogSGV4LnRvQmlnSW50KCcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiA0MjBuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBCaWdJbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JpZ0ludChoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkIH0gPSBvcHRpb25zO1xuICAgIGlmIChvcHRpb25zLnNpemUpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KGhleCk7XG4gICAgaWYgKCFzaWduZWQpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBzaXplID0gKGhleC5sZW5ndGggLSAyKSAvIDI7XG4gICAgY29uc3QgbWF4X3Vuc2lnbmVkID0gKDFuIDw8IChCaWdJbnQoc2l6ZSkgKiA4bikpIC0gMW47XG4gICAgY29uc3QgbWF4X3NpZ25lZCA9IG1heF91bnNpZ25lZCA+PiAxbjtcbiAgICBpZiAodmFsdWUgPD0gbWF4X3NpZ25lZClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSAtIG1heF91bnNpZ25lZCAtIDFuO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBib29sZWFuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvQm9vbGVhbignMHgwMScpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogSGV4LnRvQm9vbGVhbignMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgYm9vbGVhbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQm9vbGVhbihoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zLnNpemUpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIGNvbnN0IGhleF8gPSB0cmltTGVmdChoZXgpO1xuICAgIGlmIChoZXhfID09PSAnMHgnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGhleF8gPT09ICcweDEnKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEhleEJvb2xlYW5FcnJvcihoZXgpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEhleC50b0J5dGVzKCcweDQ4NjU2YzZjNmYyMDc3NmY3MjZjNjQyMScpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gQnl0ZXMuZnJvbUhleChoZXgsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBudW1iZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9OdW1iZXIoJzB4MWE0JylcbiAqIC8vIEBsb2c6IDQyMFxuICpcbiAqIEhleC50b051bWJlcignMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWE0JywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogNDIwXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBudW1iZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcihoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkLCBzaXplIH0gPSBvcHRpb25zO1xuICAgIGlmICghc2lnbmVkICYmICFzaXplKVxuICAgICAgICByZXR1cm4gTnVtYmVyKGhleCk7XG4gICAgcmV0dXJuIE51bWJlcih0b0JpZ0ludChoZXgsIG9wdGlvbnMpKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvU3RyaW5nKCcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMScpXG4gKiAvLyBAbG9nOiAnSGVsbG8gd29ybGQhJ1xuICpcbiAqIEhleC50b1N0cmluZygnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywge1xuICogIHNpemU6IDMyLFxuICogfSlcbiAqIC8vIEBsb2c6ICdIZWxsbyB3b3JsZCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGxldCBieXRlcyA9IEJ5dGVzLmZyb21IZXgoaGV4KTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpbnRlcm5hbF9ieXRlcy5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgYnl0ZXMgPSBCeXRlcy50cmltUmlnaHQoYnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnZhbGlkYXRlKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqXG4gKiBIZXgudmFsaWRhdGUoQnl0ZXMuZnJvbShbMSwgMiwgM10pKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgb3gjSGV4LkhleH0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlLCB7IHN0cmljdCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIGludGVnZXIgaXMgb3V0IG9mIHJhbmdlLCBhbmQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgaGV4IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21OdW1iZXIoNDIwMTgyNzM4OTEyNzMxMjgzNzEyOTM3MTI5KVxuICogLy8gQGVycm9yOiBIZXguSW50ZWdlck91dE9mUmFuZ2VFcnJvcjogTnVtYmVyIFxcYDQuMjAxODI3Mzg5MTI3MzEyNmUrMjZcXGAgaXMgbm90IGluIHNhZmUgdW5zaWduZWQgaW50ZWdlciByYW5nZSAoYDBgIHRvIGA5MDA3MTk5MjU0NzQwOTkxYClcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW50ZWdlck91dE9mUmFuZ2VFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWF4LCBtaW4sIHNpZ25lZCwgc2l6ZSwgdmFsdWUsIH0pIHtcbiAgICAgICAgc3VwZXIoYE51bWJlciBcXGAke3ZhbHVlfVxcYCBpcyBub3QgaW4gc2FmZSR7c2l6ZSA/IGAgJHtzaXplICogOH0tYml0YCA6ICcnfSR7c2lnbmVkID8gJyBzaWduZWQnIDogJyB1bnNpZ25lZCd9IGludGVnZXIgcmFuZ2UgJHttYXggPyBgKFxcYCR7bWlufVxcYCB0byBcXGAke21heH1cXGApYCA6IGAoYWJvdmUgXFxgJHttaW59XFxgKWB9YCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW50ZWdlck91dE9mUmFuZ2VFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaGV4IHZhbHVlIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9Cb29sZWFuKCcweGEnKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZEhleEJvb2xlYW5FcnJvcjogSGV4IHZhbHVlIGBcIjB4YVwiYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLlxuICogLy8gQGVycm9yOiBUaGUgaGV4IHZhbHVlIG11c3QgYmUgYFwiMHgwXCJgIChmYWxzZSkgb3IgYFwiMHgxXCJgICh0cnVlKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEhleEJvb2xlYW5FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhleCkge1xuICAgICAgICBzdXBlcihgSGV4IHZhbHVlIFxcYFwiJHtoZXh9XCJcXGAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnVGhlIGhleCB2YWx1ZSBtdXN0IGJlIGBcIjB4MFwiYCAoZmFsc2UpIG9yIGBcIjB4MVwiYCAodHJ1ZSkuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhCb29sZWFuRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleCB0eXBlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmFzc2VydCgxKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZEhleFR5cGVFcnJvcjogVmFsdWUgYDFgIG9mIHR5cGUgYG51bWJlcmAgaXMgYW4gaW52YWxpZCBoZXggdHlwZS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEhleFR5cGVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3R5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBKc29uLnN0cmluZ2lmeSh2YWx1ZSkgOiB2YWx1ZX1cXGAgb2YgdHlwZSBcXGAke3R5cGVvZiB2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBoZXggdHlwZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFsnSGV4IHR5cGVzIG11c3QgYmUgcmVwcmVzZW50ZWQgYXMgYFwiMHgke3N0cmluZ31cImAuJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIGhleCB2YWx1ZSBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmFzc2VydCgnMHgwMTIzNDU2Nzg5YWJjZGVmZycpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkSGV4VmFsdWVFcnJvcjogVmFsdWUgYDB4MDEyMzQ1Njc4OWFiY2RlZmdgIGlzIGFuIGludmFsaWQgaGV4IHZhbHVlLlxuICogLy8gQGVycm9yOiBIZXggdmFsdWVzIG11c3Qgc3RhcnQgd2l0aCBgXCIweFwiYCBhbmQgY29udGFpbiBvbmx5IGhleGFkZWNpbWFsIGNoYXJhY3RlcnMgKDAtOSwgYS1mLCBBLUYpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSGV4VmFsdWVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIGhleCB2YWx1ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnSGV4IHZhbHVlcyBtdXN0IHN0YXJ0IHdpdGggYFwiMHhcImAgYW5kIGNvbnRhaW4gb25seSBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzICgwLTksIGEtZiwgQS1GKS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleFZhbHVlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIGhleCB2YWx1ZSBpcyBhbiBvZGQgbGVuZ3RoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5mcm9tSGV4KCcweGFiY2RlJylcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRMZW5ndGhFcnJvcjogSGV4IHZhbHVlIGBcIjB4YWJjZGVcImAgaXMgYW4gb2RkIGxlbmd0aCAoNSBuaWJibGVzKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZExlbmd0aEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYEhleCB2YWx1ZSBcXGBcIiR7dmFsdWV9XCJcXGAgaXMgYW4gb2RkIGxlbmd0aCAoJHt2YWx1ZS5sZW5ndGggLSAyfSBuaWJibGVzKS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFsnSXQgbXVzdCBiZSBhbiBldmVuIGxlbmd0aC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZExlbmd0aEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzaXplIG9mIHRoZSB2YWx1ZSBleGNlZWRzIHRoZSBleHBlY3RlZCBtYXggc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnLCB7IHNpemU6IDggfSlcbiAqIC8vIEBlcnJvcjogSGV4LlNpemVPdmVyZmxvd0Vycm9yOiBTaXplIGNhbm5vdCBleGNlZWQgYDhgIGJ5dGVzLiBHaXZlbiBzaXplOiBgMTJgIGJ5dGVzLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTaXplT3ZlcmZsb3dFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZ2l2ZW5TaXplLCBtYXhTaXplIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpemUgY2Fubm90IGV4Y2VlZCBcXGAke21heFNpemV9XFxgIGJ5dGVzLiBHaXZlbiBzaXplOiBcXGAke2dpdmVuU2l6ZX1cXGAgYnl0ZXMuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2l6ZU92ZXJmbG93RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHNsaWNlIG9mZnNldCBleGNlZWRzIHRoZSBib3VuZHMgb2YgdGhlIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnNsaWNlKCcweDAxMjM0NTY3ODknLCA2KVxuICogLy8gQGVycm9yOiBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yOiBTbGljZSBzdGFydGluZyBhdCBvZmZzZXQgYDZgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IGA1YCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgb2Zmc2V0LCBwb3NpdGlvbiwgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgU2xpY2UgJHtwb3NpdGlvbiA9PT0gJ3N0YXJ0JyA/ICdzdGFydGluZycgOiAnZW5kaW5nJ30gYXQgb2Zmc2V0IFxcYCR7b2Zmc2V0fVxcYCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBcXGAke3NpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHNpemUgb2YgdGhlIHZhbHVlIGV4Y2VlZHMgdGhlIHBhZCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnBhZExlZnQoJzB4MWE0ZTEyYTQ1YTIxMzIzMTIzYWFhODdhODk3YTg5N2E4OThhNjU2N2E1NzhhODY3YTk4Nzc4YTY2N2E4NWE4NzVhODdhNmE3ODdhNjVhNjc1YTZhOScsIDMyKVxuICogLy8gQGVycm9yOiBIZXguU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yOiBIZXggc2l6ZSAoYDQzYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKGAzMmApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpemUsIHRhcmdldFNpemUsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYCR7dHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3R5cGVcbiAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9IHNpemUgKFxcYCR7c2l6ZX1cXGApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChcXGAke3RhcmdldFNpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Json.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\nconst bigIntSuffix = '#__bigint';\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nfunction parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\n//# sourceMappingURL=Json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSw2QkFBNkIsZ0ZBQWdGO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLGdGQUFnRjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFLQUFxSztBQUNySztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Kc29uLmpzP2VmYjIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmlnSW50U3VmZml4ID0gJyNfX2JpZ2ludCc7XG4vKipcbiAqIFBhcnNlcyBhIEpTT04gc3RyaW5nLCB3aXRoIHN1cHBvcnQgZm9yIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSnNvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGpzb24gPSBKc29uLnBhcnNlKCd7XCJmb29cIjpcImJhclwiLFwiYmF6XCI6XCI2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMCNfX2JpZ2ludFwifScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGZvbzogJ2JhcicsXG4gKiAvLyBAbG9nOiAgIGJhejogNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjBuXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RyaW5nIC0gVGhlIHZhbHVlIHRvIHBhcnNlLlxuICogQHBhcmFtIHJldml2ZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgcmVzdWx0cy5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShzdHJpbmcsIHJldml2ZXIpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmcsIChrZXksIHZhbHVlXykgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlXztcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoYmlnSW50U3VmZml4KSlcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUuc2xpY2UoMCwgLWJpZ0ludFN1ZmZpeC5sZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gcmV2aXZlcihrZXksIHZhbHVlKSA6IHZhbHVlO1xuICAgIH0pO1xufVxuLyoqXG4gKiBTdHJpbmdpZmllcyBhIHZhbHVlIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLCB3aXRoIHN1cHBvcnQgZm9yIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSnNvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGpzb24gPSBKc29uLnN0cmluZ2lmeSh7XG4gKiAgIGZvbzogJ2JhcicsXG4gKiAgIGJhejogNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjBuLFxuICogfSlcbiAqIC8vIEBsb2c6ICd7XCJmb29cIjpcImJhclwiLFwiYmF6XCI6XCI2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMCNfX2JpZ2ludFwifSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdHJpbmdpZnkuXG4gKiBAcGFyYW0gcmVwbGFjZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgcmVzdWx0cy4gSXQgaXMgcGFzc2VkIHRoZSBrZXkgYW5kIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSwgYW5kIG11c3QgcmV0dXJuIHRoZSB2YWx1ZSB0byBiZSB1c2VkIGluIHRoZSBKU09OIHN0cmluZy4gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGUgcHJvcGVydHkgaXMgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgSlNPTiBzdHJpbmcuXG4gKiBAcGFyYW0gc3BhY2UgLSBBIHN0cmluZyBvciBudW1iZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgSlNPTiBzdHJpbmcuIElmIGl0IGlzIGEgbnVtYmVyLCBpdCBpbmRpY2F0ZXMgdGhlIG51bWJlciBvZiBzcGFjZXMgdG8gdXNlIGFzIGluZGVudGF0aW9uOyBpZiBpdCBpcyBhIHN0cmluZyAoZS5nLiBgJ1xcdCdgKSwgaXQgdXNlcyB0aGUgc3RyaW5nIGFzIHRoZSBpbmRlbnRhdGlvbiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyBUaGUgSlNPTiBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlcihrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIGJpZ0ludFN1ZmZpeDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIHNwYWNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUpzb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/P256.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/P256.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createKeyPair: () => (/* binding */ createKeyPair),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/p256 */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/p256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_entropy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/entropy.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/entropy.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\n/** Re-export of noble/curves P256 utilities. */\nconst noble = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1;\n/**\n * Creates a new P256 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nfunction createKeyPair(options = {}) {\n    const { as = 'Hex' } = options;\n    const privateKey = randomPrivateKey({ as });\n    const publicKey = getPublicKey({ privateKey });\n    return {\n        privateKey: privateKey,\n        publicKey,\n    };\n}\n/**\n * Computes the P256 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const publicKey = P256.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nfunction getPublicKey(options) {\n    const { privateKey } = options;\n    const point = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.ProjectivePoint.fromPrivateKey(typeof privateKey === 'string'\n        ? privateKey.slice(2)\n        : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(privateKey).slice(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = P256.createKeyPair()\n * const { publicKey: publicKeyB } = P256.createKeyPair()\n *\n * const sharedSecret = P256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nfunction getSharedSecret(options) {\n    const { as = 'Hex', privateKey, publicKey } = options;\n    const point = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.ProjectivePoint.fromHex(_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toHex(publicKey).slice(2));\n    const privateKeyHex = typeof privateKey === 'string'\n        ? privateKey.slice(2)\n        : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(privateKey).slice(2);\n    const sharedPoint = point.multiply(_noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.utils.normPrivateKeyToScalar(privateKeyHex));\n    const sharedSecret = sharedPoint.toRawBytes(true); // compressed format\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(sharedSecret);\n    return sharedSecret;\n}\n/**\n * Generates a random P256 ECDSA private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nfunction randomPrivateKey(options = {}) {\n    const { as = 'Hex' } = options;\n    const bytes = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.utils.randomPrivateKey();\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n    return bytes;\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = P256.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nfunction recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const payload_ = payload instanceof Uint8Array ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(payload) : payload;\n    const point = signature_.recoverPublicKey(payload_.substring(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Signs the payload with the provided private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nfunction sign(options) {\n    const { extraEntropy = _internal_entropy_js__WEBPACK_IMPORTED_MODULE_3__.extraEntropy, hash, payload, privateKey, } = options;\n    const { r, s, recovery } = _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.sign(payload instanceof Uint8Array ? payload : _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(payload), privateKey instanceof Uint8Array ? privateKey : _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(privateKey), {\n        extraEntropy: typeof extraEntropy === 'boolean'\n            ? extraEntropy\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(extraEntropy).slice(2),\n        lowS: true,\n        ...(hash ? { prehash: true } : {}),\n    });\n    return {\n        r,\n        s,\n        yParity: recovery,\n    };\n}\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = P256.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nfunction verify(options) {\n    const { hash, payload, publicKey, signature } = options;\n    return _noble_curves_p256__WEBPACK_IMPORTED_MODULE_0__.secp256r1.verify(signature, payload instanceof Uint8Array ? payload : _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(payload), _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toHex(publicKey).substring(2), ...(hash ? [{ prehash: true, lowS: true }] : []));\n}\n//# sourceMappingURL=P256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1AyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUErQztBQUNYO0FBQ0o7QUFDaUI7QUFDTDtBQUM1QztBQUNPLGNBQWMseURBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxhQUFhO0FBQ3pCLDBDQUEwQyxJQUFJO0FBQzlDLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGFBQWE7QUFDekIsa0JBQWtCLHlEQUFTO0FBQzNCO0FBQ0EsVUFBVSw4Q0FBYTtBQUN2QixXQUFXLCtDQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksb0NBQW9DO0FBQ2hELGtCQUFrQix5REFBUyx5QkFBeUIsZ0RBQWU7QUFDbkU7QUFDQTtBQUNBLFVBQVUsOENBQWE7QUFDdkIsdUNBQXVDLHlEQUFTO0FBQ2hELHVEQUF1RDtBQUN2RDtBQUNBLGVBQWUsOENBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxhQUFhO0FBQ3pCLGtCQUFrQix5REFBUztBQUMzQjtBQUNBLGVBQWUsOENBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxxQkFBcUI7QUFDakMsWUFBWSxnQkFBZ0I7QUFDNUIsMkJBQTJCLHlEQUFTO0FBQ3BDLHFEQUFxRCw4Q0FBYTtBQUNsRTtBQUNBLFdBQVcsK0NBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNPO0FBQ1AsWUFBWSxlQUFlLDhEQUFvQiwrQkFBK0I7QUFDOUUsWUFBWSxpQkFBaUIsRUFBRSx5REFBUyxnREFBZ0QsOENBQWEsMkRBQTJELDhDQUFhO0FBQzdLO0FBQ0E7QUFDQSxjQUFjLHlDQUFRO0FBQ3RCO0FBQ0EscUJBQXFCLGdCQUFnQixJQUFJO0FBQ3pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxpQ0FBaUMsbUNBQW1DO0FBQ3BFO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHNDQUFzQztBQUNsRCxXQUFXLHlEQUFTLDZEQUE2RCw4Q0FBYSxXQUFXLGdEQUFlLHdDQUF3QywyQkFBMkI7QUFDM0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9QMjU2LmpzP2UwOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VjcDI1NnIxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9wMjU2JztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEVudHJvcHkgZnJvbSAnLi9pbnRlcm5hbC9lbnRyb3B5LmpzJztcbmltcG9ydCAqIGFzIFB1YmxpY0tleSBmcm9tICcuL1B1YmxpY0tleS5qcyc7XG4vKiogUmUtZXhwb3J0IG9mIG5vYmxlL2N1cnZlcyBQMjU2IHV0aWxpdGllcy4gKi9cbmV4cG9ydCBjb25zdCBub2JsZSA9IHNlY3AyNTZyMTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQMjU2IEVDRFNBIGtleSBwYWlyIGNvbnNpc3Rpbmcgb2YgYSBwcml2YXRlIGtleSBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgcHVibGljIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gUDI1Ni5jcmVhdGVLZXlQYWlyKClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIGtleSBwYWlyLlxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBrZXkgcGFpciBjb250YWluaW5nIGJvdGggcHJpdmF0ZSBhbmQgcHVibGljIGtleXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVLZXlQYWlyKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnSGV4JyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gcmFuZG9tUHJpdmF0ZUtleSh7IGFzIH0pO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgcHVibGljS2V5LFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBQMjU2IEVDRFNBIHB1YmxpYyBrZXkgZnJvbSBhIHByb3ZpZGVkIHByaXZhdGUga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFAyNTYuZ2V0UHVibGljS2V5KHsgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjb21wdXRlIHRoZSBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGNvbXB1dGVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQdWJsaWNLZXkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcHJpdmF0ZUtleSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZyMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbVByaXZhdGVLZXkodHlwZW9mIHByaXZhdGVLZXkgPT09ICdzdHJpbmcnXG4gICAgICAgID8gcHJpdmF0ZUtleS5zbGljZSgyKVxuICAgICAgICA6IEhleC5mcm9tQnl0ZXMocHJpdmF0ZUtleSkuc2xpY2UoMikpO1xuICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbShwb2ludCk7XG59XG4vKipcbiAqIENvbXB1dGVzIGEgc2hhcmVkIHNlY3JldCB1c2luZyBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUtSGVsbG1hbikgYmV0d2VlbiBhIHByaXZhdGUga2V5IGFuZCBhIHB1YmxpYyBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5OiBwcml2YXRlS2V5QSB9ID0gUDI1Ni5jcmVhdGVLZXlQYWlyKClcbiAqIGNvbnN0IHsgcHVibGljS2V5OiBwdWJsaWNLZXlCIH0gPSBQMjU2LmNyZWF0ZUtleVBhaXIoKVxuICpcbiAqIGNvbnN0IHNoYXJlZFNlY3JldCA9IFAyNTYuZ2V0U2hhcmVkU2VjcmV0KHtcbiAqICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUEsXG4gKiAgIHB1YmxpY0tleTogcHVibGljS2V5QlxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29tcHV0ZSB0aGUgc2hhcmVkIHNlY3JldC5cbiAqIEByZXR1cm5zIFRoZSBjb21wdXRlZCBzaGFyZWQgc2VjcmV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcsIHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZyMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KS5zbGljZSgyKSk7XG4gICAgY29uc3QgcHJpdmF0ZUtleUhleCA9IHR5cGVvZiBwcml2YXRlS2V5ID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHByaXZhdGVLZXkuc2xpY2UoMilcbiAgICAgICAgOiBIZXguZnJvbUJ5dGVzKHByaXZhdGVLZXkpLnNsaWNlKDIpO1xuICAgIGNvbnN0IHNoYXJlZFBvaW50ID0gcG9pbnQubXVsdGlwbHkoc2VjcDI1NnIxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleUhleCkpO1xuICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IHNoYXJlZFBvaW50LnRvUmF3Qnl0ZXModHJ1ZSk7IC8vIGNvbXByZXNzZWQgZm9ybWF0XG4gICAgaWYgKGFzID09PSAnSGV4JylcbiAgICAgICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoc2hhcmVkU2VjcmV0KTtcbiAgICByZXR1cm4gc2hhcmVkU2VjcmV0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gUDI1NiBFQ0RTQSBwcml2YXRlIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gUDI1Ni5yYW5kb21Qcml2YXRlS2V5KClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gZ2VuZXJhdGUgdGhlIHByaXZhdGUga2V5LlxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBwcml2YXRlIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVByaXZhdGVLZXkob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gc2VjcDI1NnIxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBSZWNvdmVycyB0aGUgc2lnbmluZyBwdWJsaWMga2V5IGZyb20gdGhlIHNpZ25lZCBwYXlsb2FkIGFuZCBzaWduYXR1cmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gUDI1Ni5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUDI1Ni5yZWNvdmVyUHVibGljS2V5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHJlY292ZXJlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkLCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9IG5ldyBzZWNwMjU2cjEuU2lnbmF0dXJlKEJpZ0ludChyKSwgQmlnSW50KHMpKS5hZGRSZWNvdmVyeUJpdCh5UGFyaXR5KTtcbiAgICBjb25zdCBwYXlsb2FkXyA9IHBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gSGV4LmZyb21CeXRlcyhwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgY29uc3QgcG9pbnQgPSBzaWduYXR1cmVfLnJlY292ZXJQdWJsaWNLZXkocGF5bG9hZF8uc3Vic3RyaW5nKDIpKTtcbiAgICByZXR1cm4gUHVibGljS2V5LmZyb20ocG9pbnQpO1xufVxuLyoqXG4gKiBTaWducyB0aGUgcGF5bG9hZCB3aXRoIHRoZSBwcm92aWRlZCBwcml2YXRlIGtleSBhbmQgcmV0dXJucyBhIFAyNTYgc2lnbmF0dXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFAyNTYuc2lnbih7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmluZyBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIEVDRFNBIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ24ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgZXh0cmFFbnRyb3B5ID0gRW50cm9weS5leHRyYUVudHJvcHksIGhhc2gsIHBheWxvYWQsIHByaXZhdGVLZXksIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgciwgcywgcmVjb3ZlcnkgfSA9IHNlY3AyNTZyMS5zaWduKHBheWxvYWQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gcGF5bG9hZCA6IEJ5dGVzLmZyb21IZXgocGF5bG9hZCksIHByaXZhdGVLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gcHJpdmF0ZUtleSA6IEJ5dGVzLmZyb21IZXgocHJpdmF0ZUtleSksIHtcbiAgICAgICAgZXh0cmFFbnRyb3B5OiB0eXBlb2YgZXh0cmFFbnRyb3B5ID09PSAnYm9vbGVhbidcbiAgICAgICAgICAgID8gZXh0cmFFbnRyb3B5XG4gICAgICAgICAgICA6IEhleC5mcm9tKGV4dHJhRW50cm9weSkuc2xpY2UoMiksXG4gICAgICAgIGxvd1M6IHRydWUsXG4gICAgICAgIC4uLihoYXNoID8geyBwcmVoYXNoOiB0cnVlIH0gOiB7fSksXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgeVBhcml0eTogcmVjb3ZlcnksXG4gICAgfTtcbn1cbi8qKlxuICogVmVyaWZpZXMgYSBwYXlsb2FkIHdhcyBzaWduZWQgYnkgdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0gPSBQMjU2LmNyZWF0ZUtleVBhaXIoKVxuICogY29uc3Qgc2lnbmF0dXJlID0gUDI1Ni5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5IH0pXG4gKlxuICogY29uc3QgdmVyaWZpZWQgPSBQMjU2LnZlcmlmeSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcHVibGljS2V5LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHZlcmlmaWNhdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgcGF5bG9hZCB3YXMgc2lnbmVkIGJ5IHRoZSBwcm92aWRlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGhhc2gsIHBheWxvYWQsIHB1YmxpY0tleSwgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBzZWNwMjU2cjEudmVyaWZ5KHNpZ25hdHVyZSwgcGF5bG9hZCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBwYXlsb2FkIDogQnl0ZXMuZnJvbUhleChwYXlsb2FkKSwgUHVibGljS2V5LnRvSGV4KHB1YmxpY0tleSkuc3Vic3RyaW5nKDIpLCAuLi4oaGFzaCA/IFt7IHByZWhhc2g6IHRydWUsIGxvd1M6IHRydWUgfV0gOiBbXSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UDI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/P256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/PublicKey.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/PublicKey.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidCompressedPrefixError: () => (/* binding */ InvalidCompressedPrefixError),\n/* harmony export */   InvalidError: () => (/* binding */ InvalidError),\n/* harmony export */   InvalidPrefixError: () => (/* binding */ InvalidPrefixError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidUncompressedPrefixError: () => (/* binding */ InvalidUncompressedPrefixError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   compress: () => (/* binding */ compress),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nfunction assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    // Uncompressed\n    if (compressed === false ||\n        (typeof x === 'bigint' && typeof y === 'bigint')) {\n        if (prefix !== 4)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidUncompressedPrefixError(),\n            });\n        return;\n    }\n    // Compressed\n    if (compressed === true ||\n        (typeof x === 'bigint' && typeof y === 'undefined')) {\n        if (prefix !== 3 && prefix !== 2)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidCompressedPrefixError(),\n            });\n        return;\n    }\n    // Unknown/invalid\n    throw new InvalidError({ publicKey });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nfunction compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x,\n    };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nfunction from(value) {\n    const publicKey = (() => {\n        if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.validate(value))\n            return fromHex(value);\n        if (_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.validate(value))\n            return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === 'bigint' && typeof y === 'bigint')\n            return { prefix: prefix ?? 0x04, x, y };\n        return { prefix, x };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nfunction fromBytes(publicKey) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nfunction fromHex(publicKey) {\n    if (publicKey.length !== 132 &&\n        publicKey.length !== 130 &&\n        publicKey.length !== 68)\n        throw new InvalidSerializedSizeError({ publicKey });\n    if (publicKey.length === 130) {\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 32));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y,\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y,\n        };\n    }\n    const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n    const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x,\n    };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nfunction toBytes(publicKey, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nfunction toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(includePrefix ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(prefix, { size: 1 }) : '0x', _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(x, { size: 32 }), \n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(y, { size: 32 }) : '0x');\n    return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nfunction validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    }\n    catch (_error) {\n        return false;\n    }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nclass InvalidError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${_Json_js__WEBPACK_IMPORTED_MODULE_3__.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                'Public key must contain:',\n                '- an `x` and `prefix` value (compressed)',\n                '- an `x`, `y`, and `prefix` value (uncompressed)',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidError'\n        });\n    }\n}\n/** Thrown when a public key has an invalid prefix. */\nclass InvalidPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ prefix, cause }) {\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nclass InvalidCompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('Prefix must be 2 or 3 for compressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidCompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nclass InvalidUncompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('Prefix must be 4 for uncompressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidUncompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid serialized size. */\nclass InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.from(publicKey))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidSerializedSizeError'\n        });\n    }\n}\n//# sourceMappingURL=PublicKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1B1YmxpY0tleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNFO0FBQ047QUFDRTtBQUNsQztBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDO0FBQzlDLFlBQVksYUFBYTtBQUN6QixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQSxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOEJBQThCLGVBQWUsNkJBQTZCLEdBQUcscUJBQXFCLE1BQU0saUJBQWlCO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJB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LGlEQUFnQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyw2Q0FBNkMsaURBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QyxpREFBZ0I7QUFDaEUsa0JBQWtCLFdBQVc7QUFDN0IseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLDRCQUE0Qix5Q0FBUSxDQUFDLHlDQUFRLGNBQWM7QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUHVibGljS2V5LmpzP2UwNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogUHVibGljS2V5LmFzc2VydCh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeTogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogfSlcbiAqIC8vIEBlcnJvcjogUHVibGljS2V5LkludmFsaWRFcnJvcjogVmFsdWUgXFxge1wieVwiOlwiMVwifVxcYCBpcyBub3QgYSB2YWxpZCBwdWJsaWMga2V5LlxuICogLy8gQGVycm9yOiBQdWJsaWMga2V5IG11c3QgY29udGFpbjpcbiAqIC8vIEBlcnJvcjogLSBhbiBgeGAgYW5kIGBwcmVmaXhgIHZhbHVlIChjb21wcmVzc2VkKVxuICogLy8gQGVycm9yOiAtIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjb21wcmVzc2VkIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgLy8gVW5jb21wcmVzc2VkXG4gICAgaWYgKGNvbXByZXNzZWQgPT09IGZhbHNlIHx8XG4gICAgICAgICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHkgPT09ICdiaWdpbnQnKSkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDb21wcmVzc2VkXG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHRydWUgfHxcbiAgICAgICAgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09IDMgJiYgcHJlZml4ICE9PSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVW5rbm93bi9pbnZhbGlkXG4gICAgdGhyb3cgbmV3IEludmFsaWRFcnJvcih7IHB1YmxpY0tleSB9KTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgY29tcHJlc3NlZCA9IFB1YmxpY0tleS5jb21wcmVzcyhwdWJsaWNLZXkpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiAzLFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgdG8gY29tcHJlc3MuXG4gKiBAcmV0dXJucyBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3MocHVibGljS2V5KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4OiB5ICUgMm4gPT09IDBuID8gMiA6IDMsXG4gICAgICAgIHgsXG4gICAgfTtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgdHlwZWQge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IG9iamVjdCBmcm9tIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvciB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6ICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oJzB4MDQ4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1MzU0N2YxMWNhODY5NjY0NmYyZjNhY2IwOGUzMTAxNmFmYWMyM2U2MzBjNWQxMWY1OWY2MWZlZjU3YjBkMmFhNScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgcHVibGljIGtleSB2YWx1ZSB0byBpbnN0YW50aWF0ZS5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChIZXgudmFsaWRhdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgICAgICBpZiAoQnl0ZXMudmFsaWRhdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CeXRlcyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCA/PyAweDA0LCB4LCB5IH07XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgeCB9O1xuICAgIH0pKCk7XG4gICAgYXNzZXJ0KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KFsxMjgsIDMsIDEzMSwgLi4uXSkpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gZnJvbUhleChIZXguZnJvbUJ5dGVzKHB1YmxpY0tleSkpO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gZnJvbSBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tSGV4KCcweDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiA0LFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRGVzZXJpYWxpemluZyBhIENvbXByZXNzZWQgUHVibGljIEtleVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUhleCgnMHgwMzgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDMsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGRlc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChwdWJsaWNLZXkpIHtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMTMyICYmXG4gICAgICAgIHB1YmxpY0tleS5sZW5ndGggIT09IDEzMCAmJlxuICAgICAgICBwdWJsaWNLZXkubGVuZ3RoICE9PSA2OClcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yKHsgcHVibGljS2V5IH0pO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAxMzApIHtcbiAgICAgICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAwLCAzMikpO1xuICAgICAgICBjb25zdCB5ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDMyLCA2NCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4OiA0LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAxMzIpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gTnVtYmVyKEhleC5zbGljZShwdWJsaWNLZXksIDAsIDEpKTtcbiAgICAgICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAxLCAzMykpO1xuICAgICAgICBjb25zdCB5ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDMzLCA2NSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IE51bWJlcihIZXguc2xpY2UocHVibGljS2V5LCAwLCAxKSk7XG4gICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAxLCAzMykpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgeCxcbiAgICB9O1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IHRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IGJ5dGVzID0gUHVibGljS2V5LnRvQnl0ZXMocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMjgsIDMsIDEzMSwgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgocHVibGljS2V5LCBvcHRpb25zKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gdG8ge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oe1xuICogICBwcmVmaXg6IDQsXG4gKiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoZXggPSBQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHgwNDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGFzc2VydChwdWJsaWNLZXkpO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgY29uc3QgeyBpbmNsdWRlUHJlZml4ID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwdWJsaWNLZXlfID0gSGV4LmNvbmNhdChpbmNsdWRlUHJlZml4ID8gSGV4LmZyb21OdW1iZXIocHJlZml4LCB7IHNpemU6IDEgfSkgOiAnMHgnLCBIZXguZnJvbU51bWJlcih4LCB7IHNpemU6IDMyIH0pLCBcbiAgICAvLyBJZiB0aGUgcHVibGljIGtleSBpcyBub3QgY29tcHJlc3NlZCwgYWRkIHRoZSB5IGNvb3JkaW5hdGUuXG4gICAgdHlwZW9mIHkgPT09ICdiaWdpbnQnID8gSGV4LmZyb21OdW1iZXIoeSwgeyBzaXplOiAzMiB9KSA6ICcweCcpO1xuICAgIHJldHVybiBwdWJsaWNLZXlfO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0uIFJldHVybnMgYHRydWVgIGlmIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gUHVibGljS2V5LnZhbGlkYXRlKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB5OiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiB9KVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQocHVibGljS2V5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBwdWJsaWMga2V5IGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBQdWJsaWNLZXkuYXNzZXJ0KHsgeTogMW4gfSlcbiAqIC8vIEBlcnJvcjogUHVibGljS2V5LkludmFsaWRFcnJvcjogVmFsdWUgYHtcInlcIjoxbn1gIGlzIG5vdCBhIHZhbGlkIHB1YmxpYyBrZXkuXG4gKiAvLyBAZXJyb3I6IFB1YmxpYyBrZXkgbXVzdCBjb250YWluOlxuICogLy8gQGVycm9yOiAtIGFuIGB4YCBhbmQgYHByZWZpeGAgdmFsdWUgKGNvbXByZXNzZWQpXG4gKiAvLyBAZXJyb3I6IC0gYW4gYHhgLCBgeWAsIGFuZCBgcHJlZml4YCB2YWx1ZSAodW5jb21wcmVzc2VkKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHB1YmxpY0tleSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke0pzb24uc3RyaW5naWZ5KHB1YmxpY0tleSl9XFxgIGlzIG5vdCBhIHZhbGlkIHB1YmxpYyBrZXkuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1B1YmxpYyBrZXkgbXVzdCBjb250YWluOicsXG4gICAgICAgICAgICAgICAgJy0gYW4gYHhgIGFuZCBgcHJlZml4YCB2YWx1ZSAoY29tcHJlc3NlZCknLFxuICAgICAgICAgICAgICAgICctIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZCknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYSBwdWJsaWMga2V5IGhhcyBhbiBpbnZhbGlkIHByZWZpeC4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHByZWZpeCwgY2F1c2UgfSkge1xuICAgICAgICBzdXBlcihgUHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgaW52YWxpZC5gLCB7XG4gICAgICAgICAgICBjYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZFByZWZpeEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgcHJlZml4IGZvciBhIGNvbXByZXNzZWQgcHVibGljIGtleS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQ29tcHJlc3NlZFByZWZpeEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdQcmVmaXggbXVzdCBiZSAyIG9yIDMgZm9yIGNvbXByZXNzZWQgcHVibGljIGtleXMuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBwdWJsaWMga2V5IGhhcyBhbiBpbnZhbGlkIHByZWZpeCBmb3IgYW4gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdQcmVmaXggbXVzdCBiZSA0IGZvciB1bmNvbXByZXNzZWQgcHVibGljIGtleXMuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgc2VyaWFsaXplZCBzaXplLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBwdWJsaWNLZXkgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHtwdWJsaWNLZXl9XFxgIGlzIGFuIGludmFsaWQgcHVibGljIGtleSBzaXplLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdFeHBlY3RlZDogMzMgYnl0ZXMgKGNvbXByZXNzZWQgKyBwcmVmaXgpLCA2NCBieXRlcyAodW5jb21wcmVzc2VkKSBvciA2NSBieXRlcyAodW5jb21wcmVzc2VkICsgcHJlZml4KS4nLFxuICAgICAgICAgICAgICAgIGBSZWNlaXZlZCAke0hleC5zaXplKEhleC5mcm9tKHB1YmxpY0tleSkpfSBieXRlcy5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVB1YmxpY0tleS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/PublicKey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Rlp.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Rlp.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlpCursor: () => (/* binding */ decodeRlpCursor),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   readLength: () => (/* binding */ readLength),\n/* harmony export */   readList: () => (/* binding */ readList),\n/* harmony export */   to: () => (/* binding */ to),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nfunction toBytes(value) {\n    return to(value, 'Bytes');\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value) {\n    return to(value, 'Hex');\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */\nfunction to(value, to) {\n    const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes');\n    const bytes = (() => {\n        if (typeof value === 'string') {\n            if (value.length > 3 && value.length % 2 !== 0)\n                throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.InvalidLengthError(value);\n            return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY,\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\n/** @internal */\n/** @internal */\nfunction decodeRlpCursor(cursor, to = 'Hex') {\n    if (cursor.bytes.length === 0)\n        return (to === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes) : cursor.bytes);\n    const prefix = cursor.readByte();\n    if (prefix < 0x80)\n        cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return (to === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes) : bytes);\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\n/** @internal */\nfunction readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80)\n        return 1;\n    if (prefix <= offset + 55)\n        return prefix - offset;\n    if (prefix === offset + 55 + 1)\n        return cursor.readUint8();\n    if (prefix === offset + 55 + 2)\n        return cursor.readUint16();\n    if (prefix === offset + 55 + 3)\n        return cursor.readUint24();\n    if (prefix === offset + 55 + 4)\n        return cursor.readUint32();\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError('Invalid RLP prefix');\n}\n/** @internal */\nfunction readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while (cursor.position - position < length)\n        value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction fromBytes(bytes, options = {}) {\n    const { as = 'Bytes' } = options;\n    return from(bytes, { as });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction fromHex(hex, options = {}) {\n    const { as = 'Hex' } = options;\n    return from(hex, { as });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes))\n        return getEncodableList(bytes.map((x) => getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (() => {\n        if (bodyLength <= 55)\n            return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            }\n            else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1)\n                    cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2)\n                    cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3)\n                    cursor.pushUint24(bodyLength);\n                else\n                    cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list) {\n                encode(cursor);\n            }\n        },\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (() => {\n        if (bytes.length === 1 && bytes[0] < 0x80)\n            return 1;\n        if (bytes.length <= 55)\n            return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            }\n            else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            }\n            else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1)\n                    cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2)\n                    cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3)\n                    cursor.pushUint24(bytes.length);\n                else\n                    cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        },\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length <= 0xff)\n        return 1;\n    if (length <= 0xff_ff)\n        return 2;\n    if (length <= 0xff_ff_ff)\n        return 3;\n    if (length <= 0xff_ff_ff_ff)\n        return 4;\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError('Length is too large.');\n}\n//# sourceMappingURL=Rlp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1JscC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0U7QUFDTjtBQUNlO0FBQy9DO0FBQ0EseURBQXlELHNCQUFzQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVEQUFzQjtBQUNoRCxtQkFBbUIsOENBQWE7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsdURBQWE7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwrQkFBK0IsOENBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOENBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFnQjtBQUM5QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCLElBQUksa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQSx3RkFBd0YsYUFBYTtBQUNyRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxLQUFLO0FBQ2pCO0FBQ0EsbUJBQW1CLHVEQUFhO0FBQ2hDO0FBQ0E7QUFDQSxlQUFlLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxlQUFlO0FBQzNCLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ08sa0NBQWtDO0FBQ3pDLFlBQVksYUFBYTtBQUN6Qix1QkFBdUIsSUFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOENBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQWdCO0FBQzlCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzPzU4MGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEN1cnNvciBmcm9tICcuL2ludGVybmFsL2N1cnNvci5qcyc7XG4vKipcbiAqIERlY29kZXMgYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICogUmxwLnRvQnl0ZXMoJzB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JylcbiAqIC8vIFVpbnQ4QXJyYXkoWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvKHZhbHVlLCAnQnl0ZXMnKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBSbHAgfSBmcm9tICdveCdcbiAqIFJscC50b0hleCgnMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gMHg2ODY1NmM2YzZmMjA3NzZmNzI2YzY0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICByZXR1cm4gdG8odmFsdWUsICdIZXgnKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvKHZhbHVlLCB0bykge1xuICAgIGNvbnN0IHRvXyA9IHRvID8/ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnKTtcbiAgICBjb25zdCBieXRlcyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMyAmJiB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBIZXguSW52YWxpZExlbmd0aEVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkoKTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJ5dGVzLCB7XG4gICAgICAgIHJlY3Vyc2l2ZVJlYWRMaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZVJscEN1cnNvcihjdXJzb3IsIHRvXyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHBDdXJzb3IoY3Vyc29yLCB0byA9ICdIZXgnKSB7XG4gICAgaWYgKGN1cnNvci5ieXRlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAodG8gPT09ICdIZXgnID8gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpIDogY3Vyc29yLmJ5dGVzKTtcbiAgICBjb25zdCBwcmVmaXggPSBjdXJzb3IucmVhZEJ5dGUoKTtcbiAgICBpZiAocHJlZml4IDwgMHg4MClcbiAgICAgICAgY3Vyc29yLmRlY3JlbWVudFBvc2l0aW9uKDEpO1xuICAgIC8vIGJ5dGVzXG4gICAgaWYgKHByZWZpeCA8IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHg4MCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHRvID09PSAnSGV4JyA/IEhleC5mcm9tQnl0ZXMoYnl0ZXMpIDogYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBsaXN0XG4gICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHhjMCk7XG4gICAgcmV0dXJuIHJlYWRMaXN0KGN1cnNvciwgbGVuZ3RoLCB0byk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMHg4MCAmJiBwcmVmaXggPCAweDgwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAocHJlZml4IDw9IG9mZnNldCArIDU1KVxuICAgICAgICByZXR1cm4gcHJlZml4IC0gb2Zmc2V0O1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMSlcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDgoKTtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDIpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQxNigpO1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMylcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDI0KCk7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyA0KVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50MzIoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignSW52YWxpZCBSTFAgcHJlZml4Jyk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExpc3QoY3Vyc29yLCBsZW5ndGgsIHRvKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBjdXJzb3IucG9zaXRpb247XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvc2l0aW9uIC0gcG9zaXRpb24gPCBsZW5ndGgpXG4gICAgICAgIHZhbHVlLnB1c2goZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG8pKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgUmxwIH0gZnJvbSAnb3gnXG4gKlxuICogUmxwLmZyb20oJzB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCcsIHsgYXM6ICdIZXgnIH0pXG4gKiAvLyBAbG9nOiAweDhiNjg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICpcbiAqIFJscC5mcm9tKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSwgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbmNvZGFibGUgPSBnZXRFbmNvZGFibGUodmFsdWUpO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUobmV3IFVpbnQ4QXJyYXkoZW5jb2RhYmxlLmxlbmd0aCkpO1xuICAgIGVuY29kYWJsZS5lbmNvZGUoY3Vyc29yKTtcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpO1xuICAgIHJldHVybiBjdXJzb3IuYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBSbHAgfSBmcm9tICdveCdcbiAqXG4gKiBSbHAuZnJvbUJ5dGVzKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGJ5dGVzLCB7IGFzIH0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICpcbiAqIFJscC5mcm9tSGV4KCcweDY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gQGxvZzogMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGhleCwgeyBhcyB9KTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlKGJ5dGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKVxuICAgICAgICByZXR1cm4gZ2V0RW5jb2RhYmxlTGlzdChieXRlcy5tYXAoKHgpID0+IGdldEVuY29kYWJsZSh4KSkpO1xuICAgIHJldHVybiBnZXRFbmNvZGFibGVCeXRlcyhieXRlcyk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGFibGVMaXN0KGxpc3QpIHtcbiAgICBjb25zdCBib2R5TGVuZ3RoID0gbGlzdC5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHNpemVPZkJvZHlMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYm9keUxlbmd0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGJvZHlMZW5ndGggPD0gNTUpXG4gICAgICAgICAgICByZXR1cm4gMSArIGJvZHlMZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQm9keUxlbmd0aCArIGJvZHlMZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4YzAgKyBib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweGMwICsgNTUgKyBzaXplT2ZCb2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDMyKGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGVuY29kZSB9IG9mIGxpc3QpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGUoY3Vyc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXNPckhleCkge1xuICAgIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGJ5dGVzT3JIZXggPT09ICdzdHJpbmcnID8gQnl0ZXMuZnJvbUhleChieXRlc09ySGV4KSA6IGJ5dGVzT3JIZXg7XG4gICAgY29uc3Qgc2l6ZU9mQnl0ZXNMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcbiAgICBjb25zdCBsZW5ndGggPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMHg4MClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDw9IDU1KVxuICAgICAgICAgICAgcmV0dXJuIDEgKyBieXRlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQnl0ZXNMZW5ndGggKyBieXRlcy5sZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDEgJiYgYnl0ZXNbMF0gPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIDU1ICsgc2l6ZU9mQnl0ZXNMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MzIoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2l6ZU9mTGVuZ3RoKGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPD0gMHhmZilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGxlbmd0aCA8PSAweGZmX2ZmKVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAobGVuZ3RoIDw9IDB4ZmZfZmZfZmYpXG4gICAgICAgIHJldHVybiAzO1xuICAgIGlmIChsZW5ndGggPD0gMHhmZl9mZl9mZl9mZilcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoJ0xlbmd0aCBpcyB0b28gbGFyZ2UuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SbHAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Rlp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Secp256k1.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Secp256k1.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createKeyPair: () => (/* binding */ createKeyPair),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   getSharedSecret: () => (/* binding */ getSharedSecret),\n/* harmony export */   noble: () => (/* binding */ noble),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   recoverAddress: () => (/* binding */ recoverAddress),\n/* harmony export */   recoverPublicKey: () => (/* binding */ recoverPublicKey),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/entropy.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/entropy.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\n\n/** Re-export of noble/curves secp256k1 utilities. */\nconst noble = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1;\n/**\n * Creates a new secp256k1 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey, publicKey } = Secp256k1.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nfunction createKeyPair(options = {}) {\n    const { as = 'Hex' } = options;\n    const privateKey = randomPrivateKey({ as });\n    const publicKey = getPublicKey({ privateKey });\n    return {\n        privateKey: privateKey,\n        publicKey,\n    };\n}\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nfunction getPublicKey(options) {\n    const { privateKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromPrivateKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey: privateKeyA } = Secp256k1.createKeyPair()\n * const { publicKey: publicKeyB } = Secp256k1.createKeyPair()\n *\n * const sharedSecret = Secp256k1.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nfunction getSharedSecret(options) {\n    const { as = 'Hex', privateKey, publicKey } = options;\n    const point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint.fromHex(_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toHex(publicKey).slice(2));\n    const sharedPoint = point.multiply(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.normPrivateKeyToScalar(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(privateKey).slice(2)));\n    const sharedSecret = sharedPoint.toRawBytes(true); // compressed format\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(sharedSecret);\n    return sharedSecret;\n}\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nfunction randomPrivateKey(options = {}) {\n    const { as = 'Hex' } = options;\n    const bytes = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.randomPrivateKey();\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes);\n    return bytes;\n}\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nfunction recoverAddress(options) {\n    return _Address_js__WEBPACK_IMPORTED_MODULE_3__.fromPublicKey(recoverPublicKey(options));\n}\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nfunction recoverPublicKey(options) {\n    const { payload, signature } = options;\n    const { r, s, yParity } = signature;\n    const signature_ = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);\n    const point = signature_.recoverPublicKey(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(payload).substring(2));\n    return _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.from(point);\n}\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nfunction sign(options) {\n    const { extraEntropy = _internal_entropy_js__WEBPACK_IMPORTED_MODULE_4__.extraEntropy, hash, payload, privateKey, } = options;\n    const { r, s, recovery } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.sign(_Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(privateKey), {\n        extraEntropy: typeof extraEntropy === 'boolean'\n            ? extraEntropy\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(extraEntropy).slice(2),\n        lowS: true,\n        ...(hash ? { prehash: true } : {}),\n    });\n    return {\n        r,\n        s,\n        yParity: recovery,\n    };\n}\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nfunction verify(options) {\n    const { address, hash, payload, publicKey, signature } = options;\n    if (address)\n        return _Address_js__WEBPACK_IMPORTED_MODULE_3__.isEqual(address, recoverAddress({ payload, signature }));\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.verify(signature, _Bytes_js__WEBPACK_IMPORTED_MODULE_5__.from(payload), _PublicKey_js__WEBPACK_IMPORTED_MODULE_2__.toBytes(publicKey), ...(hash ? [{ prehash: true, lowS: true }] : []));\n}\n//# sourceMappingURL=Secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDWjtBQUNKO0FBQ0o7QUFDaUI7QUFDTDtBQUM1QztBQUNPLGNBQWMsOERBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxhQUFhO0FBQ3pCLDBDQUEwQyxJQUFJO0FBQzlDLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EsOENBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGFBQWE7QUFDekIsa0JBQWtCLDhEQUFTLGdDQUFnQyx5Q0FBUTtBQUNuRSxXQUFXLCtDQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksb0NBQW9DO0FBQ2hELGtCQUFrQiw4REFBUyx5QkFBeUIsZ0RBQWU7QUFDbkUsdUNBQXVDLDhEQUFTLDhCQUE4Qix5Q0FBUTtBQUN0Rix1REFBdUQ7QUFDdkQ7QUFDQSxlQUFlLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0NBQXNDO0FBQzdDLFlBQVksYUFBYTtBQUN6QixrQkFBa0IsOERBQVM7QUFDM0I7QUFDQSxlQUFlLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0NBQXNDLDRDQUE0QztBQUNsRjtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLHNDQUFzQyw0Q0FBNEM7QUFDbEY7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLGdCQUFnQjtBQUM1QiwyQkFBMkIsOERBQVM7QUFDcEMsOENBQThDLHlDQUFRO0FBQ3RELFdBQVcsK0NBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QjtBQUNwRDtBQUNPO0FBQ1AsWUFBWSxlQUFlLDhEQUFvQiwrQkFBK0I7QUFDOUUsWUFBWSxpQkFBaUIsRUFBRSw4REFBUyxNQUFNLDJDQUFVLFdBQVcsMkNBQVU7QUFDN0U7QUFDQTtBQUNBLGNBQWMseUNBQVE7QUFDdEI7QUFDQSxxQkFBcUIsZ0JBQWdCLElBQUk7QUFDekMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0Esc0NBQXNDLDRDQUE0QztBQUNsRjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRCxzQ0FBc0MsbUNBQW1DO0FBQ3pFO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLCtDQUErQztBQUMzRDtBQUNBLGVBQWUsZ0RBQWUsMkJBQTJCLG9CQUFvQjtBQUM3RSxXQUFXLDhEQUFTLG1CQUFtQiwyQ0FBVSxXQUFXLGtEQUFpQiwyQkFBMkIsMkJBQTJCO0FBQ25JO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2VjcDI1NmsxLmpzPzJhNDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgRW50cm9weSBmcm9tICcuL2ludGVybmFsL2VudHJvcHkuanMnO1xuaW1wb3J0ICogYXMgUHVibGljS2V5IGZyb20gJy4vUHVibGljS2V5LmpzJztcbi8qKiBSZS1leHBvcnQgb2Ygbm9ibGUvY3VydmVzIHNlY3AyNTZrMSB1dGlsaXRpZXMuICovXG5leHBvcnQgY29uc3Qgbm9ibGUgPSBzZWNwMjU2azE7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc2VjcDI1NmsxIEVDRFNBIGtleSBwYWlyIGNvbnNpc3Rpbmcgb2YgYSBwcml2YXRlIGtleSBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgcHVibGljIGtleS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0gPSBTZWNwMjU2azEuY3JlYXRlS2V5UGFpcigpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSBrZXkgcGFpci5cbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQga2V5IHBhaXIgY29udGFpbmluZyBib3RoIHByaXZhdGUgYW5kIHB1YmxpYyBrZXlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlS2V5UGFpcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHJhbmRvbVByaXZhdGVLZXkoeyBhcyB9KTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXG4gICAgICAgIHB1YmxpY0tleSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc2VjcDI1NmsxIEVDRFNBIHB1YmxpYyBrZXkgZnJvbSBhIHByb3ZpZGVkIHByaXZhdGUga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gU2VjcDI1NmsxLmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29tcHV0ZSB0aGUgcHVibGljIGtleS5cbiAqIEByZXR1cm5zIFRoZSBjb21wdXRlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljS2V5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHByaXZhdGVLZXkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21Qcml2YXRlS2V5KEhleC5mcm9tKHByaXZhdGVLZXkpLnNsaWNlKDIpKTtcbiAgICByZXR1cm4gUHVibGljS2V5LmZyb20ocG9pbnQpO1xufVxuLyoqXG4gKiBDb21wdXRlcyBhIHNoYXJlZCBzZWNyZXQgdXNpbmcgRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllLUhlbGxtYW4pIGJldHdlZW4gYSBwcml2YXRlIGtleSBhbmQgYSBwdWJsaWMga2V5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5OiBwcml2YXRlS2V5QSB9ID0gU2VjcDI1NmsxLmNyZWF0ZUtleVBhaXIoKVxuICogY29uc3QgeyBwdWJsaWNLZXk6IHB1YmxpY0tleUIgfSA9IFNlY3AyNTZrMS5jcmVhdGVLZXlQYWlyKClcbiAqXG4gKiBjb25zdCBzaGFyZWRTZWNyZXQgPSBTZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KHtcbiAqICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUEsXG4gKiAgIHB1YmxpY0tleTogcHVibGljS2V5QlxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29tcHV0ZSB0aGUgc2hhcmVkIHNlY3JldC5cbiAqIEByZXR1cm5zIFRoZSBjb21wdXRlZCBzaGFyZWQgc2VjcmV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFzID0gJ0hleCcsIHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleChQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KS5zbGljZSgyKSk7XG4gICAgY29uc3Qgc2hhcmVkUG9pbnQgPSBwb2ludC5tdWx0aXBseShzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihIZXguZnJvbShwcml2YXRlS2V5KS5zbGljZSgyKSkpO1xuICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IHNoYXJlZFBvaW50LnRvUmF3Qnl0ZXModHJ1ZSk7IC8vIGNvbXByZXNzZWQgZm9ybWF0XG4gICAgaWYgKGFzID09PSAnSGV4JylcbiAgICAgICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoc2hhcmVkU2VjcmV0KTtcbiAgICByZXR1cm4gc2hhcmVkU2VjcmV0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gRUNEU0EgcHJpdmF0ZSBrZXkgb24gdGhlIHNlY3AyNTZrMSBjdXJ2ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSBTZWNwMjU2azEucmFuZG9tUHJpdmF0ZUtleSgpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSBwcml2YXRlIGtleS5cbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgcHJpdmF0ZSBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21Qcml2YXRlS2V5KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnSGV4JyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gICAgaWYgKGFzID09PSAnSGV4JylcbiAgICAgICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBieXRlcztcbn1cbi8qKlxuICogUmVjb3ZlcnMgdGhlIHNpZ25pbmcgYWRkcmVzcyBmcm9tIHRoZSBzaWduZWQgcGF5bG9hZCBhbmQgc2lnbmF0dXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqXG4gKiBjb25zdCBhZGRyZXNzID0gU2VjcDI1NmsxLnJlY292ZXJBZGRyZXNzKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHJlY292ZXJlZCBhZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3Mob3B0aW9ucykge1xuICAgIHJldHVybiBBZGRyZXNzLmZyb21QdWJsaWNLZXkocmVjb3ZlclB1YmxpY0tleShvcHRpb25zKSk7XG59XG4vKipcbiAqIFJlY292ZXJzIHRoZSBzaWduaW5nIHB1YmxpYyBrZXkgZnJvbSB0aGUgc2lnbmVkIHBheWxvYWQgYW5kIHNpZ25hdHVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gU2VjcDI1NmsxLnJlY292ZXJQdWJsaWNLZXkoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHJlY292ZXJ5IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgcmVjb3ZlcmVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHBheWxvYWQsIHNpZ25hdHVyZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHIsIHMsIHlQYXJpdHkgfSA9IHNpZ25hdHVyZTtcbiAgICBjb25zdCBzaWduYXR1cmVfID0gbmV3IHNlY3AyNTZrMS5TaWduYXR1cmUoQmlnSW50KHIpLCBCaWdJbnQocykpLmFkZFJlY292ZXJ5Qml0KHlQYXJpdHkpO1xuICAgIGNvbnN0IHBvaW50ID0gc2lnbmF0dXJlXy5yZWNvdmVyUHVibGljS2V5KEhleC5mcm9tKHBheWxvYWQpLnN1YnN0cmluZygyKSk7XG4gICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tKHBvaW50KTtcbn1cbi8qKlxuICogU2lnbnMgdGhlIHBheWxvYWQgd2l0aCB0aGUgcHJvdmlkZWQgcHJpdmF0ZSBrZXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmluZyBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIEVDRFNBIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ24ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgZXh0cmFFbnRyb3B5ID0gRW50cm9weS5leHRyYUVudHJvcHksIGhhc2gsIHBheWxvYWQsIHByaXZhdGVLZXksIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgciwgcywgcmVjb3ZlcnkgfSA9IHNlY3AyNTZrMS5zaWduKEJ5dGVzLmZyb20ocGF5bG9hZCksIEJ5dGVzLmZyb20ocHJpdmF0ZUtleSksIHtcbiAgICAgICAgZXh0cmFFbnRyb3B5OiB0eXBlb2YgZXh0cmFFbnRyb3B5ID09PSAnYm9vbGVhbidcbiAgICAgICAgICAgID8gZXh0cmFFbnRyb3B5XG4gICAgICAgICAgICA6IEhleC5mcm9tKGV4dHJhRW50cm9weSkuc2xpY2UoMiksXG4gICAgICAgIGxvd1M6IHRydWUsXG4gICAgICAgIC4uLihoYXNoID8geyBwcmVoYXNoOiB0cnVlIH0gOiB7fSksXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgeVBhcml0eTogcmVjb3ZlcnksXG4gICAgfTtcbn1cbi8qKlxuICogVmVyaWZpZXMgYSBwYXlsb2FkIHdhcyBzaWduZWQgYnkgdGhlIHByb3ZpZGVkIGFkZHJlc3MuXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBWZXJpZnkgd2l0aCBFdGhlcmV1bSBBZGRyZXNzXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKlxuICogY29uc3QgdmVyaWZpZWQgPSBTZWNwMjU2azEudmVyaWZ5KHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBhZGRyZXNzOiAnMHhmMzlmZDZlNTFhYWQ4OGY2ZjRjZTZhYjg4MjcyNzljZmZmYjkyMjY2JywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBwYXlsb2FkOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFZlcmlmeSB3aXRoIFB1YmxpYyBLZXlcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9ICcweC4uLidcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleSB9KVxuICpcbiAqIGNvbnN0IHZlcmlmaWVkID0gU2VjcDI1NmsxLnZlcmlmeSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgcHVibGljS2V5LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHBheWxvYWQ6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHZlcmlmaWNhdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgcGF5bG9hZCB3YXMgc2lnbmVkIGJ5IHRoZSBwcm92aWRlZCBhZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGhhc2gsIHBheWxvYWQsIHB1YmxpY0tleSwgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGlmIChhZGRyZXNzKVxuICAgICAgICByZXR1cm4gQWRkcmVzcy5pc0VxdWFsKGFkZHJlc3MsIHJlY292ZXJBZGRyZXNzKHsgcGF5bG9hZCwgc2lnbmF0dXJlIH0pKTtcbiAgICByZXR1cm4gc2VjcDI1NmsxLnZlcmlmeShzaWduYXR1cmUsIEJ5dGVzLmZyb20ocGF5bG9hZCksIFB1YmxpY0tleS50b0J5dGVzKHB1YmxpY0tleSksIC4uLihoYXNoID8gW3sgcHJlaGFzaDogdHJ1ZSwgbG93UzogdHJ1ZSB9XSA6IFtdKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Signature.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Signature.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidRError: () => (/* binding */ InvalidRError),\n/* harmony export */   InvalidSError: () => (/* binding */ InvalidSError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidVError: () => (/* binding */ InvalidVError),\n/* harmony export */   InvalidYParityError: () => (/* binding */ InvalidYParityError),\n/* harmony export */   MissingPropertiesError: () => (/* binding */ MissingPropertiesError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromDerBytes: () => (/* binding */ fromDerBytes),\n/* harmony export */   fromDerHex: () => (/* binding */ fromDerHex),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromLegacy: () => (/* binding */ fromLegacy),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toDerBytes: () => (/* binding */ toDerBytes),\n/* harmony export */   toDerHex: () => (/* binding */ toDerHex),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toLegacy: () => (/* binding */ toLegacy),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   vToYParity: () => (/* binding */ vToYParity),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   yParityToV: () => (/* binding */ yParityToV)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nfunction assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (typeof signature.s === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (recovered && typeof signature.yParity === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (signature.r < 0n || signature.r > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256)\n        throw new InvalidRError({ value: signature.r });\n    if (signature.s < 0n || signature.s > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256)\n        throw new InvalidSError({ value: signature.s });\n    if (typeof signature.yParity === 'number' &&\n        signature.yParity !== 0 &&\n        signature.yParity !== 1)\n        throw new InvalidYParityError({ value: signature.yParity });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nfunction fromBytes(signature) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nfunction fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132)\n        throw new InvalidSerializedSizeError({ signature });\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 0, 32));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 32, 64));\n    const yParity = (() => {\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity))\n            return undefined;\n        try {\n            return vToYParity(yParity);\n        }\n        catch {\n            throw new InvalidYParityError({ value: yParity });\n        }\n    })();\n    if (typeof yParity === 'undefined')\n        return {\n            r,\n            s,\n        };\n    return {\n        r,\n        s,\n        yParity,\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nfunction extract(value) {\n    if (typeof value.r === 'undefined')\n        return undefined;\n    if (typeof value.s === 'undefined')\n        return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nfunction from(signature) {\n    const signature_ = (() => {\n        if (typeof signature === 'string')\n            return fromHex(signature);\n        if (signature instanceof Uint8Array)\n            return fromBytes(signature);\n        if (typeof signature.r === 'string')\n            return fromRpc(signature);\n        if (signature.v)\n            return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...(typeof signature.yParity !== 'undefined'\n                ? { yParity: signature.yParity }\n                : {}),\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromDerBytes(signature) {\n    return fromDerHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromDerHex(signature) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromDER(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature).slice(2));\n    return { r, s };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nfunction fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nfunction fromRpc(signature) {\n    const yParity = (() => {\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === 'number' && typeof yParity !== 'number')\n            yParity = vToYParity(v);\n        if (typeof yParity !== 'number')\n            throw new InvalidYParityError({ value: signature.yParity });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity,\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === '0x' ? 0n : BigInt(r),\n        s: s === '0x' ? 0n : BigInt(s),\n        yParity: yParity === '0x' ? 0 : Number(yParity),\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nfunction toBytes(signature) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nfunction toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, { size: 32 }), _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, { size: 32 }), \n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n        ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(yParityToV(signature.yParity), { size: 1 })\n        : '0x');\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nfunction toDerBytes(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nfunction toDerHex(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nfunction toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nfunction toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, { size: 32 }),\n        s: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, { size: 32 }),\n        yParity: yParity === 0 ? '0x0' : '0x1',\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nfunction toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? '0x01' : '0x',\n        r === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r)),\n        s === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s)),\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nfunction validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nfunction vToYParity(v) {\n    if (v === 0 || v === 27)\n        return 0;\n    if (v === 1 || v === 28)\n        return 1;\n    if (v >= 35)\n        return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({ value: v });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nfunction yParityToV(yParity) {\n    if (yParity === 0)\n        return 27;\n    if (yParity === 1)\n        return 28;\n    throw new InvalidYParityError({ value: yParity });\n}\n/** Thrown when the serialized signature is of an invalid size. */\nclass InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }) {\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                'Expected: 64 bytes or 65 bytes.',\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSerializedSizeError'\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nclass MissingPropertiesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }) {\n        super(`Signature \\`${_Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.MissingPropertiesError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */\nclass InvalidRError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidRError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */\nclass InvalidSError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */\nclass InvalidYParityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidYParityError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */\nclass InvalidVError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidVError'\n        });\n    }\n}\n//# sourceMappingURL=Signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNoQjtBQUNFO0FBQ047QUFDRTtBQUNRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QztBQUM5QyxZQUFZLFlBQVk7QUFDeEI7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQsMENBQTBDLG9EQUFtQjtBQUM3RCxrQ0FBa0Msb0JBQW9CO0FBQ3RELDBDQUEwQyxvREFBbUI7QUFDN0Qsa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMEJBQTBCO0FBQ2xFO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLDZCQUE2Qiw2QkFBNkI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ087QUFDUCxtQkFBbUIsOENBQWE7QUFDaEM7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0IsNkJBQTZCLDZCQUE2QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ087QUFDUDtBQUNBLCtDQUErQyxXQUFXO0FBQzFELHFCQUFxQiwwQ0FBUztBQUM5QixxQkFBcUIsMENBQVM7QUFDOUI7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRD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QVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0E7QUFDTyx5Q0FBeUMsaURBQWdCO0FBQ2hFLGtCQUFrQixXQUFXO0FBQzdCLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQSw0QkFBNEIseUNBQVEsQ0FBQyx5Q0FBUSxjQUFjO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08scUNBQXFDLGlEQUFnQjtBQUM1RCxrQkFBa0IsV0FBVztBQUM3Qiw2QkFBNkIsK0NBQWMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBZ0I7QUFDbkQsa0JBQWtCLE9BQU87QUFDekIseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsaURBQWdCO0FBQ25ELGtCQUFrQixPQUFPO0FBQ3pCLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLGlEQUFnQjtBQUN6RCxrQkFBa0IsT0FBTztBQUN6Qix5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBZ0I7QUFDbkQsa0JBQWtCLE9BQU87QUFDekIseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2lnbmF0dXJlLmpzP2UyYmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbmltcG9ydCAqIGFzIFNvbGlkaXR5IGZyb20gJy4vU29saWRpdHkuanMnO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgYSBTaWduYXR1cmUgaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuYXNzZXJ0KHtcbiAqICAgcjogLTQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBlcnJvcjogSW52YWxpZFNpZ25hdHVyZVJFcnJvcjpcbiAqIC8vIEBlcnJvcjogVmFsdWUgYC01NDkuLi5uYCBpcyBhbiBpbnZhbGlkIHIgdmFsdWUuXG4gKiAvLyBAZXJyb3I6IHIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIDJeMjU2LlxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgb2JqZWN0IHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChzaWduYXR1cmUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcmVjb3ZlcmVkIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5zID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgaWYgKHJlY292ZXJlZCAmJiB0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAoc2lnbmF0dXJlLnIgPCAwbiB8fCBzaWduYXR1cmUuciA+IFNvbGlkaXR5Lm1heFVpbnQyNTYpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUkVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS5yIH0pO1xuICAgIGlmIChzaWduYXR1cmUucyA8IDBuIHx8IHNpZ25hdHVyZS5zID4gU29saWRpdHkubWF4VWludDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTRXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnMgfSk7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgc2lnbmF0dXJlLnlQYXJpdHkgIT09IDAgJiZcbiAgICAgICAgc2lnbmF0dXJlLnlQYXJpdHkgIT09IDEpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS55UGFyaXR5IH0pO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHNpZ25hdHVyZSBpbnRvIGEgc3RydWN0dXJlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzEyOCwgMywgMTMxLCAuLi5dKSlcbiAqIC8vIEBsb2c6IHsgcjogNTIzMS4uLm4sIHM6IDM1MjIuLi5uLCB5UGFyaXR5OiAwIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZnJvbUhleChIZXguZnJvbUJ5dGVzKHNpZ25hdHVyZSkpO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gc2lnbmF0dXJlIGludG8gYSBzdHJ1Y3R1cmVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tSGV4KCcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MWMnKVxuICogLy8gQGxvZzogeyByOiA1MjMxLi4ubiwgczogMzUyMi4uLm4sIHlQYXJpdHk6IDAgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWQgLSBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgoc2lnbmF0dXJlKSB7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMCAmJiBzaWduYXR1cmUubGVuZ3RoICE9PSAxMzIpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBjb25zdCByID0gQmlnSW50KEhleC5zbGljZShzaWduYXR1cmUsIDAsIDMyKSk7XG4gICAgY29uc3QgcyA9IEJpZ0ludChIZXguc2xpY2Uoc2lnbmF0dXJlLCAzMiwgNjQpKTtcbiAgICBjb25zdCB5UGFyaXR5ID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgeVBhcml0eSA9IE51bWJlcihgMHgke3NpZ25hdHVyZS5zbGljZSgxMzApfWApO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHlQYXJpdHkpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2VG9ZUGFyaXR5KHlQYXJpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHlQYXJpdHkgfSk7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIGlmICh0eXBlb2YgeVBhcml0eSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICByLFxuICAgICAgICBzLFxuICAgICAgICB5UGFyaXR5LFxuICAgIH07XG59XG4vKipcbiAqIEV4dHJhY3RzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGZyb20gYW4gYXJiaXRyYXJ5IG9iamVjdCB0aGF0IG1heSBpbmNsdWRlIHNpZ25hdHVyZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZXh0cmFjdCh7XG4gKiAgIGJhejogJ2JhcnJ5JyxcbiAqICAgZm9vOiAnYmFyJyxcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiAgIHplYnJhOiAnc3RyaXBlcycsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMVxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGFyYml0cmFyeSBvYmplY3QgdG8gZXh0cmFjdCB0aGUgc2lnbmF0dXJlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgZXh0cmFjdGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUucyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZyb20odmFsdWUpO1xufVxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSB0eXBlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gb2JqZWN0IGZyb20gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0sIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSwge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSwgb3Ige0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gU2VyaWFsaXplZFxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbSgnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODAxJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDEsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gTGVnYWN5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tKHtcbiAqICAgcjogNDczMjM0NTcwMDc0NTM2NTcyMDc4ODk3MzAyNDM4MjY5NjU3NjE5MjIyOTY1OTk2ODA0NzM4ODY1ODgyODcwMTU3NTU2NTI3MDEwNzJuLFxuICogICBzOiA1NzIyODgwMzIwMjcyNzEzMTUwMjk0OTM1ODMxMzQ1NjA3MTI4MDQ4ODE4NDI3MDI1ODI5MzY3NDI0MjEyNDM0MDExMzgyNDg4Mjc4OG4sXG4gKiAgIHY6IDI3LFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDczMjM0NTcwMDc0NTM2NTcyMDc4ODk3MzAyNDM4MjY5NjU3NjE5MjIyOTY1OTk2ODA0NzM4ODY1ODgyODcwMTU3NTU2NTI3MDEwNzJuLFxuICogLy8gQGxvZzogICBzOiA1NzIyODgwMzIwMjcyNzEzMTUwMjk0OTM1ODMxMzQ1NjA3MTI4MDQ4ODE4NDI3MDI1ODI5MzY3NDI0MjEyNDM0MDExMzgyNDg4Mjc4OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDBcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHZhbHVlIHRvIGluc3RhbnRpYXRlLlxuICogQHJldHVybnMgVGhlIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUhleChzaWduYXR1cmUpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tQnl0ZXMoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUuciA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gZnJvbVJwYyhzaWduYXR1cmUpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlLnYpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUxlZ2FjeShzaWduYXR1cmUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgICAgICBzOiBzaWduYXR1cmUucyxcbiAgICAgICAgICAgIC4uLih0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB7IHlQYXJpdHk6IHNpZ25hdHVyZS55UGFyaXR5IH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGFzc2VydChzaWduYXR1cmVfKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlXztcbn1cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBzaWduYXR1cmUgdG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tRGVyQnl0ZXMobmV3IFVpbnQ4QXJyYXkoWzEzMiwgNTEsIDIzLCAuLi5dKSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21EZXJCeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gZnJvbURlckhleChIZXguZnJvbUJ5dGVzKHNpZ25hdHVyZSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tRGVySGV4KCcweDMwNDQwMjIwNmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjAyMjA0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21EZXJIZXgoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzIH0gPSBzZWNwMjU2azEuU2lnbmF0dXJlLmZyb21ERVIoSGV4LmZyb20oc2lnbmF0dXJlKS5zbGljZSgyKSk7XG4gICAgcmV0dXJuIHsgciwgcyB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbGVnYWN5ID0gU2lnbmF0dXJlLmZyb21MZWdhY3koeyByOiAxbiwgczogMm4sIHY6IDI4IH0pXG4gKiAvLyBAbG9nOiB7IHI6IDFuLCBzOiAybiwgeVBhcml0eTogMSB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTGVnYWN5KHNpZ25hdHVyZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IHNpZ25hdHVyZS5yLFxuICAgICAgICBzOiBzaWduYXR1cmUucyxcbiAgICAgICAgeVBhcml0eTogdlRvWVBhcml0eShzaWduYXR1cmUudiksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30gaW50byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tUnBjKHtcbiAqICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICB5UGFyaXR5OiAnMHgwJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuUnBjfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHlQYXJpdHkgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCB2ID0gc2lnbmF0dXJlLnYgPyBOdW1iZXIoc2lnbmF0dXJlLnYpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgeVBhcml0eSA9IHNpZ25hdHVyZS55UGFyaXR5ID8gTnVtYmVyKHNpZ25hdHVyZS55UGFyaXR5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeVBhcml0eSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB5UGFyaXR5ID0gdlRvWVBhcml0eSh2KTtcbiAgICAgICAgaWYgKHR5cGVvZiB5UGFyaXR5ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS55UGFyaXR5IH0pO1xuICAgICAgICByZXR1cm4geVBhcml0eTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IEJpZ0ludChzaWduYXR1cmUuciksXG4gICAgICAgIHM6IEJpZ0ludChzaWduYXR1cmUucyksXG4gICAgICAgIHlQYXJpdHksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tVHVwbGUoWycweDAxJywgJzB4N2InLCAnMHgxYzgnXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogMTIzbixcbiAqIC8vIEBsb2c6ICAgczogNDU2bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZSh0dXBsZSkge1xuICAgIGNvbnN0IFt5UGFyaXR5LCByLCBzXSA9IHR1cGxlO1xuICAgIHJldHVybiBmcm9tKHtcbiAgICAgICAgcjogciA9PT0gJzB4JyA/IDBuIDogQmlnSW50KHIpLFxuICAgICAgICBzOiBzID09PSAnMHgnID8gMG4gOiBCaWdJbnQocyksXG4gICAgICAgIHlQYXJpdHk6IHlQYXJpdHkgPT09ICcweCcgPyAwIDogTnVtYmVyKHlQYXJpdHkpLFxuICAgIH0pO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9CeXRlcyh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxXG4gKiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTAyLCAxNiwgMTAsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8ge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvSGV4KHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODFjJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoc2lnbmF0dXJlKSB7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZSk7XG4gICAgY29uc3QgciA9IHNpZ25hdHVyZS5yO1xuICAgIGNvbnN0IHMgPSBzaWduYXR1cmUucztcbiAgICBjb25zdCBzaWduYXR1cmVfID0gSGV4LmNvbmNhdChIZXguZnJvbU51bWJlcihyLCB7IHNpemU6IDMyIH0pLCBIZXguZnJvbU51bWJlcihzLCB7IHNpemU6IDMyIH0pLCBcbiAgICAvLyBJZiB0aGUgc2lnbmF0dXJlIGlzIHJlY292ZXJlZCwgYWRkIHRoZSByZWNvdmVyeSBieXRlIHRvIHRoZSBzaWduYXR1cmUuXG4gICAgdHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAnbnVtYmVyJ1xuICAgICAgICA/IEhleC5mcm9tTnVtYmVyKHlQYXJpdHlUb1Yoc2lnbmF0dXJlLnlQYXJpdHkpLCB7IHNpemU6IDEgfSlcbiAgICAgICAgOiAnMHgnKTtcbiAgICByZXR1cm4gc2lnbmF0dXJlXztcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gREVSLWVuY29kZWQgZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlX2RlciA9IFNpZ25hdHVyZS50b0RlckJ5dGVzKHNpZ25hdHVyZSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzEzMiwgNTEsIDIzLCAuLi5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGVyQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gbmV3IHNlY3AyNTZrMS5TaWduYXR1cmUoc2lnbmF0dXJlLnIsIHNpZ25hdHVyZS5zKTtcbiAgICByZXR1cm4gc2lnLnRvREVSUmF3Qnl0ZXMoKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gREVSLWVuY29kZWQgZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlX2RlciA9IFNpZ25hdHVyZS50b0RlckhleChzaWduYXR1cmUpXG4gKiAvLyBAbG9nOiAnMHgzMDQ0MDIyMDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmYwMjIwNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiOCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZXJIZXgoc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gbmV3IHNlY3AyNTZrMS5TaWduYXR1cmUoc2lnbmF0dXJlLnIsIHNpZ25hdHVyZS5zKTtcbiAgICByZXR1cm4gYDB4JHtzaWcudG9ERVJIZXgoKX1gO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgbGVnYWN5ID0gU2lnbmF0dXJlLnRvTGVnYWN5KHsgcjogMW4sIHM6IDJuLCB5UGFyaXR5OiAxIH0pXG4gKiAvLyBAbG9nOiB7IHI6IDFuLCBzOiAybiwgdjogMjggfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9MZWdhY3koc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICB2OiB5UGFyaXR5VG9WKHNpZ25hdHVyZS55UGFyaXR5KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvUnBjKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMsIHlQYXJpdHkgfSA9IHNpZ25hdHVyZTtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBIZXguZnJvbU51bWJlcihyLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICBzOiBIZXguZnJvbU51bWJlcihzLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICB5UGFyaXR5OiB5UGFyaXR5ID09PSAwID8gJzB4MCcgOiAnMHgxJyxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBhIHNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0gdG8gYmUgdXNlZCBmb3Igc2lnbmF0dXJlcyBpbiBUcmFuc2FjdGlvbiBFbnZlbG9wZXMsIEVJUC03NzAyIEF1dGhvcml6YXRpb24gTGlzdHMsIGV0Yy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZVR1cGxlID0gU2lnbmF0dXJlLnRvVHVwbGUoe1xuICogICByOiAxMjNuLFxuICogICBzOiA0NTZuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IFt5UGFyaXR5OiAnMHgwMScsIHI6ICcweDdiJywgczogJzB4MWM4J11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1R1cGxlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcywgeVBhcml0eSB9ID0gc2lnbmF0dXJlO1xuICAgIHJldHVybiBbXG4gICAgICAgIHlQYXJpdHkgPyAnMHgwMScgOiAnMHgnLFxuICAgICAgICByID09PSAwbiA/ICcweCcgOiBIZXgudHJpbUxlZnQoSGV4LmZyb21OdW1iZXIocikpLFxuICAgICAgICBzID09PSAwbiA/ICcweCcgOiBIZXgudHJpbUxlZnQoSGV4LmZyb21OdW1iZXIocykpLFxuICAgIF07XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIFNpZ25hdHVyZS4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZS52YWxpZGF0ZSh7XG4gKiAgIHI6IC00OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgb2JqZWN0IHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHNpZ25hdHVyZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHNpZ25hdHVyZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGEgRUNEU0EgYHZgIHZhbHVlIHRvIGEgYHlQYXJpdHlgIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeVBhcml0eSA9IFNpZ25hdHVyZS52VG9ZUGFyaXR5KDI4KVxuICogLy8gQGxvZzogMVxuICogYGBgXG4gKlxuICogQHBhcmFtIHYgLSBUaGUgRUNEU0EgYHZgIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYHlQYXJpdHlgIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdlRvWVBhcml0eSh2KSB7XG4gICAgaWYgKHYgPT09IDAgfHwgdiA9PT0gMjcpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmICh2ID09PSAxIHx8IHYgPT09IDI4KVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodiA+PSAzNSlcbiAgICAgICAgcmV0dXJuIHYgJSAyID09PSAwID8gMSA6IDA7XG4gICAgdGhyb3cgbmV3IEludmFsaWRWRXJyb3IoeyB2YWx1ZTogdiB9KTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBFQ0RTQSBgdmAgdmFsdWUgdG8gYSBgeVBhcml0eWAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2ID0gU2lnbmF0dXJlLnlQYXJpdHlUb1YoMSlcbiAqIC8vIEBsb2c6IDI4XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0geVBhcml0eSAtIFRoZSBFQ0RTQSBgeVBhcml0eWAgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBgdmAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5UGFyaXR5VG9WKHlQYXJpdHkpIHtcbiAgICBpZiAoeVBhcml0eSA9PT0gMClcbiAgICAgICAgcmV0dXJuIDI3O1xuICAgIGlmICh5UGFyaXR5ID09PSAxKVxuICAgICAgICByZXR1cm4gMjg7XG4gICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogeVBhcml0eSB9KTtcbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2VyaWFsaXplZCBzaWduYXR1cmUgaXMgb2YgYW4gaW52YWxpZCBzaXplLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHtzaWduYXR1cmV9XFxgIGlzIGFuIGludmFsaWQgc2lnbmF0dXJlIHNpemUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkOiA2NCBieXRlcyBvciA2NSBieXRlcy4nLFxuICAgICAgICAgICAgICAgIGBSZWNlaXZlZCAke0hleC5zaXplKEhleC5mcm9tKHNpZ25hdHVyZSkpfSBieXRlcy5gLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGlzIG1pc3NpbmcgZWl0aGVyIGFuIGByYCwgYHNgLCBvciBgeVBhcml0eWAgcHJvcGVydHkuICovXG5leHBvcnQgY2xhc3MgTWlzc2luZ1Byb3BlcnRpZXNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2lnbmF0dXJlIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpZ25hdHVyZSBcXGAke0pzb24uc3RyaW5naWZ5KHNpZ25hdHVyZSl9XFxgIGlzIG1pc3NpbmcgZWl0aGVyIGFuIFxcYHJcXGAsIFxcYHNcXGAsIG9yIFxcYHlQYXJpdHlcXGAgcHJvcGVydHkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuTWlzc2luZ1Byb3BlcnRpZXNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHJgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRSRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgciB2YWx1ZS4gciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFJFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHNgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgcyB2YWx1ZS4gcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHlQYXJpdHlgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRZUGFyaXR5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgeS1wYXJpdHkgdmFsdWUuIFktcGFyaXR5IG11c3QgYmUgMCBvciAxLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRZUGFyaXR5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGhhcyBhbiBpbnZhbGlkIGB2YCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHYgdmFsdWUuIHYgbXVzdCBiZSAyNywgMjggb3IgPj0zNS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkVkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaWduYXR1cmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Solidity.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_esm/core/Solidity.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayRegex: () => (/* binding */ arrayRegex),\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   maxInt104: () => (/* binding */ maxInt104),\n/* harmony export */   maxInt112: () => (/* binding */ maxInt112),\n/* harmony export */   maxInt120: () => (/* binding */ maxInt120),\n/* harmony export */   maxInt128: () => (/* binding */ maxInt128),\n/* harmony export */   maxInt136: () => (/* binding */ maxInt136),\n/* harmony export */   maxInt144: () => (/* binding */ maxInt144),\n/* harmony export */   maxInt152: () => (/* binding */ maxInt152),\n/* harmony export */   maxInt16: () => (/* binding */ maxInt16),\n/* harmony export */   maxInt160: () => (/* binding */ maxInt160),\n/* harmony export */   maxInt168: () => (/* binding */ maxInt168),\n/* harmony export */   maxInt176: () => (/* binding */ maxInt176),\n/* harmony export */   maxInt184: () => (/* binding */ maxInt184),\n/* harmony export */   maxInt192: () => (/* binding */ maxInt192),\n/* harmony export */   maxInt200: () => (/* binding */ maxInt200),\n/* harmony export */   maxInt208: () => (/* binding */ maxInt208),\n/* harmony export */   maxInt216: () => (/* binding */ maxInt216),\n/* harmony export */   maxInt224: () => (/* binding */ maxInt224),\n/* harmony export */   maxInt232: () => (/* binding */ maxInt232),\n/* harmony export */   maxInt24: () => (/* binding */ maxInt24),\n/* harmony export */   maxInt240: () => (/* binding */ maxInt240),\n/* harmony export */   maxInt248: () => (/* binding */ maxInt248),\n/* harmony export */   maxInt256: () => (/* binding */ maxInt256),\n/* harmony export */   maxInt32: () => (/* binding */ maxInt32),\n/* harmony export */   maxInt40: () => (/* binding */ maxInt40),\n/* harmony export */   maxInt48: () => (/* binding */ maxInt48),\n/* harmony export */   maxInt56: () => (/* binding */ maxInt56),\n/* harmony export */   maxInt64: () => (/* binding */ maxInt64),\n/* harmony export */   maxInt72: () => (/* binding */ maxInt72),\n/* harmony export */   maxInt8: () => (/* binding */ maxInt8),\n/* harmony export */   maxInt80: () => (/* binding */ maxInt80),\n/* harmony export */   maxInt88: () => (/* binding */ maxInt88),\n/* harmony export */   maxInt96: () => (/* binding */ maxInt96),\n/* harmony export */   maxUint104: () => (/* binding */ maxUint104),\n/* harmony export */   maxUint112: () => (/* binding */ maxUint112),\n/* harmony export */   maxUint120: () => (/* binding */ maxUint120),\n/* harmony export */   maxUint128: () => (/* binding */ maxUint128),\n/* harmony export */   maxUint136: () => (/* binding */ maxUint136),\n/* harmony export */   maxUint144: () => (/* binding */ maxUint144),\n/* harmony export */   maxUint152: () => (/* binding */ maxUint152),\n/* harmony export */   maxUint16: () => (/* binding */ maxUint16),\n/* harmony export */   maxUint160: () => (/* binding */ maxUint160),\n/* harmony export */   maxUint168: () => (/* binding */ maxUint168),\n/* harmony export */   maxUint176: () => (/* binding */ maxUint176),\n/* harmony export */   maxUint184: () => (/* binding */ maxUint184),\n/* harmony export */   maxUint192: () => (/* binding */ maxUint192),\n/* harmony export */   maxUint200: () => (/* binding */ maxUint200),\n/* harmony export */   maxUint208: () => (/* binding */ maxUint208),\n/* harmony export */   maxUint216: () => (/* binding */ maxUint216),\n/* harmony export */   maxUint224: () => (/* binding */ maxUint224),\n/* harmony export */   maxUint232: () => (/* binding */ maxUint232),\n/* harmony export */   maxUint24: () => (/* binding */ maxUint24),\n/* harmony export */   maxUint240: () => (/* binding */ maxUint240),\n/* harmony export */   maxUint248: () => (/* binding */ maxUint248),\n/* harmony export */   maxUint256: () => (/* binding */ maxUint256),\n/* harmony export */   maxUint32: () => (/* binding */ maxUint32),\n/* harmony export */   maxUint40: () => (/* binding */ maxUint40),\n/* harmony export */   maxUint48: () => (/* binding */ maxUint48),\n/* harmony export */   maxUint56: () => (/* binding */ maxUint56),\n/* harmony export */   maxUint64: () => (/* binding */ maxUint64),\n/* harmony export */   maxUint72: () => (/* binding */ maxUint72),\n/* harmony export */   maxUint8: () => (/* binding */ maxUint8),\n/* harmony export */   maxUint80: () => (/* binding */ maxUint80),\n/* harmony export */   maxUint88: () => (/* binding */ maxUint88),\n/* harmony export */   maxUint96: () => (/* binding */ maxUint96),\n/* harmony export */   minInt104: () => (/* binding */ minInt104),\n/* harmony export */   minInt112: () => (/* binding */ minInt112),\n/* harmony export */   minInt120: () => (/* binding */ minInt120),\n/* harmony export */   minInt128: () => (/* binding */ minInt128),\n/* harmony export */   minInt136: () => (/* binding */ minInt136),\n/* harmony export */   minInt144: () => (/* binding */ minInt144),\n/* harmony export */   minInt152: () => (/* binding */ minInt152),\n/* harmony export */   minInt16: () => (/* binding */ minInt16),\n/* harmony export */   minInt160: () => (/* binding */ minInt160),\n/* harmony export */   minInt168: () => (/* binding */ minInt168),\n/* harmony export */   minInt176: () => (/* binding */ minInt176),\n/* harmony export */   minInt184: () => (/* binding */ minInt184),\n/* harmony export */   minInt192: () => (/* binding */ minInt192),\n/* harmony export */   minInt200: () => (/* binding */ minInt200),\n/* harmony export */   minInt208: () => (/* binding */ minInt208),\n/* harmony export */   minInt216: () => (/* binding */ minInt216),\n/* harmony export */   minInt224: () => (/* binding */ minInt224),\n/* harmony export */   minInt232: () => (/* binding */ minInt232),\n/* harmony export */   minInt24: () => (/* binding */ minInt24),\n/* harmony export */   minInt240: () => (/* binding */ minInt240),\n/* harmony export */   minInt248: () => (/* binding */ minInt248),\n/* harmony export */   minInt256: () => (/* binding */ minInt256),\n/* harmony export */   minInt32: () => (/* binding */ minInt32),\n/* harmony export */   minInt40: () => (/* binding */ minInt40),\n/* harmony export */   minInt48: () => (/* binding */ minInt48),\n/* harmony export */   minInt56: () => (/* binding */ minInt56),\n/* harmony export */   minInt64: () => (/* binding */ minInt64),\n/* harmony export */   minInt72: () => (/* binding */ minInt72),\n/* harmony export */   minInt8: () => (/* binding */ minInt8),\n/* harmony export */   minInt80: () => (/* binding */ minInt80),\n/* harmony export */   minInt88: () => (/* binding */ minInt88),\n/* harmony export */   minInt96: () => (/* binding */ minInt96)\n/* harmony export */ });\nconst arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nconst bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nconst integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nconst maxInt8 = 2n ** (8n - 1n) - 1n;\nconst maxInt16 = 2n ** (16n - 1n) - 1n;\nconst maxInt24 = 2n ** (24n - 1n) - 1n;\nconst maxInt32 = 2n ** (32n - 1n) - 1n;\nconst maxInt40 = 2n ** (40n - 1n) - 1n;\nconst maxInt48 = 2n ** (48n - 1n) - 1n;\nconst maxInt56 = 2n ** (56n - 1n) - 1n;\nconst maxInt64 = 2n ** (64n - 1n) - 1n;\nconst maxInt72 = 2n ** (72n - 1n) - 1n;\nconst maxInt80 = 2n ** (80n - 1n) - 1n;\nconst maxInt88 = 2n ** (88n - 1n) - 1n;\nconst maxInt96 = 2n ** (96n - 1n) - 1n;\nconst maxInt104 = 2n ** (104n - 1n) - 1n;\nconst maxInt112 = 2n ** (112n - 1n) - 1n;\nconst maxInt120 = 2n ** (120n - 1n) - 1n;\nconst maxInt128 = 2n ** (128n - 1n) - 1n;\nconst maxInt136 = 2n ** (136n - 1n) - 1n;\nconst maxInt144 = 2n ** (144n - 1n) - 1n;\nconst maxInt152 = 2n ** (152n - 1n) - 1n;\nconst maxInt160 = 2n ** (160n - 1n) - 1n;\nconst maxInt168 = 2n ** (168n - 1n) - 1n;\nconst maxInt176 = 2n ** (176n - 1n) - 1n;\nconst maxInt184 = 2n ** (184n - 1n) - 1n;\nconst maxInt192 = 2n ** (192n - 1n) - 1n;\nconst maxInt200 = 2n ** (200n - 1n) - 1n;\nconst maxInt208 = 2n ** (208n - 1n) - 1n;\nconst maxInt216 = 2n ** (216n - 1n) - 1n;\nconst maxInt224 = 2n ** (224n - 1n) - 1n;\nconst maxInt232 = 2n ** (232n - 1n) - 1n;\nconst maxInt240 = 2n ** (240n - 1n) - 1n;\nconst maxInt248 = 2n ** (248n - 1n) - 1n;\nconst maxInt256 = 2n ** (256n - 1n) - 1n;\nconst minInt8 = -(2n ** (8n - 1n));\nconst minInt16 = -(2n ** (16n - 1n));\nconst minInt24 = -(2n ** (24n - 1n));\nconst minInt32 = -(2n ** (32n - 1n));\nconst minInt40 = -(2n ** (40n - 1n));\nconst minInt48 = -(2n ** (48n - 1n));\nconst minInt56 = -(2n ** (56n - 1n));\nconst minInt64 = -(2n ** (64n - 1n));\nconst minInt72 = -(2n ** (72n - 1n));\nconst minInt80 = -(2n ** (80n - 1n));\nconst minInt88 = -(2n ** (88n - 1n));\nconst minInt96 = -(2n ** (96n - 1n));\nconst minInt104 = -(2n ** (104n - 1n));\nconst minInt112 = -(2n ** (112n - 1n));\nconst minInt120 = -(2n ** (120n - 1n));\nconst minInt128 = -(2n ** (128n - 1n));\nconst minInt136 = -(2n ** (136n - 1n));\nconst minInt144 = -(2n ** (144n - 1n));\nconst minInt152 = -(2n ** (152n - 1n));\nconst minInt160 = -(2n ** (160n - 1n));\nconst minInt168 = -(2n ** (168n - 1n));\nconst minInt176 = -(2n ** (176n - 1n));\nconst minInt184 = -(2n ** (184n - 1n));\nconst minInt192 = -(2n ** (192n - 1n));\nconst minInt200 = -(2n ** (200n - 1n));\nconst minInt208 = -(2n ** (208n - 1n));\nconst minInt216 = -(2n ** (216n - 1n));\nconst minInt224 = -(2n ** (224n - 1n));\nconst minInt232 = -(2n ** (232n - 1n));\nconst minInt240 = -(2n ** (240n - 1n));\nconst minInt248 = -(2n ** (248n - 1n));\nconst minInt256 = -(2n ** (256n - 1n));\nconst maxUint8 = 2n ** 8n - 1n;\nconst maxUint16 = 2n ** 16n - 1n;\nconst maxUint24 = 2n ** 24n - 1n;\nconst maxUint32 = 2n ** 32n - 1n;\nconst maxUint40 = 2n ** 40n - 1n;\nconst maxUint48 = 2n ** 48n - 1n;\nconst maxUint56 = 2n ** 56n - 1n;\nconst maxUint64 = 2n ** 64n - 1n;\nconst maxUint72 = 2n ** 72n - 1n;\nconst maxUint80 = 2n ** 80n - 1n;\nconst maxUint88 = 2n ** 88n - 1n;\nconst maxUint96 = 2n ** 96n - 1n;\nconst maxUint104 = 2n ** 104n - 1n;\nconst maxUint112 = 2n ** 112n - 1n;\nconst maxUint120 = 2n ** 120n - 1n;\nconst maxUint128 = 2n ** 128n - 1n;\nconst maxUint136 = 2n ** 136n - 1n;\nconst maxUint144 = 2n ** 144n - 1n;\nconst maxUint152 = 2n ** 152n - 1n;\nconst maxUint160 = 2n ** 160n - 1n;\nconst maxUint168 = 2n ** 168n - 1n;\nconst maxUint176 = 2n ** 176n - 1n;\nconst maxUint184 = 2n ** 184n - 1n;\nconst maxUint192 = 2n ** 192n - 1n;\nconst maxUint200 = 2n ** 200n - 1n;\nconst maxUint208 = 2n ** 208n - 1n;\nconst maxUint216 = 2n ** 216n - 1n;\nconst maxUint224 = 2n ** 224n - 1n;\nconst maxUint232 = 2n ** 232n - 1n;\nconst maxUint240 = 2n ** 240n - 1n;\nconst maxUint248 = 2n ** 248n - 1n;\nconst maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=Solidity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NvbGlkaXR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU29saWRpdHkuanM/OTZkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgYXJyYXlSZWdleCA9IC9eKC4qKVxcWyhbMC05XSopXFxdJC87XG4vLyBgYnl0ZXM8TT5gOiBiaW5hcnkgdHlwZSBvZiBgTWAgYnl0ZXMsIGAwIDwgTSA8PSAzMmBcbi8vIGh0dHBzOi8vcmVnZXhyLmNvbS82dmE1NVxuZXhwb3J0IGNvbnN0IGJ5dGVzUmVnZXggPSAvXmJ5dGVzKFsxLTldfDFbMC05XXwyWzAtOV18M1swLTJdKT8kLztcbi8vIGAodSlpbnQ8TT5gOiAodW4pc2lnbmVkIGludGVnZXIgdHlwZSBvZiBgTWAgYml0cywgYDAgPCBNIDw9IDI1NmAsIGBNICUgOCA9PSAwYFxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2OGhwXG5leHBvcnQgY29uc3QgaW50ZWdlclJlZ2V4ID0gL14odT9pbnQpKDh8MTZ8MjR8MzJ8NDB8NDh8NTZ8NjR8NzJ8ODB8ODh8OTZ8MTA0fDExMnwxMjB8MTI4fDEzNnwxNDR8MTUyfDE2MHwxNjh8MTc2fDE4NHwxOTJ8MjAwfDIwOHwyMTZ8MjI0fDIzMnwyNDB8MjQ4fDI1Nik/JC87XG5leHBvcnQgY29uc3QgbWF4SW50OCA9IDJuICoqICg4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE2ID0gMm4gKiogKDE2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDI0ID0gMm4gKiogKDI0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDMyID0gMm4gKiogKDMybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDQwID0gMm4gKiogKDQwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDQ4ID0gMm4gKiogKDQ4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDU2ID0gMm4gKiogKDU2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDY0ID0gMm4gKiogKDY0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDcyID0gMm4gKiogKDcybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDgwID0gMm4gKiogKDgwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDg4ID0gMm4gKiogKDg4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDk2ID0gMm4gKiogKDk2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDEwNCA9IDJuICoqICgxMDRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTEyID0gMm4gKiogKDExMm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMjAgPSAybiAqKiAoMTIwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDEyOCA9IDJuICoqICgxMjhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTM2ID0gMm4gKiogKDEzNm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNDQgPSAybiAqKiAoMTQ0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE1MiA9IDJuICoqICgxNTJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTYwID0gMm4gKiogKDE2MG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNjggPSAybiAqKiAoMTY4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE3NiA9IDJuICoqICgxNzZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTg0ID0gMm4gKiogKDE4NG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxOTIgPSAybiAqKiAoMTkybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIwMCA9IDJuICoqICgyMDBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjA4ID0gMm4gKiogKDIwOG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMTYgPSAybiAqKiAoMjE2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIyNCA9IDJuICoqICgyMjRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjMyID0gMm4gKiogKDIzMm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyNDAgPSAybiAqKiAoMjQwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDI0OCA9IDJuICoqICgyNDhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjU2ID0gMm4gKiogKDI1Nm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtaW5JbnQ4ID0gLSgybiAqKiAoOG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDE2ID0gLSgybiAqKiAoMTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNCA9IC0oMm4gKiogKDI0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MzIgPSAtKDJuICoqICgzMm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDQwID0gLSgybiAqKiAoNDBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ0OCA9IC0oMm4gKiogKDQ4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NTYgPSAtKDJuICoqICg1Nm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDY0ID0gLSgybiAqKiAoNjRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ3MiA9IC0oMm4gKiogKDcybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50ODAgPSAtKDJuICoqICg4MG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDg4ID0gLSgybiAqKiAoODhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ5NiA9IC0oMm4gKiogKDk2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTA0ID0gLSgybiAqKiAoMTA0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTEyID0gLSgybiAqKiAoMTEybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTIwID0gLSgybiAqKiAoMTIwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTI4ID0gLSgybiAqKiAoMTI4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTM2ID0gLSgybiAqKiAoMTM2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTQ0ID0gLSgybiAqKiAoMTQ0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTUyID0gLSgybiAqKiAoMTUybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTYwID0gLSgybiAqKiAoMTYwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTY4ID0gLSgybiAqKiAoMTY4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTc2ID0gLSgybiAqKiAoMTc2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTg0ID0gLSgybiAqKiAoMTg0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTkyID0gLSgybiAqKiAoMTkybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjAwID0gLSgybiAqKiAoMjAwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjA4ID0gLSgybiAqKiAoMjA4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjE2ID0gLSgybiAqKiAoMjE2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjI0ID0gLSgybiAqKiAoMjI0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjMyID0gLSgybiAqKiAoMjMybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjQwID0gLSgybiAqKiAoMjQwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjQ4ID0gLSgybiAqKiAoMjQ4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjU2ID0gLSgybiAqKiAoMjU2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWF4VWludDggPSAybiAqKiA4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNiA9IDJuICoqIDE2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyNCA9IDJuICoqIDI0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQzMiA9IDJuICoqIDMybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ0MCA9IDJuICoqIDQwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ0OCA9IDJuICoqIDQ4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ1NiA9IDJuICoqIDU2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ2NCA9IDJuICoqIDY0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ3MiA9IDJuICoqIDcybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ4MCA9IDJuICoqIDgwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ4OCA9IDJuICoqIDg4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ5NiA9IDJuICoqIDk2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMDQgPSAybiAqKiAxMDRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDExMiA9IDJuICoqIDExMm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTIwID0gMm4gKiogMTIwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMjggPSAybiAqKiAxMjhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDEzNiA9IDJuICoqIDEzNm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTQ0ID0gMm4gKiogMTQ0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNTIgPSAybiAqKiAxNTJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE2MCA9IDJuICoqIDE2MG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTY4ID0gMm4gKiogMTY4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNzYgPSAybiAqKiAxNzZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE4NCA9IDJuICoqIDE4NG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTkyID0gMm4gKiogMTkybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMDAgPSAybiAqKiAyMDBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIwOCA9IDJuICoqIDIwOG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjE2ID0gMm4gKiogMjE2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMjQgPSAybiAqKiAyMjRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIzMiA9IDJuICoqIDIzMm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjQwID0gMm4gKiogMjQwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyNDggPSAybiAqKiAyNDhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDI1NiA9IDJuICoqIDI1Nm4gLSAxbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNvbGlkaXR5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Solidity.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Transaction.js":
/*!**************************************************!*\
  !*** ./node_modules/ox/_esm/core/Transaction.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcType: () => (/* binding */ fromRpcType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcType: () => (/* binding */ toRpcType)\n/* harmony export */ });\n/* harmony import */ var _Authorization_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Authorization.js */ \"(ssr)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n/** Type to RPC Type mapping. */\nconst toRpcType = {\n    legacy: '0x0',\n    eip2930: '0x1',\n    eip1559: '0x2',\n    eip4844: '0x3',\n    eip7702: '0x4',\n};\n/** RPC Type to Type mapping. */\nconst fromRpcType = {\n    '0x0': 'legacy',\n    '0x1': 'eip2930',\n    '0x2': 'eip1559',\n    '0x3': 'eip4844',\n    '0x4': 'eip7702',\n};\n/**\n * Converts an {@link ox#Transaction.Rpc} to an {@link ox#Transaction.Transaction}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x2',\n * })\n * ```\n *\n * @param transaction - The RPC transaction to convert.\n * @returns An instantiated {@link ox#Transaction.Transaction}.\n */\nfunction fromRpc(transaction, _options = {}) {\n    if (!transaction)\n        return null;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(transaction);\n    const transaction_ = {\n        ...transaction,\n        ...signature,\n    };\n    transaction_.blockNumber = transaction.blockNumber\n        ? BigInt(transaction.blockNumber)\n        : null;\n    transaction_.data = transaction.input;\n    transaction_.gas = BigInt(transaction.gas ?? 0n);\n    transaction_.nonce = BigInt(transaction.nonce ?? 0n);\n    transaction_.transactionIndex = transaction.transactionIndex\n        ? Number(transaction.transactionIndex)\n        : null;\n    transaction_.value = BigInt(transaction.value ?? 0n);\n    if (transaction.authorizationList)\n        transaction_.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_1__.fromRpcList(transaction.authorizationList);\n    if (transaction.chainId)\n        transaction_.chainId = Number(transaction.chainId);\n    if (transaction.gasPrice)\n        transaction_.gasPrice = BigInt(transaction.gasPrice);\n    if (transaction.maxFeePerBlobGas)\n        transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas);\n    if (transaction.maxFeePerGas)\n        transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas);\n    if (transaction.maxPriorityFeePerGas)\n        transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas);\n    if (transaction.type)\n        transaction_.type =\n            fromRpcType[transaction.type] ?? transaction.type;\n    if (signature)\n        transaction_.v = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.yParityToV(signature.yParity);\n    return transaction_;\n}\n/**\n * Converts an {@link ox#Transaction.Transaction} to an {@link ox#Transaction.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox'\n *\n * const transaction = Transaction.toRpc({\n *   accessList: [],\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   chainId: 1,\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gas: 278365n,\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   maxFeePerGas: 11985937556n,\n *   maxPriorityFeePerGas: 68993984n,\n *   nonce: 855n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *   transactionIndex: 2,\n *   type: 'eip1559',\n *   v: 27,\n *   value: 700000000000000000n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param transaction - The transaction to convert.\n * @returns An RPC-formatted transaction.\n */\nfunction toRpc(transaction, _options) {\n    const rpc = {};\n    rpc.blockHash = transaction.blockHash;\n    rpc.blockNumber =\n        typeof transaction.blockNumber === 'bigint'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.blockNumber)\n            : null;\n    rpc.from = transaction.from;\n    rpc.gas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.gas ?? 0n);\n    rpc.hash = transaction.hash;\n    rpc.input = transaction.input;\n    rpc.nonce = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.nonce ?? 0n);\n    rpc.to = transaction.to;\n    rpc.transactionIndex = transaction.transactionIndex\n        ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.transactionIndex)\n        : null;\n    rpc.type = toRpcType[transaction.type] ?? transaction.type;\n    rpc.value = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.value ?? 0n);\n    if (transaction.accessList)\n        rpc.accessList = transaction.accessList;\n    if (transaction.authorizationList)\n        rpc.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_1__.toRpcList(transaction.authorizationList);\n    if (transaction.blobVersionedHashes)\n        rpc.blobVersionedHashes = transaction.blobVersionedHashes;\n    if (transaction.chainId)\n        rpc.chainId = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.chainId);\n    if (typeof transaction.gasPrice === 'bigint')\n        rpc.gasPrice = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.gasPrice);\n    if (typeof transaction.maxFeePerBlobGas === 'bigint')\n        rpc.maxFeePerBlobGas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.maxFeePerBlobGas);\n    if (typeof transaction.maxFeePerGas === 'bigint')\n        rpc.maxFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.maxFeePerGas);\n    if (typeof transaction.maxPriorityFeePerGas === 'bigint')\n        rpc.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.maxPriorityFeePerGas);\n    if (typeof transaction.r === 'bigint')\n        rpc.r = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.r, { size: 32 });\n    if (typeof transaction.s === 'bigint')\n        rpc.s = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.s, { size: 32 });\n    if (typeof transaction.v === 'number')\n        rpc.v = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(transaction.v, { size: 1 });\n    if (typeof transaction.yParity === 'number')\n        rpc.yParity = transaction.yParity === 0 ? '0x0' : '0x1';\n    return rpc;\n}\n//# sourceMappingURL=Transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBb0Q7QUFDcEI7QUFDWTtBQUM1QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQixPQUFPLGlDQUFpQztBQUNsRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlDQUFpQztBQUM5RDtBQUNPLDJDQUEyQztBQUNsRDtBQUNBO0FBQ0Esc0JBQXNCLGtEQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQXlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0MsT0FBTyx5QkFBeUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUFjO0FBQzVCO0FBQ0E7QUFDQSxjQUFjLCtDQUFjO0FBQzVCO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQWM7QUFDOUI7QUFDQTtBQUNBLFVBQVUsK0NBQWM7QUFDeEI7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQ0FBYztBQUNwQztBQUNBLHVCQUF1QiwrQ0FBYztBQUNyQztBQUNBLCtCQUErQiwrQ0FBYztBQUM3QztBQUNBLDJCQUEyQiwrQ0FBYztBQUN6QztBQUNBLG1DQUFtQywrQ0FBYztBQUNqRDtBQUNBLGdCQUFnQiwrQ0FBYyxrQkFBa0IsVUFBVTtBQUMxRDtBQUNBLGdCQUFnQiwrQ0FBYyxrQkFBa0IsVUFBVTtBQUMxRDtBQUNBLGdCQUFnQiwrQ0FBYyxrQkFBa0IsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uLmpzPzljZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQXV0aG9yaXphdGlvbiBmcm9tICcuL0F1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuL1NpZ25hdHVyZS5qcyc7XG4vKiogVHlwZSB0byBSUEMgVHlwZSBtYXBwaW5nLiAqL1xuZXhwb3J0IGNvbnN0IHRvUnBjVHlwZSA9IHtcbiAgICBsZWdhY3k6ICcweDAnLFxuICAgIGVpcDI5MzA6ICcweDEnLFxuICAgIGVpcDE1NTk6ICcweDInLFxuICAgIGVpcDQ4NDQ6ICcweDMnLFxuICAgIGVpcDc3MDI6ICcweDQnLFxufTtcbi8qKiBSUEMgVHlwZSB0byBUeXBlIG1hcHBpbmcuICovXG5leHBvcnQgY29uc3QgZnJvbVJwY1R5cGUgPSB7XG4gICAgJzB4MCc6ICdsZWdhY3knLFxuICAgICcweDEnOiAnZWlwMjkzMCcsXG4gICAgJzB4Mic6ICdlaXAxNTU5JyxcbiAgICAnMHgzJzogJ2VpcDQ4NDQnLFxuICAgICcweDQnOiAnZWlwNzcwMicsXG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uUnBjfSB0byBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uVHJhbnNhY3Rpb259LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0cmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uLmZyb21ScGMoe1xuICogICBoYXNoOiAnMHgzNTNmZGZjMzhhMmYyNjExNWRhYWRlZTlmNWI4MzkyY2U2MmI4NGY0MTA5NTc5NjdlMmVkNTZiMzUzMzhjZGQwJyxcbiAqICAgbm9uY2U6ICcweDM1NycsXG4gKiAgIGJsb2NrSGFzaDpcbiAqICAgICAnMHhjMzUwZDgwNzUwNWZiODM1NjUwZjAwMTM2MzJjNTUxNTU5Mjk4N2JhMTY5YmJjNjYyNmQ5ZmM1NGQ5MWYwZjBiJyxcbiAqICAgYmxvY2tOdW1iZXI6ICcweDEyZjI5NmYnLFxuICogICB0cmFuc2FjdGlvbkluZGV4OiAnMHgyJyxcbiAqICAgZnJvbTogJzB4ODE0ZTVlMGUzMTAxNmI5YTdmMTM4Yzc2YjdlN2IyYmI1YzFhYjZhNicsXG4gKiAgIHRvOiAnMHgzZmM5MWEzYWZkNzAzOTVjZDQ5NmM2NDdkNWE2Y2M5ZDRiMmI3ZmFkJyxcbiAqICAgdmFsdWU6ICcweDliNmU2NGE4ZWM2MDAwMCcsXG4gKiAgIGdhczogJzB4NDNmNWQnLFxuICogICBtYXhGZWVQZXJHYXM6ICcweDJjYTZhZTQ5NCcsXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiAnMHg0MWNjM2MwJyxcbiAqICAgaW5wdXQ6XG4gKiAgICAgJzB4MzU5MzU2NGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjY0MzUwNDcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MGIwODA2MDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBlMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwOWI2ZTY0YThlYzYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwOWI2ZTY0YThlYzYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MTI0YmI1YWU5NzhjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGMwMmFhYTM5YjIyM2ZlOGQwYTBlNWM0ZjI3ZWFkOTA4M2M3NTZjYzIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjNTZjN2EwZWFhODA0Zjg1NGI1MzZhNWYzZDVmNDlkMmVjNGIxMmI4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmZWUxM2ExMDNhMTBkNTkzYjlhZTA2YjNlMDVmMmU3ZTFjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxOTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjNTZjN2EwZWFhODA0Zjg1NGI1MzZhNWYzZDVmNDlkMmVjNGIxMmI4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxOTAyNDAwMDFiOTg3MmInLFxuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgYWNjZXNzTGlzdDogW10sXG4gKiAgIHR5cGU6ICcweDInLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSBSUEMgdHJhbnNhY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIGluc3RhbnRpYXRlZCB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uVHJhbnNhY3Rpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyh0cmFuc2FjdGlvbiwgX29wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdHJhbnNhY3Rpb24pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KHRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl8gPSB7XG4gICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgfTtcbiAgICB0cmFuc2FjdGlvbl8uYmxvY2tOdW1iZXIgPSB0cmFuc2FjdGlvbi5ibG9ja051bWJlclxuICAgICAgICA/IEJpZ0ludCh0cmFuc2FjdGlvbi5ibG9ja051bWJlcilcbiAgICAgICAgOiBudWxsO1xuICAgIHRyYW5zYWN0aW9uXy5kYXRhID0gdHJhbnNhY3Rpb24uaW5wdXQ7XG4gICAgdHJhbnNhY3Rpb25fLmdhcyA9IEJpZ0ludCh0cmFuc2FjdGlvbi5nYXMgPz8gMG4pO1xuICAgIHRyYW5zYWN0aW9uXy5ub25jZSA9IEJpZ0ludCh0cmFuc2FjdGlvbi5ub25jZSA/PyAwbik7XG4gICAgdHJhbnNhY3Rpb25fLnRyYW5zYWN0aW9uSW5kZXggPSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkluZGV4XG4gICAgICAgID8gTnVtYmVyKHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uSW5kZXgpXG4gICAgICAgIDogbnVsbDtcbiAgICB0cmFuc2FjdGlvbl8udmFsdWUgPSBCaWdJbnQodHJhbnNhY3Rpb24udmFsdWUgPz8gMG4pO1xuICAgIGlmICh0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdClcbiAgICAgICAgdHJhbnNhY3Rpb25fLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi5mcm9tUnBjTGlzdCh0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdCk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQpXG4gICAgICAgIHRyYW5zYWN0aW9uXy5jaGFpbklkID0gTnVtYmVyKHRyYW5zYWN0aW9uLmNoYWluSWQpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5nYXNQcmljZSlcbiAgICAgICAgdHJhbnNhY3Rpb25fLmdhc1ByaWNlID0gQmlnSW50KHRyYW5zYWN0aW9uLmdhc1ByaWNlKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubWF4RmVlUGVyQmxvYkdhcylcbiAgICAgICAgdHJhbnNhY3Rpb25fLm1heEZlZVBlckJsb2JHYXMgPSBCaWdJbnQodHJhbnNhY3Rpb24ubWF4RmVlUGVyQmxvYkdhcyk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcylcbiAgICAgICAgdHJhbnNhY3Rpb25fLm1heEZlZVBlckdhcyA9IEJpZ0ludCh0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcylcbiAgICAgICAgdHJhbnNhY3Rpb25fLm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnSW50KHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAodHJhbnNhY3Rpb24udHlwZSlcbiAgICAgICAgdHJhbnNhY3Rpb25fLnR5cGUgPVxuICAgICAgICAgICAgZnJvbVJwY1R5cGVbdHJhbnNhY3Rpb24udHlwZV0gPz8gdHJhbnNhY3Rpb24udHlwZTtcbiAgICBpZiAoc2lnbmF0dXJlKVxuICAgICAgICB0cmFuc2FjdGlvbl8udiA9IFNpZ25hdHVyZS55UGFyaXR5VG9WKHNpZ25hdHVyZS55UGFyaXR5KTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25fO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uVHJhbnNhY3Rpb259IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbi5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0cmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uLnRvUnBjKHtcbiAqICAgYWNjZXNzTGlzdDogW10sXG4gKiAgIGJsb2NrSGFzaDpcbiAqICAgICAnMHhjMzUwZDgwNzUwNWZiODM1NjUwZjAwMTM2MzJjNTUxNTU5Mjk4N2JhMTY5YmJjNjYyNmQ5ZmM1NGQ5MWYwZjBiJyxcbiAqICAgYmxvY2tOdW1iZXI6IDE5ODY4MDE1bixcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZnJvbTogJzB4ODE0ZTVlMGUzMTAxNmI5YTdmMTM4Yzc2YjdlN2IyYmI1YzFhYjZhNicsXG4gKiAgIGdhczogMjc4MzY1bixcbiAqICAgaGFzaDogJzB4MzUzZmRmYzM4YTJmMjYxMTVkYWFkZWU5ZjViODM5MmNlNjJiODRmNDEwOTU3OTY3ZTJlZDU2YjM1MzM4Y2RkMCcsXG4gKiAgIGlucHV0OlxuICogICAgICcweDM1OTM1NjRjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDY2NDM1MDQ3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDBiMDgwNjA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDI4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDliNmU2NGE4ZWM2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDliNmU2NGE4ZWM2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxOTEyNGJiNWFlOTc4YzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjMDJhYWEzOWIyMjNmZThkMGEwZTVjNGYyN2VhZDkwODNjNzU2Y2MyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBjNTZjN2EwZWFhODA0Zjg1NGI1MzZhNWYzZDVmNDlkMmVjNGIxMmI4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmVlMTNhMTAzYTEwZDU5M2I5YWUwNmIzZTA1ZjJlN2UxYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkwMjQwMDAxYjk4NzJiJyxcbiAqICAgbWF4RmVlUGVyR2FzOiAxMTk4NTkzNzU1Nm4sXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiA2ODk5Mzk4NG4sXG4gKiAgIG5vbmNlOiA4NTVuLFxuICogICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgdG86ICcweDNmYzkxYTNhZmQ3MDM5NWNkNDk2YzY0N2Q1YTZjYzlkNGIyYjdmYWQnLFxuICogICB0cmFuc2FjdGlvbkluZGV4OiAyLFxuICogICB0eXBlOiAnZWlwMTU1OScsXG4gKiAgIHY6IDI3LFxuICogICB2YWx1ZTogNzAwMDAwMDAwMDAwMDAwMDAwbixcbiAqICAgeVBhcml0eTogMCxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyh0cmFuc2FjdGlvbiwgX29wdGlvbnMpIHtcbiAgICBjb25zdCBycGMgPSB7fTtcbiAgICBycGMuYmxvY2tIYXNoID0gdHJhbnNhY3Rpb24uYmxvY2tIYXNoO1xuICAgIHJwYy5ibG9ja051bWJlciA9XG4gICAgICAgIHR5cGVvZiB0cmFuc2FjdGlvbi5ibG9ja051bWJlciA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24uYmxvY2tOdW1iZXIpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgcnBjLmZyb20gPSB0cmFuc2FjdGlvbi5mcm9tO1xuICAgIHJwYy5nYXMgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi5nYXMgPz8gMG4pO1xuICAgIHJwYy5oYXNoID0gdHJhbnNhY3Rpb24uaGFzaDtcbiAgICBycGMuaW5wdXQgPSB0cmFuc2FjdGlvbi5pbnB1dDtcbiAgICBycGMubm9uY2UgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi5ub25jZSA/PyAwbik7XG4gICAgcnBjLnRvID0gdHJhbnNhY3Rpb24udG87XG4gICAgcnBjLnRyYW5zYWN0aW9uSW5kZXggPSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkluZGV4XG4gICAgICAgID8gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24udHJhbnNhY3Rpb25JbmRleClcbiAgICAgICAgOiBudWxsO1xuICAgIHJwYy50eXBlID0gdG9ScGNUeXBlW3RyYW5zYWN0aW9uLnR5cGVdID8/IHRyYW5zYWN0aW9uLnR5cGU7XG4gICAgcnBjLnZhbHVlID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24udmFsdWUgPz8gMG4pO1xuICAgIGlmICh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0KVxuICAgICAgICBycGMuYWNjZXNzTGlzdCA9IHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3Q7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmF1dGhvcml6YXRpb25MaXN0KVxuICAgICAgICBycGMuYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLnRvUnBjTGlzdCh0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdCk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmJsb2JWZXJzaW9uZWRIYXNoZXMpXG4gICAgICAgIHJwYy5ibG9iVmVyc2lvbmVkSGFzaGVzID0gdHJhbnNhY3Rpb24uYmxvYlZlcnNpb25lZEhhc2hlcztcbiAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZClcbiAgICAgICAgcnBjLmNoYWluSWQgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi5jaGFpbklkKTtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLmdhc1ByaWNlID09PSAnYmlnaW50JylcbiAgICAgICAgcnBjLmdhc1ByaWNlID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24uZ2FzUHJpY2UpO1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24ubWF4RmVlUGVyQmxvYkdhcyA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJwYy5tYXhGZWVQZXJCbG9iR2FzID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24ubWF4RmVlUGVyQmxvYkdhcyk7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMgPT09ICdiaWdpbnQnKVxuICAgICAgICBycGMubWF4RmVlUGVyR2FzID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzKTtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzID09PSAnYmlnaW50JylcbiAgICAgICAgcnBjLm1heFByaW9yaXR5RmVlUGVyR2FzID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24uciA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJwYy5yID0gSGV4LmZyb21OdW1iZXIodHJhbnNhY3Rpb24uciwgeyBzaXplOiAzMiB9KTtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLnMgPT09ICdiaWdpbnQnKVxuICAgICAgICBycGMucyA9IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLnMsIHsgc2l6ZTogMzIgfSk7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi52ID09PSAnbnVtYmVyJylcbiAgICAgICAgcnBjLnYgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi52LCB7IHNpemU6IDEgfSk7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi55UGFyaXR5ID09PSAnbnVtYmVyJylcbiAgICAgICAgcnBjLnlQYXJpdHkgPSB0cmFuc2FjdGlvbi55UGFyaXR5ID09PSAwID8gJzB4MCcgOiAnMHgxJztcbiAgICByZXR1cm4gcnBjO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/TransactionRequest.js":
/*!*********************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionRequest.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Authorization_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Authorization.js */ \"(ssr)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Transaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transaction.js */ \"(ssr)/./node_modules/ox/_esm/core/Transaction.js\");\n\n\n\n/**\n * Converts a {@link ox#TransactionRequest.Rpc} to a {@link ox#TransactionRequest.TransactionRequest}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionRequest } from 'ox'\n *\n * const request = TransactionRequest.fromRpc({\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: '0x2386f26fc10000',\n * })\n * ```\n *\n * @param request - The RPC request to convert.\n * @returns A transaction request.\n */\nfunction fromRpc(request) {\n    const request_ = request;\n    if (typeof request.authorizationList !== 'undefined')\n        request_.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_0__.fromRpcList(request.authorizationList);\n    if (typeof request.chainId !== 'undefined')\n        request_.chainId = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(request.chainId);\n    if (typeof request.gas !== 'undefined')\n        request_.gas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.gas);\n    if (typeof request.gasPrice !== 'undefined')\n        request_.gasPrice = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.gasPrice);\n    if (typeof request.maxFeePerBlobGas !== 'undefined')\n        request_.maxFeePerBlobGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.maxFeePerBlobGas);\n    if (typeof request.maxFeePerGas !== 'undefined')\n        request_.maxFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.maxFeePerGas);\n    if (typeof request.maxPriorityFeePerGas !== 'undefined')\n        request_.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.maxPriorityFeePerGas);\n    if (typeof request.nonce !== 'undefined')\n        request_.nonce = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.nonce);\n    if (typeof request.type !== 'undefined')\n        request_.type =\n            _Transaction_js__WEBPACK_IMPORTED_MODULE_2__.fromRpcType[request.type] || request.type;\n    if (typeof request.value !== 'undefined')\n        request_.value = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(request.value);\n    return request_;\n}\n/**\n * Converts a {@link ox#TransactionRequest.TransactionRequest} to a {@link ox#TransactionRequest.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionRequest, Value } from 'ox'\n *\n * const request = TransactionRequest.toRpc({\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('0.01'),\n * })\n * ```\n *\n * @example\n * ### Using with a Provider\n *\n * You can use {@link ox#Provider.(from:function)} to instantiate an EIP-1193 Provider and\n * send a transaction to the Wallet using the `eth_sendTransaction` method.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, TransactionRequest, Value } from 'ox'\n *\n * const provider = Provider.from(window.ethereum!)\n *\n * const request = TransactionRequest.toRpc({\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('0.01'),\n * })\n *\n * const hash = await provider.request({ // [!code focus]\n *   method: 'eth_sendTransaction', // [!code focus]\n *   params: [request], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param request - The request to convert.\n * @returns An RPC request.\n */\nfunction toRpc(request) {\n    const request_rpc = {};\n    if (typeof request.accessList !== 'undefined')\n        request_rpc.accessList = request.accessList;\n    if (typeof request.authorizationList !== 'undefined')\n        request_rpc.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_0__.toRpcList(request.authorizationList);\n    if (typeof request.blobVersionedHashes !== 'undefined')\n        request_rpc.blobVersionedHashes = request.blobVersionedHashes;\n    if (typeof request.blobs !== 'undefined')\n        request_rpc.blobs = request.blobs;\n    if (typeof request.chainId !== 'undefined')\n        request_rpc.chainId = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.chainId);\n    if (typeof request.data !== 'undefined') {\n        request_rpc.data = request.data;\n        request_rpc.input = request.data;\n    }\n    else if (typeof request.input !== 'undefined') {\n        request_rpc.data = request.input;\n        request_rpc.input = request.input;\n    }\n    if (typeof request.from !== 'undefined')\n        request_rpc.from = request.from;\n    if (typeof request.gas !== 'undefined')\n        request_rpc.gas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.gas);\n    if (typeof request.gasPrice !== 'undefined')\n        request_rpc.gasPrice = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.gasPrice);\n    if (typeof request.maxFeePerBlobGas !== 'undefined')\n        request_rpc.maxFeePerBlobGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxFeePerBlobGas);\n    if (typeof request.maxFeePerGas !== 'undefined')\n        request_rpc.maxFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxFeePerGas);\n    if (typeof request.maxPriorityFeePerGas !== 'undefined')\n        request_rpc.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxPriorityFeePerGas);\n    if (typeof request.maxPriorityFeePerGas !== 'undefined')\n        request_rpc.maxPriorityFeePerGas = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.maxPriorityFeePerGas);\n    if (typeof request.nonce !== 'undefined')\n        request_rpc.nonce = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.nonce);\n    if (typeof request.to !== 'undefined')\n        request_rpc.to = request.to;\n    if (typeof request.type !== 'undefined')\n        request_rpc.type =\n            _Transaction_js__WEBPACK_IMPORTED_MODULE_2__.toRpcType[request.type] || request.type;\n    if (typeof request.value !== 'undefined')\n        request_rpc.value = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(request.value);\n    return request_rpc;\n}\n//# sourceMappingURL=TransactionRequest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uUmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFvRDtBQUNwQjtBQUNnQjtBQUNoRDtBQUNBLGVBQWUsaUNBQWlDLE1BQU0sK0NBQStDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxxQ0FBcUMsMERBQXlCO0FBQzlEO0FBQ0EsMkJBQTJCLDZDQUFZO0FBQ3ZDO0FBQ0EsdUJBQXVCLDZDQUFZO0FBQ25DO0FBQ0EsNEJBQTRCLDZDQUFZO0FBQ3hDO0FBQ0Esb0NBQW9DLDZDQUFZO0FBQ2hEO0FBQ0EsZ0NBQWdDLDZDQUFZO0FBQzVDO0FBQ0Esd0NBQXdDLDZDQUFZO0FBQ3BEO0FBQ0EseUJBQXlCLDZDQUFZO0FBQ3JDO0FBQ0E7QUFDQSxZQUFZLHdEQUF1QjtBQUNuQztBQUNBLHlCQUF5Qiw2Q0FBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxlQUFlLGdEQUFnRCxNQUFNLGdDQUFnQztBQUNyRztBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdEQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQWM7QUFDeEM7QUFDQSwrQkFBK0IsK0NBQWM7QUFDN0M7QUFDQSx1Q0FBdUMsK0NBQWM7QUFDckQ7QUFDQSxtQ0FBbUMsK0NBQWM7QUFDakQ7QUFDQSwyQ0FBMkMsK0NBQWM7QUFDekQ7QUFDQSwyQ0FBMkMsK0NBQWM7QUFDekQ7QUFDQSw0QkFBNEIsK0NBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFxQjtBQUNqQztBQUNBLDRCQUE0QiwrQ0FBYztBQUMxQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25SZXF1ZXN0LmpzPzc1ZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQXV0aG9yaXphdGlvbiBmcm9tICcuL0F1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFRyYW5zYWN0aW9uIGZyb20gJy4vVHJhbnNhY3Rpb24uanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvblJlcXVlc3QuUnBjfSB0byBhIHtAbGluayBveCNUcmFuc2FjdGlvblJlcXVlc3QuVHJhbnNhY3Rpb25SZXF1ZXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uUmVxdWVzdCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHJlcXVlc3QgPSBUcmFuc2FjdGlvblJlcXVlc3QuZnJvbVJwYyh7XG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6ICcweDIzODZmMjZmYzEwMDAwJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBSUEMgcmVxdWVzdCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSB0cmFuc2FjdGlvbiByZXF1ZXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhyZXF1ZXN0KSB7XG4gICAgY29uc3QgcmVxdWVzdF8gPSByZXF1ZXN0O1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5hdXRob3JpemF0aW9uTGlzdCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi5mcm9tUnBjTGlzdChyZXF1ZXN0LmF1dGhvcml6YXRpb25MaXN0KTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuY2hhaW5JZCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfLmNoYWluSWQgPSBIZXgudG9OdW1iZXIocmVxdWVzdC5jaGFpbklkKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuZ2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF8uZ2FzID0gSGV4LnRvQmlnSW50KHJlcXVlc3QuZ2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuZ2FzUHJpY2UgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0Xy5nYXNQcmljZSA9IEhleC50b0JpZ0ludChyZXF1ZXN0Lmdhc1ByaWNlKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QubWF4RmVlUGVyQmxvYkdhcyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfLm1heEZlZVBlckJsb2JHYXMgPSBIZXgudG9CaWdJbnQocmVxdWVzdC5tYXhGZWVQZXJCbG9iR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QubWF4RmVlUGVyR2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF8ubWF4RmVlUGVyR2FzID0gSGV4LnRvQmlnSW50KHJlcXVlc3QubWF4RmVlUGVyR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0Xy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEhleC50b0JpZ0ludChyZXF1ZXN0Lm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3Qubm9uY2UgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0Xy5ub25jZSA9IEhleC50b0JpZ0ludChyZXF1ZXN0Lm5vbmNlKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QudHlwZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfLnR5cGUgPVxuICAgICAgICAgICAgVHJhbnNhY3Rpb24uZnJvbVJwY1R5cGVbcmVxdWVzdC50eXBlXSB8fCByZXF1ZXN0LnR5cGU7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LnZhbHVlICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF8udmFsdWUgPSBIZXgudG9CaWdJbnQocmVxdWVzdC52YWx1ZSk7XG4gICAgcmV0dXJuIHJlcXVlc3RfO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvblJlcXVlc3QuVHJhbnNhY3Rpb25SZXF1ZXN0fSB0byBhIHtAbGluayBveCNUcmFuc2FjdGlvblJlcXVlc3QuUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uUmVxdWVzdCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCByZXF1ZXN0ID0gVHJhbnNhY3Rpb25SZXF1ZXN0LnRvUnBjKHtcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcwLjAxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBVc2luZyB3aXRoIGEgUHJvdmlkZXJcbiAqXG4gKiBZb3UgY2FuIHVzZSB7QGxpbmsgb3gjUHJvdmlkZXIuKGZyb206ZnVuY3Rpb24pfSB0byBpbnN0YW50aWF0ZSBhbiBFSVAtMTE5MyBQcm92aWRlciBhbmRcbiAqIHNlbmQgYSB0cmFuc2FjdGlvbiB0byB0aGUgV2FsbGV0IHVzaW5nIHRoZSBgZXRoX3NlbmRUcmFuc2FjdGlvbmAgbWV0aG9kLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgJ294L3dpbmRvdydcbiAqIGltcG9ydCB7IFByb3ZpZGVyLCBUcmFuc2FjdGlvblJlcXVlc3QsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJvdmlkZXIgPSBQcm92aWRlci5mcm9tKHdpbmRvdy5ldGhlcmV1bSEpXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFRyYW5zYWN0aW9uUmVxdWVzdC50b1JwYyh7XG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMC4wMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgbWV0aG9kOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGFyYW1zOiBbcmVxdWVzdF0sIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3QgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQyByZXF1ZXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlcXVlc3RfcnBjID0ge307XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmFjY2Vzc0xpc3QgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5hY2Nlc3NMaXN0ID0gcmVxdWVzdC5hY2Nlc3NMaXN0O1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5hdXRob3JpemF0aW9uTGlzdCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi50b1JwY0xpc3QocmVxdWVzdC5hdXRob3JpemF0aW9uTGlzdCk7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmJsb2JWZXJzaW9uZWRIYXNoZXMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5ibG9iVmVyc2lvbmVkSGFzaGVzID0gcmVxdWVzdC5ibG9iVmVyc2lvbmVkSGFzaGVzO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5ibG9icyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmJsb2JzID0gcmVxdWVzdC5ibG9icztcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuY2hhaW5JZCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmNoYWluSWQgPSBIZXguZnJvbU51bWJlcihyZXF1ZXN0LmNoYWluSWQpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5kYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXF1ZXN0X3JwYy5kYXRhID0gcmVxdWVzdC5kYXRhO1xuICAgICAgICByZXF1ZXN0X3JwYy5pbnB1dCA9IHJlcXVlc3QuZGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QuaW5wdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJlcXVlc3RfcnBjLmRhdGEgPSByZXF1ZXN0LmlucHV0O1xuICAgICAgICByZXF1ZXN0X3JwYy5pbnB1dCA9IHJlcXVlc3QuaW5wdXQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5mcm9tICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMuZnJvbSA9IHJlcXVlc3QuZnJvbTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuZ2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMuZ2FzID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5nYXMpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5nYXNQcmljZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLmdhc1ByaWNlID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5nYXNQcmljZSk7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0Lm1heEZlZVBlckJsb2JHYXMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5tYXhGZWVQZXJCbG9iR2FzID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5tYXhGZWVQZXJCbG9iR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QubWF4RmVlUGVyR2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMubWF4RmVlUGVyR2FzID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5tYXhGZWVQZXJHYXMpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLm1heFByaW9yaXR5RmVlUGVyR2FzID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBIZXguZnJvbU51bWJlcihyZXF1ZXN0Lm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3Qubm9uY2UgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy5ub25jZSA9IEhleC5mcm9tTnVtYmVyKHJlcXVlc3Qubm9uY2UpO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC50byAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLnRvID0gcmVxdWVzdC50bztcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QudHlwZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLnR5cGUgPVxuICAgICAgICAgICAgVHJhbnNhY3Rpb24udG9ScGNUeXBlW3JlcXVlc3QudHlwZV0gfHwgcmVxdWVzdC50eXBlO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLnZhbHVlID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC52YWx1ZSk7XG4gICAgcmV0dXJuIHJlcXVlc3RfcnBjO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25SZXF1ZXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/TransactionRequest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/TxEnvelope.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/TxEnvelope.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeeCapTooHighError: () => (/* binding */ FeeCapTooHighError),\n/* harmony export */   GasPriceTooHighError: () => (/* binding */ GasPriceTooHighError),\n/* harmony export */   InvalidChainIdError: () => (/* binding */ InvalidChainIdError),\n/* harmony export */   InvalidSerializedError: () => (/* binding */ InvalidSerializedError),\n/* harmony export */   TipAboveFeeCapError: () => (/* binding */ TipAboveFeeCapError)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Value.js */ \"(ssr)/./node_modules/ox/_esm/core/Value.js\");\n\n\n/**\n * Thrown when a fee cap is too high.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.FeeCapTooHighError: The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nclass FeeCapTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ feeCap, } = {}) {\n        super(`The fee cap (\\`maxFeePerGas\\`/\\`maxPriorityFeePerGas\\`${feeCap ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(feeCap)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.FeeCapTooHighError'\n        });\n    }\n}\n/**\n * Thrown when a gas price is too high.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeLegacy } from 'ox'\n *\n * TxEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.GasPriceTooHighError: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nclass GasPriceTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ gasPrice, } = {}) {\n        super(`The gas price (\\`gasPrice\\`${gasPrice ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(gasPrice)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.GasPriceTooHighError'\n        });\n    }\n}\n/**\n * Thrown when a chain ID is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({ chainId: 0 })\n * // @error: TransactionEnvelope.InvalidChainIdError: Chain ID \"0\" is invalid.\n * ```\n */\nclass InvalidChainIdError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ chainId }) {\n        super(typeof chainId !== 'undefined'\n            ? `Chain ID \"${chainId}\" is invalid.`\n            : 'Chain ID is invalid.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.InvalidChainIdError'\n        });\n    }\n}\n/**\n * Thrown when a serialized transaction is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.deserialize('0x02c0')\n * // @error: TransactionEnvelope.InvalidSerializedError: Invalid serialized transaction of type \"eip1559\" was provided.\n * // @error: Serialized Transaction: \"0x02c0\"\n * // @error: Missing Attributes: chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList\n * ```\n */\nclass InvalidSerializedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ attributes, serialized, type, }) {\n        const missing = Object.entries(attributes)\n            .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n            .filter(Boolean);\n        super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n            metaMessages: [\n                `Serialized Transaction: \"${serialized}\"`,\n                missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n            ].filter(Boolean),\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.InvalidSerializedError'\n        });\n    }\n}\n/**\n * Thrown when a tip is higher than a fee cap.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeEip1559 } from 'ox'\n *\n * TxEnvelopeEip1559.assert({\n *   chainId: 1,\n *   maxFeePerGas: 10n,\n *   maxPriorityFeePerGas: 11n,\n * })\n * // @error: TransactionEnvelope.TipAboveFeeCapError: The provided tip (`maxPriorityFeePerGas` = 11 gwei) cannot be higher than the fee cap (`maxFeePerGas` = 10 gwei).\n * ```\n */\nclass TipAboveFeeCapError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ maxPriorityFeePerGas, maxFeePerGas, } = {}) {\n        super([\n            `The provided tip (\\`maxPriorityFeePerGas\\`${maxPriorityFeePerGas\n                ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxPriorityFeePerGas)} gwei`\n                : ''}) cannot be higher than the fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxFeePerGas)} gwei` : ''}).`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.TipAboveFeeCapError'\n        });\n    }\n}\n//# sourceMappingURL=TxEnvelope.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1R4RW52ZWxvcGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzQztBQUNGO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUMsaURBQWdCO0FBQ3hELGtCQUFrQixVQUFVLElBQUk7QUFDaEMsdUVBQXVFLGVBQWUsaURBQWdCLFVBQVUsV0FBVztBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ08sbUNBQW1DLGlEQUFnQjtBQUMxRCxrQkFBa0IsWUFBWSxJQUFJO0FBQ2xDLDRDQUE0QyxpQkFBaUIsaURBQWdCLFlBQVksV0FBVztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsaURBQWdCO0FBQ3pELGtCQUFrQixTQUFTO0FBQzNCO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUMsaURBQWdCO0FBQzVELGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EseURBQXlELEtBQUs7QUFDOUQ7QUFDQSw0Q0FBNEMsV0FBVztBQUN2RCw0REFBNEQsbUJBQW1CO0FBQy9FO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxpREFBZ0I7QUFDekQsa0JBQWtCLHNDQUFzQyxJQUFJO0FBQzVEO0FBQ0EseURBQXlEO0FBQ3pELHdCQUF3QixpREFBZ0Isd0JBQXdCO0FBQ2hFLHFCQUFxQix1REFBdUQscUJBQXFCLGlEQUFnQixnQkFBZ0IsV0FBVztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1R4RW52ZWxvcGUuanM/Y2QxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgVmFsdWUgZnJvbSAnLi9WYWx1ZS5qcyc7XG4vKipcbiAqIFRocm93biB3aGVuIGEgZmVlIGNhcCBpcyB0b28gaGlnaC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogVHhFbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KHtcbiAqICAgbWF4RmVlUGVyR2FzOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuRmVlQ2FwVG9vSGlnaEVycm9yOiBUaGUgZmVlIGNhcCAoYG1heEZlZVBlckdhc2AvYG1heFByaW9yaXR5RmVlUGVyR2FzYCA9IDExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMy4xMjk2Mzk5MzYgZ3dlaSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBGZWVDYXBUb29IaWdoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGZlZUNhcCwgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGBUaGUgZmVlIGNhcCAoXFxgbWF4RmVlUGVyR2FzXFxgL1xcYG1heFByaW9yaXR5RmVlUGVyR2FzXFxgJHtmZWVDYXAgPyBgID0gJHtWYWx1ZS5mb3JtYXRHd2VpKGZlZUNhcCl9IGd3ZWlgIDogJyd9KSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLkZlZUNhcFRvb0hpZ2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGdhcyBwcmljZSBpcyB0b28gaGlnaC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVMZWdhY3kgfSBmcm9tICdveCdcbiAqXG4gKiBUeEVudmVsb3BlTGVnYWN5LmFzc2VydCh7XG4gKiAgIGdhc1ByaWNlOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuR2FzUHJpY2VUb29IaWdoRXJyb3I6IFRoZSBnYXMgcHJpY2UgKGBnYXNQcmljZWAgPSAxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMuMTI5NjM5OTM2IGd3ZWkpIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgR2FzUHJpY2VUb29IaWdoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdhc1ByaWNlLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoYFRoZSBnYXMgcHJpY2UgKFxcYGdhc1ByaWNlXFxgJHtnYXNQcmljZSA/IGAgPSAke1ZhbHVlLmZvcm1hdEd3ZWkoZ2FzUHJpY2UpfSBnd2VpYCA6ICcnfSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHJhbnNhY3Rpb25FbnZlbG9wZS5HYXNQcmljZVRvb0hpZ2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGNoYWluIElEIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIFR4RW52ZWxvcGVFaXAxNTU5LmFzc2VydCh7IGNoYWluSWQ6IDAgfSlcbiAqIC8vIEBlcnJvcjogVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkQ2hhaW5JZEVycm9yOiBDaGFpbiBJRCBcIjBcIiBpcyBpbnZhbGlkLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQ2hhaW5JZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjaGFpbklkIH0pIHtcbiAgICAgICAgc3VwZXIodHlwZW9mIGNoYWluSWQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IGBDaGFpbiBJRCBcIiR7Y2hhaW5JZH1cIiBpcyBpbnZhbGlkLmBcbiAgICAgICAgICAgIDogJ0NoYWluIElEIGlzIGludmFsaWQuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRDaGFpbklkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGlzIGludmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIFR4RW52ZWxvcGVFaXAxNTU5LmRlc2VyaWFsaXplKCcweDAyYzAnKVxuICogLy8gQGVycm9yOiBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRTZXJpYWxpemVkRXJyb3I6IEludmFsaWQgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvZiB0eXBlIFwiZWlwMTU1OVwiIHdhcyBwcm92aWRlZC5cbiAqIC8vIEBlcnJvcjogU2VyaWFsaXplZCBUcmFuc2FjdGlvbjogXCIweDAyYzBcIlxuICogLy8gQGVycm9yOiBNaXNzaW5nIEF0dHJpYnV0ZXM6IGNoYWluSWQsIG5vbmNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCBnYXMsIHRvLCB2YWx1ZSwgZGF0YSwgYWNjZXNzTGlzdFxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU2VyaWFsaXplZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhdHRyaWJ1dGVzLCBzZXJpYWxpemVkLCB0eXBlLCB9KSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKVxuICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGtleSA6IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBzdXBlcihgSW52YWxpZCBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9mIHR5cGUgXCIke3R5cGV9XCIgd2FzIHByb3ZpZGVkLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBTZXJpYWxpemVkIFRyYW5zYWN0aW9uOiBcIiR7c2VyaWFsaXplZH1cImAsXG4gICAgICAgICAgICAgICAgbWlzc2luZy5sZW5ndGggPiAwID8gYE1pc3NpbmcgQXR0cmlidXRlczogJHttaXNzaW5nLmpvaW4oJywgJyl9YCA6ICcnLFxuICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbiksXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgdGlwIGlzIGhpZ2hlciB0aGFuIGEgZmVlIGNhcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogVHhFbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiAxMG4sXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiAxMW4sXG4gKiB9KVxuICogLy8gQGVycm9yOiBUcmFuc2FjdGlvbkVudmVsb3BlLlRpcEFib3ZlRmVlQ2FwRXJyb3I6IFRoZSBwcm92aWRlZCB0aXAgKGBtYXhQcmlvcml0eUZlZVBlckdhc2AgPSAxMSBnd2VpKSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIGZlZSBjYXAgKGBtYXhGZWVQZXJHYXNgID0gMTAgZ3dlaSkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFRpcEFib3ZlRmVlQ2FwRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihbXG4gICAgICAgICAgICBgVGhlIHByb3ZpZGVkIHRpcCAoXFxgbWF4UHJpb3JpdHlGZWVQZXJHYXNcXGAke21heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgICAgICAgICAgPyBgID0gJHtWYWx1ZS5mb3JtYXRHd2VpKG1heFByaW9yaXR5RmVlUGVyR2FzKX0gZ3dlaWBcbiAgICAgICAgICAgICAgICA6ICcnfSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBmZWUgY2FwIChcXGBtYXhGZWVQZXJHYXNcXGAke21heEZlZVBlckdhcyA/IGAgPSAke1ZhbHVlLmZvcm1hdEd3ZWkobWF4RmVlUGVyR2FzKX0gZ3dlaWAgOiAnJ30pLmAsXG4gICAgICAgIF0uam9pbignXFxuJykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHJhbnNhY3Rpb25FbnZlbG9wZS5UaXBBYm92ZUZlZUNhcEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UeEVudmVsb3BlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/TxEnvelope.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Value.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Value.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidDecimalNumberError: () => (/* binding */ InvalidDecimalNumberError),\n/* harmony export */   exponents: () => (/* binding */ exponents),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatGwei: () => (/* binding */ formatGwei),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromEther: () => (/* binding */ fromEther),\n/* harmony export */   fromGwei: () => (/* binding */ fromGwei)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n\n/** @see https://ethereum.github.io/yellowpaper/paper.pdf */\nconst exponents = {\n    wei: 0,\n    gwei: 9,\n    szabo: 12,\n    finney: 15,\n    ether: 18,\n};\n/**\n * Formats a `bigint` Value to its string representation (divided by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.format(420_000_000_000n, 9)\n * // @log: '420'\n * ```\n *\n * @param value - The `bigint` Value to format.\n * @param decimals - The exponent to divide the `bigint` Value by.\n * @returns The string representation of the Value.\n */\nfunction format(value, decimals = 0) {\n    let display = value.toString();\n    const negative = display.startsWith('-');\n    if (negative)\n        display = display.slice(1);\n    display = display.padStart(decimals, '0');\n    let [integer, fraction] = [\n        display.slice(0, display.length - decimals),\n        display.slice(display.length - decimals),\n    ];\n    fraction = fraction.replace(/(0+)$/, '');\n    return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Ether.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatEther(1_000_000_000_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Ether string representation of the Value.\n */\nfunction formatEther(wei, unit = 'wei') {\n    return format(wei, exponents.ether - exponents[unit]);\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Gwei.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatGwei(1_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Gwei string representation of the Value.\n */\nfunction formatGwei(wei, unit = 'wei') {\n    return format(wei, exponents.gwei - exponents[unit]);\n}\n/**\n * Parses a `string` representation of a Value to `bigint` (multiplied by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.from('420', 9)\n * // @log: 420000000000n\n * ```\n *\n * @param value - The string representation of the Value.\n * @param decimals - The exponent to multiply the Value by.\n * @returns The `bigint` representation of the Value.\n */\nfunction from(value, decimals = 0) {\n    if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value))\n        throw new InvalidDecimalNumberError({ value });\n    let [integer = '', fraction = '0'] = value.split('.');\n    const negative = integer.startsWith('-');\n    if (negative)\n        integer = integer.slice(1);\n    // trim trailing zeros.\n    fraction = fraction.replace(/(0+)$/, '');\n    // round off if the fraction is larger than the number of decimals.\n    if (decimals === 0) {\n        if (Math.round(Number(`.${fraction}`)) === 1)\n            integer = `${BigInt(integer) + 1n}`;\n        fraction = '';\n    }\n    else if (fraction.length > decimals) {\n        const [left, unit, right] = [\n            fraction.slice(0, decimals - 1),\n            fraction.slice(decimals - 1, decimals),\n            fraction.slice(decimals),\n        ];\n        const rounded = Math.round(Number(`${unit}.${right}`));\n        if (rounded > 9)\n            fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0');\n        else\n            fraction = `${left}${rounded}`;\n        if (fraction.length > decimals) {\n            fraction = fraction.slice(1);\n            integer = `${BigInt(integer) + 1n}`;\n        }\n        fraction = fraction.slice(0, decimals);\n    }\n    else {\n        fraction = fraction.padEnd(decimals, '0');\n    }\n    return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);\n}\n/**\n * Parses a string representation of Ether to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('420')\n * // @log: 420000000000000000000n\n * ```\n *\n * @param ether - String representation of Ether.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nfunction fromEther(ether, unit = 'wei') {\n    return from(ether, exponents.ether - exponents[unit]);\n}\n/**\n * Parses a string representation of Gwei to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromGwei('420')\n * // @log: 420000000000n\n * ```\n *\n * @param gwei - String representation of Gwei.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nfunction fromGwei(gwei, unit = 'wei') {\n    return from(gwei, exponents.gwei - exponents[unit]);\n}\n/**\n * Thrown when a value is not a valid decimal number.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('123.456.789')\n * // @error: Value.InvalidDecimalNumberError: Value `123.456.789` is not a valid decimal number.\n * ```\n */\nclass InvalidDecimalNumberError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is not a valid decimal number.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Value.InvalidDecimalNumberError'\n        });\n    }\n}\n//# sourceMappingURL=Value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1ZhbHVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFzQztBQUN0QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0IsRUFBRSxlQUFlLEVBQUUsZUFBZSxTQUFTLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLLEdBQUcsTUFBTTtBQUMzRDtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQSwwQkFBMEIsS0FBSyxFQUFFLFFBQVE7QUFDekM7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQixFQUFFLFFBQVEsRUFBRSxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHdDQUF3QyxpREFBZ0I7QUFDL0Qsa0JBQWtCLE9BQU87QUFDekIseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVmFsdWUuanM/NGZiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuLyoqIEBzZWUgaHR0cHM6Ly9ldGhlcmV1bS5naXRodWIuaW8veWVsbG93cGFwZXIvcGFwZXIucGRmICovXG5leHBvcnQgY29uc3QgZXhwb25lbnRzID0ge1xuICAgIHdlaTogMCxcbiAgICBnd2VpOiA5LFxuICAgIHN6YWJvOiAxMixcbiAgICBmaW5uZXk6IDE1LFxuICAgIGV0aGVyOiAxOCxcbn07XG4vKipcbiAqIEZvcm1hdHMgYSBgYmlnaW50YCBWYWx1ZSB0byBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIChkaXZpZGVkIGJ5IHRoZSBnaXZlbiBleHBvbmVudCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZvcm1hdCg0MjBfMDAwXzAwMF8wMDBuLCA5KVxuICogLy8gQGxvZzogJzQyMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCBWYWx1ZSB0byBmb3JtYXQuXG4gKiBAcGFyYW0gZGVjaW1hbHMgLSBUaGUgZXhwb25lbnQgdG8gZGl2aWRlIHRoZSBgYmlnaW50YCBWYWx1ZSBieS5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCBkZWNpbWFscyA9IDApIHtcbiAgICBsZXQgZGlzcGxheSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgbmVnYXRpdmUgPSBkaXNwbGF5LnN0YXJ0c1dpdGgoJy0nKTtcbiAgICBpZiAobmVnYXRpdmUpXG4gICAgICAgIGRpc3BsYXkgPSBkaXNwbGF5LnNsaWNlKDEpO1xuICAgIGRpc3BsYXkgPSBkaXNwbGF5LnBhZFN0YXJ0KGRlY2ltYWxzLCAnMCcpO1xuICAgIGxldCBbaW50ZWdlciwgZnJhY3Rpb25dID0gW1xuICAgICAgICBkaXNwbGF5LnNsaWNlKDAsIGRpc3BsYXkubGVuZ3RoIC0gZGVjaW1hbHMpLFxuICAgICAgICBkaXNwbGF5LnNsaWNlKGRpc3BsYXkubGVuZ3RoIC0gZGVjaW1hbHMpLFxuICAgIF07XG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5yZXBsYWNlKC8oMCspJC8sICcnKTtcbiAgICByZXR1cm4gYCR7bmVnYXRpdmUgPyAnLScgOiAnJ30ke2ludGVnZXIgfHwgJzAnfSR7ZnJhY3Rpb24gPyBgLiR7ZnJhY3Rpb259YCA6ICcnfWA7XG59XG4vKipcbiAqIEZvcm1hdHMgYSBgYmlnaW50YCBWYWx1ZSAoZGVmYXVsdDogd2VpKSB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBFdGhlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZm9ybWF0RXRoZXIoMV8wMDBfMDAwXzAwMF8wMDBfMDAwXzAwMG4pXG4gKiAvLyBAbG9nOiAnMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3ZWkgLSBUaGUgVmFsdWUgdG8gZm9ybWF0LlxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBmb3JtYXQgdGhlIFZhbHVlIGluLiBAZGVmYXVsdCAnd2VpJy5cbiAqIEByZXR1cm5zIFRoZSBFdGhlciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpLCB1bml0ID0gJ3dlaScpIHtcbiAgICByZXR1cm4gZm9ybWF0KHdlaSwgZXhwb25lbnRzLmV0aGVyIC0gZXhwb25lbnRzW3VuaXRdKTtcbn1cbi8qKlxuICogRm9ybWF0cyBhIGBiaWdpbnRgIFZhbHVlIChkZWZhdWx0OiB3ZWkpIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEd3ZWkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZvcm1hdEd3ZWkoMV8wMDBfMDAwXzAwMG4pXG4gKiAvLyBAbG9nOiAnMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3ZWkgLSBUaGUgVmFsdWUgdG8gZm9ybWF0LlxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBmb3JtYXQgdGhlIFZhbHVlIGluLiBAZGVmYXVsdCAnd2VpJy5cbiAqIEByZXR1cm5zIFRoZSBHd2VpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRHd2VpKHdlaSwgdW5pdCA9ICd3ZWknKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh3ZWksIGV4cG9uZW50cy5nd2VpIC0gZXhwb25lbnRzW3VuaXRdKTtcbn1cbi8qKlxuICogUGFyc2VzIGEgYHN0cmluZ2AgcmVwcmVzZW50YXRpb24gb2YgYSBWYWx1ZSB0byBgYmlnaW50YCAobXVsdGlwbGllZCBieSB0aGUgZ2l2ZW4gZXhwb25lbnQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mcm9tKCc0MjAnLCA5KVxuICogLy8gQGxvZzogNDIwMDAwMDAwMDAwblxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsdWUuXG4gKiBAcGFyYW0gZGVjaW1hbHMgLSBUaGUgZXhwb25lbnQgdG8gbXVsdGlwbHkgdGhlIFZhbHVlIGJ5LlxuICogQHJldHVybnMgVGhlIGBiaWdpbnRgIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUsIGRlY2ltYWxzID0gMCkge1xuICAgIGlmICghL14oLT8pKFswLTldKilcXC4/KFswLTldKikkLy50ZXN0KHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWREZWNpbWFsTnVtYmVyRXJyb3IoeyB2YWx1ZSB9KTtcbiAgICBsZXQgW2ludGVnZXIgPSAnJywgZnJhY3Rpb24gPSAnMCddID0gdmFsdWUuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBuZWdhdGl2ZSA9IGludGVnZXIuc3RhcnRzV2l0aCgnLScpO1xuICAgIGlmIChuZWdhdGl2ZSlcbiAgICAgICAgaW50ZWdlciA9IGludGVnZXIuc2xpY2UoMSk7XG4gICAgLy8gdHJpbSB0cmFpbGluZyB6ZXJvcy5cbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnJlcGxhY2UoLygwKykkLywgJycpO1xuICAgIC8vIHJvdW5kIG9mZiBpZiB0aGUgZnJhY3Rpb24gaXMgbGFyZ2VyIHRoYW4gdGhlIG51bWJlciBvZiBkZWNpbWFscy5cbiAgICBpZiAoZGVjaW1hbHMgPT09IDApIHtcbiAgICAgICAgaWYgKE1hdGgucm91bmQoTnVtYmVyKGAuJHtmcmFjdGlvbn1gKSkgPT09IDEpXG4gICAgICAgICAgICBpbnRlZ2VyID0gYCR7QmlnSW50KGludGVnZXIpICsgMW59YDtcbiAgICAgICAgZnJhY3Rpb24gPSAnJztcbiAgICB9XG4gICAgZWxzZSBpZiAoZnJhY3Rpb24ubGVuZ3RoID4gZGVjaW1hbHMpIHtcbiAgICAgICAgY29uc3QgW2xlZnQsIHVuaXQsIHJpZ2h0XSA9IFtcbiAgICAgICAgICAgIGZyYWN0aW9uLnNsaWNlKDAsIGRlY2ltYWxzIC0gMSksXG4gICAgICAgICAgICBmcmFjdGlvbi5zbGljZShkZWNpbWFscyAtIDEsIGRlY2ltYWxzKSxcbiAgICAgICAgICAgIGZyYWN0aW9uLnNsaWNlKGRlY2ltYWxzKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoTnVtYmVyKGAke3VuaXR9LiR7cmlnaHR9YCkpO1xuICAgICAgICBpZiAocm91bmRlZCA+IDkpXG4gICAgICAgICAgICBmcmFjdGlvbiA9IGAke0JpZ0ludChsZWZ0KSArIEJpZ0ludCgxKX0wYC5wYWRTdGFydChsZWZ0Lmxlbmd0aCArIDEsICcwJyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZyYWN0aW9uID0gYCR7bGVmdH0ke3JvdW5kZWR9YDtcbiAgICAgICAgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IGRlY2ltYWxzKSB7XG4gICAgICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnNsaWNlKDEpO1xuICAgICAgICAgICAgaW50ZWdlciA9IGAke0JpZ0ludChpbnRlZ2VyKSArIDFufWA7XG4gICAgICAgIH1cbiAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zbGljZSgwLCBkZWNpbWFscyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnBhZEVuZChkZWNpbWFscywgJzAnKTtcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludChgJHtuZWdhdGl2ZSA/ICctJyA6ICcnfSR7aW50ZWdlcn0ke2ZyYWN0aW9ufWApO1xufVxuLyoqXG4gKiBQYXJzZXMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgRXRoZXIgdG8gYSBgYmlnaW50YCBWYWx1ZSAoZGVmYXVsdDogd2VpKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZnJvbUV0aGVyKCc0MjAnKVxuICogLy8gQGxvZzogNDIwMDAwMDAwMDAwMDAwMDAwMDAwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGV0aGVyIC0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEV0aGVyLlxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBwYXJzZSB0by4gQGRlZmF1bHQgJ3dlaScuXG4gKiBAcmV0dXJucyBBIGBiaWdpbnRgIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV0aGVyKGV0aGVyLCB1bml0ID0gJ3dlaScpIHtcbiAgICByZXR1cm4gZnJvbShldGhlciwgZXhwb25lbnRzLmV0aGVyIC0gZXhwb25lbnRzW3VuaXRdKTtcbn1cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEd3ZWkgdG8gYSBgYmlnaW50YCBWYWx1ZSAoZGVmYXVsdDogd2VpKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZnJvbUd3ZWkoJzQyMCcpXG4gKiAvLyBAbG9nOiA0MjAwMDAwMDAwMDBuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZ3dlaSAtIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBHd2VpLlxuICogQHBhcmFtIHVuaXQgLSBUaGUgdW5pdCB0byBwYXJzZSB0by4gQGRlZmF1bHQgJ3dlaScuXG4gKiBAcmV0dXJucyBBIGBiaWdpbnRgIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUd3ZWkoZ3dlaSwgdW5pdCA9ICd3ZWknKSB7XG4gICAgcmV0dXJuIGZyb20oZ3dlaSwgZXhwb25lbnRzLmd3ZWkgLSBleHBvbmVudHNbdW5pdF0pO1xufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGRlY2ltYWwgbnVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mcm9tRXRoZXIoJzEyMy40NTYuNzg5JylcbiAqIC8vIEBlcnJvcjogVmFsdWUuSW52YWxpZERlY2ltYWxOdW1iZXJFcnJvcjogVmFsdWUgYDEyMy40NTYuNzg5YCBpcyBub3QgYSB2YWxpZCBkZWNpbWFsIG51bWJlci5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZERlY2ltYWxOdW1iZXJFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGEgdmFsaWQgZGVjaW1hbCBudW1iZXIuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdWYWx1ZS5JbnZhbGlkRGVjaW1hbE51bWJlckVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYWx1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Value.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/WebAuthnP256.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/WebAuthnP256.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CredentialCreationFailedError: () => (/* binding */ CredentialCreationFailedError),\n/* harmony export */   CredentialRequestFailedError: () => (/* binding */ CredentialRequestFailedError),\n/* harmony export */   createChallenge: () => (/* binding */ createChallenge),\n/* harmony export */   createCredential: () => (/* binding */ createCredential),\n/* harmony export */   getAuthenticatorData: () => (/* binding */ getAuthenticatorData),\n/* harmony export */   getClientDataJSON: () => (/* binding */ getClientDataJSON),\n/* harmony export */   getCredentialCreationOptions: () => (/* binding */ getCredentialCreationOptions),\n/* harmony export */   getCredentialRequestOptions: () => (/* binding */ getCredentialRequestOptions),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _Base64_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Base64.js */ \"(ssr)/./node_modules/ox/_esm/core/Base64.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_webauthn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/webauthn.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/webauthn.js\");\n/* harmony import */ var _P256_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./P256.js */ \"(ssr)/./node_modules/ox/_esm/core/P256.js\");\n\n\n\n\n\n\n\nconst createChallenge = Uint8Array.from([\n    105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233,\n]);\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */\nasync function createCredential(options) {\n    const { createFn = window.navigator.credentials.create.bind(window.navigator.credentials), ...rest } = options;\n    const creationOptions = getCredentialCreationOptions(rest);\n    try {\n        const credential = (await createFn(creationOptions));\n        if (!credential)\n            throw new CredentialCreationFailedError();\n        const response = credential.response;\n        const publicKey = await _internal_webauthn_js__WEBPACK_IMPORTED_MODULE_0__.parseCredentialPublicKey(response);\n        return {\n            id: credential.id,\n            publicKey,\n            raw: credential,\n        };\n    }\n    catch (error) {\n        throw new CredentialCreationFailedError({\n            cause: error,\n        });\n    }\n}\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */\nfunction getAuthenticatorData(options = {}) {\n    const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options;\n    const rpIdHash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(rpId));\n    const flag_bytes = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(flag, { size: 1 });\n    const signCount_bytes = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(signCount, { size: 4 });\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(rpIdHash, flag_bytes, signCount_bytes);\n}\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */\nfunction getClientDataJSON(options) {\n    const { challenge, crossOrigin = false, extraClientData, origin = window.location.origin, } = options;\n    return JSON.stringify({\n        type: 'webauthn.get',\n        challenge: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(challenge, { url: true, pad: false }),\n        origin,\n        crossOrigin,\n        ...extraClientData,\n    });\n}\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */\nfunction getCredentialCreationOptions(options) {\n    const { attestation = 'none', authenticatorSelection = {\n        residentKey: 'preferred',\n        requireResidentKey: false,\n        userVerification: 'required',\n    }, challenge = createChallenge, excludeCredentialIds, extensions, name: name_, rp = {\n        id: window.location.hostname,\n        name: window.document.title,\n    }, user, } = options;\n    const name = (user?.name ?? name_);\n    return {\n        publicKey: {\n            attestation,\n            authenticatorSelection,\n            challenge: typeof challenge === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(challenge) : challenge,\n            ...(excludeCredentialIds\n                ? {\n                    excludeCredentials: excludeCredentialIds?.map((id) => ({\n                        id: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(id),\n                        type: 'public-key',\n                    })),\n                }\n                : {}),\n            pubKeyCredParams: [\n                {\n                    type: 'public-key',\n                    alg: -7, // p256\n                },\n            ],\n            ...(extensions && { extensions }),\n            rp,\n            user: {\n                id: user?.id ?? _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(name), { as: 'Bytes' }),\n                name,\n                displayName: user?.displayName ?? name,\n            },\n        },\n    };\n}\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */\nfunction getCredentialRequestOptions(options) {\n    const { credentialId, challenge, extensions, rpId = window.location.hostname, userVerification = 'required', } = options;\n    return {\n        publicKey: {\n            ...(credentialId\n                ? {\n                    allowCredentials: Array.isArray(credentialId)\n                        ? credentialId.map((id) => ({\n                            id: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(id),\n                            type: 'public-key',\n                        }))\n                        : [\n                            {\n                                id: _Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(credentialId),\n                                type: 'public-key',\n                            },\n                        ],\n                }\n                : {}),\n            challenge: _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(challenge),\n            ...(extensions && { extensions }),\n            rpId,\n            userVerification,\n        },\n    };\n}\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */\nfunction getSignPayload(options) {\n    const { challenge, crossOrigin, extraClientData, flag, origin, rpId, signCount, userVerification = 'required', } = options;\n    const authenticatorData = getAuthenticatorData({\n        flag,\n        rpId,\n        signCount,\n    });\n    const clientDataJSON = getClientDataJSON({\n        challenge,\n        crossOrigin,\n        extraClientData,\n        origin,\n    });\n    const clientDataJSONHash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(clientDataJSON));\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"');\n    const typeIndex = clientDataJSON.indexOf('\"type\"');\n    const metadata = {\n        authenticatorData,\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired: userVerification === 'required',\n    };\n    const payload = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(authenticatorData, clientDataJSONHash);\n    return { metadata, payload };\n}\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */\nasync function sign(options) {\n    const { getFn = window.navigator.credentials.get.bind(window.navigator.credentials), ...rest } = options;\n    const requestOptions = getCredentialRequestOptions(rest);\n    try {\n        const credential = (await getFn(requestOptions));\n        if (!credential)\n            throw new CredentialRequestFailedError();\n        const response = credential.response;\n        const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));\n        const challengeIndex = clientDataJSON.indexOf('\"challenge\"');\n        const typeIndex = clientDataJSON.indexOf('\"type\"');\n        const signature = _internal_webauthn_js__WEBPACK_IMPORTED_MODULE_0__.parseAsn1Signature(new Uint8Array(response.signature));\n        return {\n            metadata: {\n                authenticatorData: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(new Uint8Array(response.authenticatorData)),\n                clientDataJSON,\n                challengeIndex,\n                typeIndex,\n                userVerificationRequired: requestOptions.publicKey.userVerification === 'required',\n            },\n            signature,\n            raw: credential,\n        };\n    }\n    catch (error) {\n        throw new CredentialRequestFailedError({\n            cause: error,\n        });\n    }\n}\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */\nfunction verify(options) {\n    const { challenge, hash = true, metadata, publicKey, signature } = options;\n    const { authenticatorData, challengeIndex, clientDataJSON, typeIndex, userVerificationRequired, } = metadata;\n    const authenticatorDataBytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(authenticatorData);\n    // Check length of `authenticatorData`.\n    if (authenticatorDataBytes.length < 37)\n        return false;\n    const flag = authenticatorDataBytes[32];\n    // Verify that the UP bit of the flags in authData is set.\n    if ((flag & 0x01) !== 0x01)\n        return false;\n    // If user verification was determined to be required, verify that\n    // the UV bit of the flags in authData is set. Otherwise, ignore the\n    // value of the UV flag.\n    if (userVerificationRequired && (flag & 0x04) !== 0x04)\n        return false;\n    // If the BE bit of the flags in authData is not set, verify that\n    // the BS bit is not set.\n    if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10)\n        return false;\n    // Check that response is for an authentication assertion (if typeIndex is provided)\n    if (typeIndex !== undefined) {\n        const type = '\"type\":\"webauthn.get\"';\n        if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1))\n            return false;\n    }\n    // Extract and validate the challenge from clientDataJSON\n    const challengeMatch = challengeIndex !== undefined\n        ? clientDataJSON\n            .slice(Number(challengeIndex))\n            .match(/^\"challenge\":\"(.*?)\"/)\n        : clientDataJSON.match(/\"challenge\":\"(.*?)\"/);\n    if (!challengeMatch)\n        return false;\n    // Validate the challenge in the clientDataJSON.\n    const [_, challenge_extracted] = challengeMatch;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(_Base64_js__WEBPACK_IMPORTED_MODULE_3__.toBytes(challenge_extracted)) !== challenge)\n        return false;\n    const clientDataJSONHash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(clientDataJSON), {\n        as: 'Bytes',\n    });\n    const payload = _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.concat(authenticatorDataBytes, clientDataJSONHash);\n    return _P256_js__WEBPACK_IMPORTED_MODULE_5__.verify({\n        hash,\n        payload,\n        publicKey,\n        signature,\n    });\n}\n/** Thrown when a WebAuthn P256 credential creation fails. */\nclass CredentialCreationFailedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ cause } = {}) {\n        super('Failed to create credential.', {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'WebAuthnP256.CredentialCreationFailedError'\n        });\n    }\n}\n/** Thrown when a WebAuthn P256 credential request fails. */\nclass CredentialRequestFailedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ cause } = {}) {\n        super('Failed to request credential.', {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'WebAuthnP256.CredentialRequestFailedError'\n        });\n    }\n}\n//# sourceMappingURL=WebAuthnP256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1dlYkF1dGhuUDI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFDRjtBQUNFO0FBQ0o7QUFDRjtBQUNtQjtBQUNqQjtBQUMzQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSw2RkFBNkY7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJFQUFpQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdUNBQXVDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDO0FBQ2pELFlBQVksMkRBQTJEO0FBQ3ZFLHFCQUFxQiw0Q0FBVyxDQUFDLCtDQUFjO0FBQy9DLHVCQUF1QiwrQ0FBYyxTQUFTLFNBQVM7QUFDdkQsNEJBQTRCLCtDQUFjLGNBQWMsU0FBUztBQUNqRSxXQUFXLDJDQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQ0FBc0M7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx1Q0FBdUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFB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d2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XZWJBdXRoblAyNTYuanM/ZWIzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBCYXNlNjQgZnJvbSAnLi9CYXNlNjQuanMnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvd2ViYXV0aG4uanMnO1xuaW1wb3J0ICogYXMgUDI1NiBmcm9tICcuL1AyNTYuanMnO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNoYWxsZW5nZSA9IFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgMTA1LCAxNzEsIDE4MCwgMTgxLCAxNjAsIDIyMiwgNzUsIDE5OCwgNDIsIDQyLCAzMiwgMzEsIDE0MSwgMzcsIDE4NiwgMjMzLFxuXSk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgV2ViQXV0aG4gUDI1NiBDcmVkZW50aWFsLCB3aGljaCBjYW4gYmUgc3RvcmVkIGFuZCBsYXRlciB1c2VkIGZvciBzaWduaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5jcmVhdGVDcmVkZW50aWFsKHsgbmFtZTogJ0V4YW1wbGUnIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgaWQ6ICdvWjQ4Li4uJyxcbiAqIC8vIEBsb2c6ICAgcHVibGljS2V5OiB7IHg6IDUxNDIxLi4uNTEyM24sIHk6IDEyMzQ1Li4uNjc4OW4gfSxcbiAqIC8vIEBsb2c6ICAgcmF3OiBQdWJsaWNLZXlDcmVkZW50aWFsIHt9LFxuICogLy8gQGxvZzogfVxuICpcbiAqIGNvbnN0IHsgbWV0YWRhdGEsIHNpZ25hdHVyZSB9ID0gYXdhaXQgV2ViQXV0aG5QMjU2LnNpZ24oe1xuICogICBjcmVkZW50aWFsSWQ6IGNyZWRlbnRpYWwuaWQsXG4gKiAgIGNoYWxsZW5nZTogJzB4ZGVhZGJlZWYnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gQ3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgQSBXZWJBdXRobiBQMjU2IGNyZWRlbnRpYWwuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDcmVkZW50aWFsKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNyZWF0ZUZuID0gd2luZG93Lm5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUuYmluZCh3aW5kb3cubmF2aWdhdG9yLmNyZWRlbnRpYWxzKSwgLi4ucmVzdCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjcmVhdGlvbk9wdGlvbnMgPSBnZXRDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKHJlc3QpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWwgPSAoYXdhaXQgY3JlYXRlRm4oY3JlYXRpb25PcHRpb25zKSk7XG4gICAgICAgIGlmICghY3JlZGVudGlhbClcbiAgICAgICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsQ3JlYXRpb25GYWlsZWRFcnJvcigpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGNyZWRlbnRpYWwucmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IGludGVybmFsLnBhcnNlQ3JlZGVudGlhbFB1YmxpY0tleShyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogY3JlZGVudGlhbC5pZCxcbiAgICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICAgIHJhdzogY3JlZGVudGlhbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsQ3JlYXRpb25GYWlsZWRFcnJvcih7XG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogR2V0cyB0aGUgYXV0aGVudGljYXRvciBkYXRhIHdoaWNoIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogcHJvY2Vzc2luZyBvZiBhbiBhdXRoZW50aWNhdG9yIHJlcXVlc3QgKGllLiBmcm9tIGBXZWJBdXRoblAyNTYuc2lnbmApLlxuICpcbiAqIDo6Ondhcm5pbmdcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG1haW5seSBmb3IgdGVzdGluZyBwdXJwb3NlcyBvciBmb3IgbWFudWFsbHkgY29uc3RydWN0aW5nXG4gKiBhdXRlbnRpY2F0b3IgZGF0YS4gSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCBub3QgbmVlZCB0aGlzIGZ1bmN0aW9uLlxuICogYGF1dGhlbnRpY2F0b3JEYXRhYCBpcyB0eXBpY2FsbHkgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGVcbiAqIHtAbGluayBveCNXZWJBdXRoblAyNTYuKHNpZ246ZnVuY3Rpb24pfSByZXNwb25zZSAoaWUuIGFuIGF1dGhlbnRpY2F0b3IgcmVzcG9uc2UpLlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aGVudGljYXRvckRhdGEgPSBXZWJBdXRoblAyNTYuZ2V0QXV0aGVudGljYXRvckRhdGEoe1xuICogICBycElkOiAnZXhhbXBsZS5jb20nLFxuICogICBzaWduQ291bnQ6IDQyMCxcbiAqIH0pXG4gKiAvLyBAbG9nOiBcIjB4YTM3OWE2ZjZlZWFmYjlhNTVlMzc4YzExODAzNGUyNzUxZTY4MmZhYjlmMmQzMGFiMTNkMjEyNTU4NmNlMTk0NzA1MDAwMDAxYTRcIlxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIHRvIGNvbnN0cnVjdCB0aGUgYXV0aGVudGljYXRvciBkYXRhLlxuICogQHJldHVybnMgVGhlIGF1dGhlbnRpY2F0b3IgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dGhlbnRpY2F0b3JEYXRhKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZmxhZyA9IDUsIHJwSWQgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsIHNpZ25Db3VudCA9IDAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcnBJZEhhc2ggPSBIYXNoLnNoYTI1NihIZXguZnJvbVN0cmluZyhycElkKSk7XG4gICAgY29uc3QgZmxhZ19ieXRlcyA9IEhleC5mcm9tTnVtYmVyKGZsYWcsIHsgc2l6ZTogMSB9KTtcbiAgICBjb25zdCBzaWduQ291bnRfYnl0ZXMgPSBIZXguZnJvbU51bWJlcihzaWduQ291bnQsIHsgc2l6ZTogNCB9KTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChycElkSGFzaCwgZmxhZ19ieXRlcywgc2lnbkNvdW50X2J5dGVzKTtcbn1cbi8qKlxuICogQ29uc3RydWN0cyB0aGUgQ2xpZW50IERhdGEgaW4gc3RyaW5naWZpZWQgSlNPTiBmb3JtYXQgd2hpY2ggcmVwcmVzZW50cyBjbGllbnQgZGF0YSB0aGF0XG4gKiB3YXMgcGFzc2VkIHRvIGBjcmVkZW50aWFscy5nZXQoKWAgaW4ge0BsaW5rIG94I1dlYkF1dGhuUDI1Ni4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIDo6Ondhcm5pbmdcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG1haW5seSBmb3IgdGVzdGluZyBwdXJwb3NlcyBvciBmb3IgbWFudWFsbHkgY29uc3RydWN0aW5nXG4gKiBjbGllbnQgZGF0YS4gSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCBub3QgbmVlZCB0aGlzIGZ1bmN0aW9uLlxuICogYGNsaWVudERhdGFKU09OYCBpcyB0eXBpY2FsbHkgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGVcbiAqIHtAbGluayBveCNXZWJBdXRoblAyNTYuKHNpZ246ZnVuY3Rpb24pfSByZXNwb25zZSAoaWUuIGFuIGF1dGhlbnRpY2F0b3IgcmVzcG9uc2UpLlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgY2xpZW50RGF0YUpTT04gPSBXZWJBdXRoblAyNTYuZ2V0Q2xpZW50RGF0YUpTT04oe1xuICogICBjaGFsbGVuZ2U6ICcweGRlYWRiZWVmJyxcbiAqICAgb3JpZ2luOiAnaHR0cHM6Ly9leGFtcGxlLmNvbScsXG4gKiB9KVxuICogLy8gQGxvZzogXCJ7XCJ0eXBlXCI6XCJ3ZWJhdXRobi5nZXRcIixcImNoYWxsZW5nZVwiOlwiM3EyLTd3XCIsXCJvcmlnaW5cIjpcImh0dHBzOi8vZXhhbXBsZS5jb21cIixcImNyb3NzT3JpZ2luXCI6ZmFsc2V9XCJcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25zdHJ1Y3QgdGhlIGNsaWVudCBkYXRhLlxuICogQHJldHVybnMgVGhlIGNsaWVudCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50RGF0YUpTT04ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hhbGxlbmdlLCBjcm9zc09yaWdpbiA9IGZhbHNlLCBleHRyYUNsaWVudERhdGEsIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHR5cGU6ICd3ZWJhdXRobi5nZXQnLFxuICAgICAgICBjaGFsbGVuZ2U6IEJhc2U2NC5mcm9tSGV4KGNoYWxsZW5nZSwgeyB1cmw6IHRydWUsIHBhZDogZmFsc2UgfSksXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgY3Jvc3NPcmlnaW4sXG4gICAgICAgIC4uLmV4dHJhQ2xpZW50RGF0YSxcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3JlYXRpb24gb3B0aW9ucyBmb3IgYSBQMjU2IFdlYkF1dGhuIENyZWRlbnRpYWwgdG8gYmUgdXNlZCB3aXRoXG4gKiB0aGUgV2ViIEF1dGhlbnRpY2F0aW9uIEFQSS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdlYkF1dGhuUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IG9wdGlvbnMgPSBXZWJBdXRoblAyNTYuZ2V0Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyh7IG5hbWU6ICdFeGFtcGxlJyB9KVxuICpcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCB3aW5kb3cubmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZShvcHRpb25zKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGNyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXR0ZXN0YXRpb24gPSAnbm9uZScsIGF1dGhlbnRpY2F0b3JTZWxlY3Rpb24gPSB7XG4gICAgICAgIHJlc2lkZW50S2V5OiAncHJlZmVycmVkJyxcbiAgICAgICAgcmVxdWlyZVJlc2lkZW50S2V5OiBmYWxzZSxcbiAgICAgICAgdXNlclZlcmlmaWNhdGlvbjogJ3JlcXVpcmVkJyxcbiAgICB9LCBjaGFsbGVuZ2UgPSBjcmVhdGVDaGFsbGVuZ2UsIGV4Y2x1ZGVDcmVkZW50aWFsSWRzLCBleHRlbnNpb25zLCBuYW1lOiBuYW1lXywgcnAgPSB7XG4gICAgICAgIGlkOiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsXG4gICAgICAgIG5hbWU6IHdpbmRvdy5kb2N1bWVudC50aXRsZSxcbiAgICB9LCB1c2VyLCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBuYW1lID0gKHVzZXI/Lm5hbWUgPz8gbmFtZV8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHB1YmxpY0tleToge1xuICAgICAgICAgICAgYXR0ZXN0YXRpb24sXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yU2VsZWN0aW9uLFxuICAgICAgICAgICAgY2hhbGxlbmdlOiB0eXBlb2YgY2hhbGxlbmdlID09PSAnc3RyaW5nJyA/IEJ5dGVzLmZyb21IZXgoY2hhbGxlbmdlKSA6IGNoYWxsZW5nZSxcbiAgICAgICAgICAgIC4uLihleGNsdWRlQ3JlZGVudGlhbElkc1xuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBleGNsdWRlQ3JlZGVudGlhbHM6IGV4Y2x1ZGVDcmVkZW50aWFsSWRzPy5tYXAoKGlkKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IEJhc2U2NC50b0J5dGVzKGlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdWJsaWMta2V5JyxcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIHB1YktleUNyZWRQYXJhbXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdWJsaWMta2V5JyxcbiAgICAgICAgICAgICAgICAgICAgYWxnOiAtNywgLy8gcDI1NlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLi4uKGV4dGVuc2lvbnMgJiYgeyBleHRlbnNpb25zIH0pLFxuICAgICAgICAgICAgcnAsXG4gICAgICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHVzZXI/LmlkID8/IEhhc2gua2VjY2FrMjU2KEJ5dGVzLmZyb21TdHJpbmcobmFtZSksIHsgYXM6ICdCeXRlcycgfSksXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogdXNlcj8uZGlzcGxheU5hbWUgPz8gbmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWVzdCBvcHRpb25zIHRvIHNpZ24gYSBjaGFsbGVuZ2Ugd2l0aCB0aGUgV2ViIEF1dGhlbnRpY2F0aW9uIEFQSS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdlYkF1dGhuUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IG9wdGlvbnMgPSBXZWJBdXRoblAyNTYuZ2V0Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKHtcbiAqICAgY2hhbGxlbmdlOiAnMHhkZWFkYmVlZicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCB3aW5kb3cubmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldChvcHRpb25zKVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGNyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNyZWRlbnRpYWxJZCwgY2hhbGxlbmdlLCBleHRlbnNpb25zLCBycElkID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLCB1c2VyVmVyaWZpY2F0aW9uID0gJ3JlcXVpcmVkJywgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHVibGljS2V5OiB7XG4gICAgICAgICAgICAuLi4oY3JlZGVudGlhbElkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q3JlZGVudGlhbHM6IEFycmF5LmlzQXJyYXkoY3JlZGVudGlhbElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVkZW50aWFsSWQubWFwKChpZCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogQmFzZTY0LnRvQnl0ZXMoaWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwdWJsaWMta2V5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogQmFzZTY0LnRvQnl0ZXMoY3JlZGVudGlhbElkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIGNoYWxsZW5nZTogQnl0ZXMuZnJvbUhleChjaGFsbGVuZ2UpLFxuICAgICAgICAgICAgLi4uKGV4dGVuc2lvbnMgJiYgeyBleHRlbnNpb25zIH0pLFxuICAgICAgICAgICAgcnBJZCxcbiAgICAgICAgICAgIHVzZXJWZXJpZmljYXRpb24sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ29uc3RydWN0cyB0aGUgZmluYWwgZGlnZXN0IHRoYXQgd2FzIHNpZ25lZCBhbmQgY29tcHV0ZWQgYnkgdGhlIGF1dGhlbnRpY2F0b3IuIFRoaXMgcGF5bG9hZCBpbmNsdWRlc1xuICogdGhlIGNyeXB0b2dyYXBoaWMgYGNoYWxsZW5nZWAsIGFzIHdlbGwgYXMgYXV0aGVudGljYXRvciBtZXRhZGF0YSAoYGF1dGhlbnRpY2F0b3JEYXRhYCArIGBjbGllbnREYXRhSlNPTmApLlxuICogVGhpcyB2YWx1ZSBjYW4gYmUgYWxzbyB1c2VkIHdpdGggcmF3IFAyNTYgdmVyaWZpY2F0aW9uIChzdWNoIGFzIHtAbGluayBveCNQMjU2Lih2ZXJpZnk6ZnVuY3Rpb24pfSBvclxuICoge0BsaW5rIG94I1dlYkNyeXB0b1AyNTYuKHZlcmlmeTpmdW5jdGlvbil9KS5cbiAqXG4gKiA6Ojp3YXJuaW5nXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBtYWlubHkgZm9yIHRlc3RpbmcgcHVycG9zZXMgb3IgZm9yIG1hbnVhbGx5IGNvbnN0cnVjdGluZ1xuICogc2lnbmluZyBwYXlsb2Fkcy4gSW4gbW9zdCBjYXNlcyB5b3Ugd2lsbCBub3QgbmVlZCB0aGlzIGZ1bmN0aW9uIGFuZFxuICogaW5zdGVhZCB1c2Uge0BsaW5rIG94I1dlYkF1dGhuUDI1Ni4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2LCBXZWJDcnlwdG9QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgcGF5bG9hZCB9ID0gV2ViQXV0aG5QMjU2LmdldFNpZ25QYXlsb2FkKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBjaGFsbGVuZ2U6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBtZXRhZGF0YToge1xuICogLy8gQGxvZzogICAgIGF1dGhlbnRpY2F0b3JEYXRhOiBcIjB4NDk5NjBkZTU4ODBlOGM2ODc0MzQxNzBmNjQ3NjYwNWI4ZmU0YWViOWEyODYzMmM3OTk1Y2YzYmE4MzFkOTc2MzA1MDAwMDAwMDBcIixcbiAqIC8vIEBsb2c6ICAgICBjaGFsbGVuZ2VJbmRleDogMjMsXG4gKiAvLyBAbG9nOiAgICAgY2xpZW50RGF0YUpTT046IFwie1widHlwZVwiOlwid2ViYXV0aG4uZ2V0XCIsXCJjaGFsbGVuZ2VcIjpcIjlqRUZpanVoRVdyTTRTT1ctdENoSmJVRUhFUDQ0VmNqY0otQnFvMWZUTThcIixcIm9yaWdpblwiOlwiaHR0cDovL2xvY2FsaG9zdDo1MTczXCIsXCJjcm9zc09yaWdpblwiOmZhbHNlfVwiLFxuICogLy8gQGxvZzogICAgIHR5cGVJbmRleDogMSxcbiAqIC8vIEBsb2c6ICAgICB1c2VyVmVyaWZpY2F0aW9uUmVxdWlyZWQ6IHRydWUsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHBheWxvYWQ6IFwiMHg0OTk2MGRlNTg4MGU4YzY4NzQzNDE3MGY2NDc2NjA1YjhmZTRhZWI5YTI4NjMyYzc5OTVjZjNiYTgzMWQ5NzYzMDUwMDAwMDAwMDQ1MDg2ZGNiMDZhNWYyMzRkYjYyNWJjZGM5NGU2NTdmODZiNzZiNmZkM2ViOWMzMDU0M2VhYmMxZTU3N2E0YjBcIixcbiAqIC8vIEBsb2c6IH1cbiAqXG4gKiBjb25zdCB7IHB1YmxpY0tleSwgcHJpdmF0ZUtleSB9ID0gYXdhaXQgV2ViQ3J5cHRvUDI1Ni5jcmVhdGVLZXlQYWlyKClcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LnNpZ24oe1xuICogICBwYXlsb2FkLFxuICogICBwcml2YXRlS2V5LFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBjb25zdHJ1Y3QgdGhlIHNpZ25pbmcgcGF5bG9hZC5cbiAqIEByZXR1cm5zIFRoZSBzaWduaW5nIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGFsbGVuZ2UsIGNyb3NzT3JpZ2luLCBleHRyYUNsaWVudERhdGEsIGZsYWcsIG9yaWdpbiwgcnBJZCwgc2lnbkNvdW50LCB1c2VyVmVyaWZpY2F0aW9uID0gJ3JlcXVpcmVkJywgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYXV0aGVudGljYXRvckRhdGEgPSBnZXRBdXRoZW50aWNhdG9yRGF0YSh7XG4gICAgICAgIGZsYWcsXG4gICAgICAgIHJwSWQsXG4gICAgICAgIHNpZ25Db3VudCxcbiAgICB9KTtcbiAgICBjb25zdCBjbGllbnREYXRhSlNPTiA9IGdldENsaWVudERhdGFKU09OKHtcbiAgICAgICAgY2hhbGxlbmdlLFxuICAgICAgICBjcm9zc09yaWdpbixcbiAgICAgICAgZXh0cmFDbGllbnREYXRhLFxuICAgICAgICBvcmlnaW4sXG4gICAgfSk7XG4gICAgY29uc3QgY2xpZW50RGF0YUpTT05IYXNoID0gSGFzaC5zaGEyNTYoSGV4LmZyb21TdHJpbmcoY2xpZW50RGF0YUpTT04pKTtcbiAgICBjb25zdCBjaGFsbGVuZ2VJbmRleCA9IGNsaWVudERhdGFKU09OLmluZGV4T2YoJ1wiY2hhbGxlbmdlXCInKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBjbGllbnREYXRhSlNPTi5pbmRleE9mKCdcInR5cGVcIicpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICBhdXRoZW50aWNhdG9yRGF0YSxcbiAgICAgICAgY2xpZW50RGF0YUpTT04sXG4gICAgICAgIGNoYWxsZW5nZUluZGV4LFxuICAgICAgICB0eXBlSW5kZXgsXG4gICAgICAgIHVzZXJWZXJpZmljYXRpb25SZXF1aXJlZDogdXNlclZlcmlmaWNhdGlvbiA9PT0gJ3JlcXVpcmVkJyxcbiAgICB9O1xuICAgIGNvbnN0IHBheWxvYWQgPSBIZXguY29uY2F0KGF1dGhlbnRpY2F0b3JEYXRhLCBjbGllbnREYXRhSlNPTkhhc2gpO1xuICAgIHJldHVybiB7IG1ldGFkYXRhLCBwYXlsb2FkIH07XG59XG4vKipcbiAqIFNpZ25zIGEgY2hhbGxlbmdlIHVzaW5nIGEgc3RvcmVkIFdlYkF1dGhuIFAyNTYgQ3JlZGVudGlhbC4gSWYgbm8gQ3JlZGVudGlhbCBpcyBwcm92aWRlZCxcbiAqIGEgcHJvbXB0IHdpbGwgYmUgZGlzcGxheWVkIGZvciB0aGUgdXNlciB0byBzZWxlY3QgYW4gZXhpc3RpbmcgQ3JlZGVudGlhbFxuICogdGhhdCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5jcmVhdGVDcmVkZW50aWFsKHtcbiAqICAgbmFtZTogJ0V4YW1wbGUnLFxuICogfSlcbiAqXG4gKiBjb25zdCB7IG1ldGFkYXRhLCBzaWduYXR1cmUgfSA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5zaWduKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBjcmVkZW50aWFsSWQ6IGNyZWRlbnRpYWwuaWQsIC8vIFshY29kZSBmb2N1c11cbiAqICAgY2hhbGxlbmdlOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgbWV0YWRhdGE6IHtcbiAqIC8vIEBsb2c6ICAgICBhdXRoZW50aWNhdG9yRGF0YTogJzB4NDk5NjBkZTU4ODBlOGM2ODc0MzQxNzBmNjQ3NjYwNWI4ZmU0YWViOWEyODYzMmM3OTk1Y2YzYmE4MzFkOTc2MzA1MDAwMDAwMDAnLFxuICogLy8gQGxvZzogICAgIGNsaWVudERhdGFKU09OOiAne1widHlwZVwiOlwid2ViYXV0aG4uZ2V0XCIsXCJjaGFsbGVuZ2VcIjpcIjlqRUZpanVoRVdyTTRTT1ctdENoSmJVRUhFUDQ0VmNqY0otQnFvMWZUTThcIixcIm9yaWdpblwiOlwiaHR0cDovL2xvY2FsaG9zdDo1MTczXCIsXCJjcm9zc09yaWdpblwiOmZhbHNlfScsXG4gKiAvLyBAbG9nOiAgICAgY2hhbGxlbmdlSW5kZXg6IDIzLFxuICogLy8gQGxvZzogICAgIHR5cGVJbmRleDogMSxcbiAqIC8vIEBsb2c6ICAgICB1c2VyVmVyaWZpY2F0aW9uUmVxdWlyZWQ6IHRydWUsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHNpZ25hdHVyZTogeyByOiA1MTIzMS4uLjQyMTVuLCBzOiAxMjM0NS4uLjY3ODluIH0sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbihvcHRpb25zKSB7XG4gICAgY29uc3QgeyBnZXRGbiA9IHdpbmRvdy5uYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0LmJpbmQod2luZG93Lm5hdmlnYXRvci5jcmVkZW50aWFscyksIC4uLnJlc3QgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBnZXRDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMocmVzdCk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbCA9IChhd2FpdCBnZXRGbihyZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICBpZiAoIWNyZWRlbnRpYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3JlZGVudGlhbFJlcXVlc3RGYWlsZWRFcnJvcigpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGNyZWRlbnRpYWwucmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IGNsaWVudERhdGFKU09OID0gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShyZXNwb25zZS5jbGllbnREYXRhSlNPTikpO1xuICAgICAgICBjb25zdCBjaGFsbGVuZ2VJbmRleCA9IGNsaWVudERhdGFKU09OLmluZGV4T2YoJ1wiY2hhbGxlbmdlXCInKTtcbiAgICAgICAgY29uc3QgdHlwZUluZGV4ID0gY2xpZW50RGF0YUpTT04uaW5kZXhPZignXCJ0eXBlXCInKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gaW50ZXJuYWwucGFyc2VBc24xU2lnbmF0dXJlKG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLnNpZ25hdHVyZSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YTogSGV4LmZyb21CeXRlcyhuZXcgVWludDhBcnJheShyZXNwb25zZS5hdXRoZW50aWNhdG9yRGF0YSkpLFxuICAgICAgICAgICAgICAgIGNsaWVudERhdGFKU09OLFxuICAgICAgICAgICAgICAgIGNoYWxsZW5nZUluZGV4LFxuICAgICAgICAgICAgICAgIHR5cGVJbmRleCxcbiAgICAgICAgICAgICAgICB1c2VyVmVyaWZpY2F0aW9uUmVxdWlyZWQ6IHJlcXVlc3RPcHRpb25zLnB1YmxpY0tleS51c2VyVmVyaWZpY2F0aW9uID09PSAncmVxdWlyZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgIHJhdzogY3JlZGVudGlhbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBDcmVkZW50aWFsUmVxdWVzdEZhaWxlZEVycm9yKHtcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBWZXJpZmllcyBhIHNpZ25hdHVyZSB1c2luZyB0aGUgQ3JlZGVudGlhbCdzIHB1YmxpYyBrZXkgYW5kIHRoZSBjaGFsbGVuZ2Ugd2hpY2ggd2FzIHNpZ25lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFdlYkF1dGhuUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCBXZWJBdXRoblAyNTYuY3JlYXRlQ3JlZGVudGlhbCh7XG4gKiAgIG5hbWU6ICdFeGFtcGxlJyxcbiAqIH0pXG4gKlxuICogY29uc3QgeyBtZXRhZGF0YSwgc2lnbmF0dXJlIH0gPSBhd2FpdCBXZWJBdXRoblAyNTYuc2lnbih7XG4gKiAgIGNyZWRlbnRpYWxJZDogY3JlZGVudGlhbC5pZCxcbiAqICAgY2hhbGxlbmdlOiAnMHhkZWFkYmVlZicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFdlYkF1dGhuUDI1Ni52ZXJpZnkoeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1ldGFkYXRhLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGNoYWxsZW5nZTogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHB1YmxpY0tleTogY3JlZGVudGlhbC5wdWJsaWNLZXksIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnkob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hhbGxlbmdlLCBoYXNoID0gdHJ1ZSwgbWV0YWRhdGEsIHB1YmxpY0tleSwgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgYXV0aGVudGljYXRvckRhdGEsIGNoYWxsZW5nZUluZGV4LCBjbGllbnREYXRhSlNPTiwgdHlwZUluZGV4LCB1c2VyVmVyaWZpY2F0aW9uUmVxdWlyZWQsIH0gPSBtZXRhZGF0YTtcbiAgICBjb25zdCBhdXRoZW50aWNhdG9yRGF0YUJ5dGVzID0gQnl0ZXMuZnJvbUhleChhdXRoZW50aWNhdG9yRGF0YSk7XG4gICAgLy8gQ2hlY2sgbGVuZ3RoIG9mIGBhdXRoZW50aWNhdG9yRGF0YWAuXG4gICAgaWYgKGF1dGhlbnRpY2F0b3JEYXRhQnl0ZXMubGVuZ3RoIDwgMzcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBmbGFnID0gYXV0aGVudGljYXRvckRhdGFCeXRlc1szMl07XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIFVQIGJpdCBvZiB0aGUgZmxhZ3MgaW4gYXV0aERhdGEgaXMgc2V0LlxuICAgIGlmICgoZmxhZyAmIDB4MDEpICE9PSAweDAxKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gSWYgdXNlciB2ZXJpZmljYXRpb24gd2FzIGRldGVybWluZWQgdG8gYmUgcmVxdWlyZWQsIHZlcmlmeSB0aGF0XG4gICAgLy8gdGhlIFVWIGJpdCBvZiB0aGUgZmxhZ3MgaW4gYXV0aERhdGEgaXMgc2V0LiBPdGhlcndpc2UsIGlnbm9yZSB0aGVcbiAgICAvLyB2YWx1ZSBvZiB0aGUgVVYgZmxhZy5cbiAgICBpZiAodXNlclZlcmlmaWNhdGlvblJlcXVpcmVkICYmIChmbGFnICYgMHgwNCkgIT09IDB4MDQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBJZiB0aGUgQkUgYml0IG9mIHRoZSBmbGFncyBpbiBhdXRoRGF0YSBpcyBub3Qgc2V0LCB2ZXJpZnkgdGhhdFxuICAgIC8vIHRoZSBCUyBiaXQgaXMgbm90IHNldC5cbiAgICBpZiAoKGZsYWcgJiAweDA4KSAhPT0gMHgwOCAmJiAoZmxhZyAmIDB4MTApID09PSAweDEwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgdGhhdCByZXNwb25zZSBpcyBmb3IgYW4gYXV0aGVudGljYXRpb24gYXNzZXJ0aW9uIChpZiB0eXBlSW5kZXggaXMgcHJvdmlkZWQpXG4gICAgaWYgKHR5cGVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAnXCJ0eXBlXCI6XCJ3ZWJhdXRobi5nZXRcIic7XG4gICAgICAgIGlmICh0eXBlICE9PSBjbGllbnREYXRhSlNPTi5zbGljZShOdW1iZXIodHlwZUluZGV4KSwgdHlwZS5sZW5ndGggKyAxKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRXh0cmFjdCBhbmQgdmFsaWRhdGUgdGhlIGNoYWxsZW5nZSBmcm9tIGNsaWVudERhdGFKU09OXG4gICAgY29uc3QgY2hhbGxlbmdlTWF0Y2ggPSBjaGFsbGVuZ2VJbmRleCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gY2xpZW50RGF0YUpTT05cbiAgICAgICAgICAgIC5zbGljZShOdW1iZXIoY2hhbGxlbmdlSW5kZXgpKVxuICAgICAgICAgICAgLm1hdGNoKC9eXCJjaGFsbGVuZ2VcIjpcIiguKj8pXCIvKVxuICAgICAgICA6IGNsaWVudERhdGFKU09OLm1hdGNoKC9cImNoYWxsZW5nZVwiOlwiKC4qPylcIi8pO1xuICAgIGlmICghY2hhbGxlbmdlTWF0Y2gpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBWYWxpZGF0ZSB0aGUgY2hhbGxlbmdlIGluIHRoZSBjbGllbnREYXRhSlNPTi5cbiAgICBjb25zdCBbXywgY2hhbGxlbmdlX2V4dHJhY3RlZF0gPSBjaGFsbGVuZ2VNYXRjaDtcbiAgICBpZiAoSGV4LmZyb21CeXRlcyhCYXNlNjQudG9CeXRlcyhjaGFsbGVuZ2VfZXh0cmFjdGVkKSkgIT09IGNoYWxsZW5nZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGNsaWVudERhdGFKU09OSGFzaCA9IEhhc2guc2hhMjU2KEJ5dGVzLmZyb21TdHJpbmcoY2xpZW50RGF0YUpTT04pLCB7XG4gICAgICAgIGFzOiAnQnl0ZXMnLFxuICAgIH0pO1xuICAgIGNvbnN0IHBheWxvYWQgPSBCeXRlcy5jb25jYXQoYXV0aGVudGljYXRvckRhdGFCeXRlcywgY2xpZW50RGF0YUpTT05IYXNoKTtcbiAgICByZXR1cm4gUDI1Ni52ZXJpZnkoe1xuICAgICAgICBoYXNoLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICB9KTtcbn1cbi8qKiBUaHJvd24gd2hlbiBhIFdlYkF1dGhuIFAyNTYgY3JlZGVudGlhbCBjcmVhdGlvbiBmYWlscy4gKi9cbmV4cG9ydCBjbGFzcyBDcmVkZW50aWFsQ3JlYXRpb25GYWlsZWRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY2F1c2UgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCdGYWlsZWQgdG8gY3JlYXRlIGNyZWRlbnRpYWwuJywge1xuICAgICAgICAgICAgY2F1c2UsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnV2ViQXV0aG5QMjU2LkNyZWRlbnRpYWxDcmVhdGlvbkZhaWxlZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYSBXZWJBdXRobiBQMjU2IGNyZWRlbnRpYWwgcmVxdWVzdCBmYWlscy4gKi9cbmV4cG9ydCBjbGFzcyBDcmVkZW50aWFsUmVxdWVzdEZhaWxlZEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBjYXVzZSB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoJ0ZhaWxlZCB0byByZXF1ZXN0IGNyZWRlbnRpYWwuJywge1xuICAgICAgICAgICAgY2F1c2UsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnV2ViQXV0aG5QMjU2LkNyZWRlbnRpYWxSZXF1ZXN0RmFpbGVkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdlYkF1dGhuUDI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/WebAuthnP256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Withdrawal.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/Withdrawal.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n/**\n * Converts a {@link ox#Withdrawal.Rpc} to an {@link ox#Withdrawal.Withdrawal}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.fromRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: '0x620323',\n *   index: '0x0',\n *   validatorIndex: '0x1',\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: 6423331n,\n * // @log:   index: 0,\n * // @log:   validatorIndex: 1\n * // @log: }\n * ```\n *\n * @param withdrawal - The RPC withdrawal to convert.\n * @returns An instantiated {@link ox#Withdrawal.Withdrawal}.\n */\nfunction fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex),\n    };\n}\n/**\n * Converts a {@link ox#Withdrawal.Withdrawal} to an {@link ox#Withdrawal.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.toRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: 6423331n,\n *   index: 0,\n *   validatorIndex: 1,\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: '0x620323',\n * // @log:   index: '0x0',\n * // @log:   validatorIndex: '0x1',\n * // @log: }\n * ```\n *\n * @param withdrawal - The Withdrawal to convert.\n * @returns An RPC Withdrawal.\n */\nfunction toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.amount),\n        index: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.index),\n        validatorIndex: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.validatorIndex),\n    };\n}\n//# sourceMappingURL=Withdrawal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1dpdGhkcmF3YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdDO0FBQ2hDO0FBQ0EsZUFBZSx5QkFBeUIsT0FBTywrQkFBK0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0MsT0FBTyx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFjO0FBQzlCLGVBQWUsK0NBQWM7QUFDN0Isd0JBQXdCLCtDQUFjO0FBQ3RDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XaXRoZHJhd2FsLmpzPzQ3MzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjV2l0aGRyYXdhbC5ScGN9IHRvIGFuIHtAbGluayBveCNXaXRoZHJhd2FsLldpdGhkcmF3YWx9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2l0aGRyYXdhbCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHdpdGhkcmF3YWwgPSBXaXRoZHJhd2FsLmZyb21ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJyxcbiAqICAgYW1vdW50OiAnMHg2MjAzMjMnLFxuICogICBpbmRleDogJzB4MCcsXG4gKiAgIHZhbGlkYXRvckluZGV4OiAnMHgxJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogLy8gQGxvZzogICBhbW91bnQ6IDY0MjMzMzFuLFxuICogLy8gQGxvZzogICBpbmRleDogMCxcbiAqIC8vIEBsb2c6ICAgdmFsaWRhdG9ySW5kZXg6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3aXRoZHJhd2FsIC0gVGhlIFJQQyB3aXRoZHJhd2FsIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1dpdGhkcmF3YWwuV2l0aGRyYXdhbH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHdpdGhkcmF3YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi53aXRoZHJhd2FsLFxuICAgICAgICBhbW91bnQ6IEJpZ0ludCh3aXRoZHJhd2FsLmFtb3VudCksXG4gICAgICAgIGluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC5pbmRleCksXG4gICAgICAgIHZhbGlkYXRvckluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjV2l0aGRyYXdhbC5XaXRoZHJhd2FsfSB0byBhbiB7QGxpbmsgb3gjV2l0aGRyYXdhbC5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2l0aGRyYXdhbCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHdpdGhkcmF3YWwgPSBXaXRoZHJhd2FsLnRvUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYScsXG4gKiAgIGFtb3VudDogNjQyMzMzMW4sXG4gKiAgIGluZGV4OiAwLFxuICogICB2YWxpZGF0b3JJbmRleDogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogLy8gQGxvZzogICBhbW91bnQ6ICcweDYyMDMyMycsXG4gKiAvLyBAbG9nOiAgIGluZGV4OiAnMHgwJyxcbiAqIC8vIEBsb2c6ICAgdmFsaWRhdG9ySW5kZXg6ICcweDEnLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHdpdGhkcmF3YWwgLSBUaGUgV2l0aGRyYXdhbCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gUlBDIFdpdGhkcmF3YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyh3aXRoZHJhd2FsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogd2l0aGRyYXdhbC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuYW1vdW50KSxcbiAgICAgICAgaW5kZXg6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuaW5kZXgpLFxuICAgICAgICB2YWxpZGF0b3JJbmRleDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhkcmF3YWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Withdrawal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/abiParameters.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeAddress: () => (/* binding */ decodeAddress),\n/* harmony export */   decodeArray: () => (/* binding */ decodeArray),\n/* harmony export */   decodeBool: () => (/* binding */ decodeBool),\n/* harmony export */   decodeBytes: () => (/* binding */ decodeBytes),\n/* harmony export */   decodeNumber: () => (/* binding */ decodeNumber),\n/* harmony export */   decodeParameter: () => (/* binding */ decodeParameter),\n/* harmony export */   decodeString: () => (/* binding */ decodeString),\n/* harmony export */   decodeTuple: () => (/* binding */ decodeTuple),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeAddress: () => (/* binding */ encodeAddress),\n/* harmony export */   encodeArray: () => (/* binding */ encodeArray),\n/* harmony export */   encodeBoolean: () => (/* binding */ encodeBoolean),\n/* harmony export */   encodeBytes: () => (/* binding */ encodeBytes),\n/* harmony export */   encodeNumber: () => (/* binding */ encodeNumber),\n/* harmony export */   encodeString: () => (/* binding */ encodeString),\n/* harmony export */   encodeTuple: () => (/* binding */ encodeTuple),\n/* harmony export */   getArrayComponents: () => (/* binding */ getArrayComponents),\n/* harmony export */   hasDynamicChild: () => (/* binding */ hasDynamicChild),\n/* harmony export */   prepareParameter: () => (/* binding */ prepareParameter),\n/* harmony export */   prepareParameters: () => (/* binding */ prepareParameters)\n/* harmony export */ });\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Solidity.js */ \"(ssr)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/** @internal */\nfunction decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { checksumAddress, length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, {\n            checksumAddress,\n            staticPosition,\n        });\n    if (param.type === 'address')\n        return decodeAddress(cursor, { checksum: checksumAddress });\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nfunction decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address) => checksum ? _Address_js__WEBPACK_IMPORTED_MODULE_1__.checksum(address) : address;\n    return [wrap(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.slice(value, -20))), 32];\n}\n/** @internal */\nfunction decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\n/** @internal */\nfunction decodeBool(cursor) {\n    return [_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBoolean(cursor.readBytes(32), { size: 32 }), 32];\n}\n/** @internal */\nfunction decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data), 32];\n    }\n    const value = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32));\n    return [value, 32];\n}\n/** @internal */\nfunction decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256', 10);\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBigInt(value, { signed })\n            : _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(value, { signed }),\n        32,\n    ];\n}\n/** @internal */\nfunction decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\n/** @internal */\nfunction decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toString(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\n/** @internal */\nfunction prepareParameters({ checksumAddress, parameters, values, }) {\n    const preparedParameters = [];\n    for (let i = 0; i < parameters.length; i++) {\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i],\n        }));\n    }\n    return preparedParameters;\n}\n/** @internal */\nfunction prepareParameter({ checksumAddress = false, parameter: parameter_, value, }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type,\n            },\n        });\n    }\n    if (parameter.type === 'tuple') {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter,\n        });\n    }\n    if (parameter.type === 'address') {\n        return encodeAddress(value, {\n            checksum: checksumAddress,\n        });\n    }\n    if (parameter.type === 'bool') {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n        const signed = parameter.type.startsWith('int');\n        const [, , size = '256'] = _Solidity_js__WEBPACK_IMPORTED_MODULE_4__.integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (parameter.type.startsWith('bytes')) {\n        return encodeBytes(value, { type: parameter.type });\n    }\n    if (parameter.type === 'string') {\n        return encodeString(value);\n    }\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(parameter.type);\n}\n/** @internal */\nfunction encode(preparedParameters) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(staticSize + dynamicSize, { size: 32 }));\n            dynamicParameters.push(encoded);\n            dynamicSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n        }\n        else {\n            staticParameters.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nfunction encodeAddress(value, options) {\n    const { checksum = false } = options;\n    _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(value, { strict: checksum });\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(value.toLowerCase()),\n    };\n}\n/** @internal */\nfunction encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.ArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${parameter.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i],\n        });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(preparedParameters.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(length, data) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nfunction encodeBytes(value, { type }) {\n    const [, parametersize] = type.split('bytes');\n    const bytesSize = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(bytesSize, { size: 32 })), value_),\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize, 10))\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.BytesSizeMismatchError({\n            expectedSize: Number.parseInt(parametersize, 10),\n            value,\n        });\n    return { dynamic: false, encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value) };\n}\n/** @internal */\nfunction encodeBoolean(value) {\n    if (typeof value !== 'boolean')\n        throw new _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value)) };\n}\n/** @internal */\nfunction encodeNumber(value, { signed, size }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new _Hex_js__WEBPACK_IMPORTED_MODULE_2__.IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\n/** @internal */\nfunction encodeString(value) {\n    const hexValue = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n    const partsLength = Math.ceil(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue), { size: 32 })), ...parts),\n    };\n}\n/** @internal */\nfunction encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for (let i = 0; i < parameter.components.length; i++) {\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index],\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encode(preparedParameters)\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nfunction getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n/** @internal */\nfunction hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({\n            ...param,\n            type: arrayComponents[1],\n        }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=abiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaVBhcmFtZXRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDWjtBQUNKO0FBQ0U7QUFDTjtBQUNhO0FBQzlDO0FBQ087QUFDUCxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCLElBQUkseUNBQXlDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RCxjQUFjLCtEQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNPLDJDQUEyQztBQUNsRCxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBLHlDQUF5QyxpREFBZ0I7QUFDekQsaUJBQWlCLDhDQUFhLENBQUMsNENBQVc7QUFDMUM7QUFDQTtBQUNPO0FBQ1AsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FB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O0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBVSw4QkFBOEIsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYWJpUGFyYW1ldGVycy5qcz85NTMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi4vQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4uL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4uL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vSGV4LmpzJztcbmltcG9ydCB7IGludGVnZXJSZWdleCB9IGZyb20gJy4uL1NvbGlkaXR5LmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBzdGF0aWNQb3NpdGlvbiB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBhcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHMocGFyYW0udHlwZSk7XG4gICAgaWYgKGFycmF5Q29tcG9uZW50cykge1xuICAgICAgICBjb25zdCBbbGVuZ3RoLCB0eXBlXSA9IGFycmF5Q29tcG9uZW50cztcbiAgICAgICAgcmV0dXJuIGRlY29kZUFycmF5KGN1cnNvciwgeyAuLi5wYXJhbSwgdHlwZSB9LCB7IGNoZWNrc3VtQWRkcmVzcywgbGVuZ3RoLCBzdGF0aWNQb3NpdGlvbiB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICd0dXBsZScpXG4gICAgICAgIHJldHVybiBkZWNvZGVUdXBsZShjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBzdGF0aWNQb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICdhZGRyZXNzJylcbiAgICAgICAgcmV0dXJuIGRlY29kZUFkZHJlc3MoY3Vyc29yLCB7IGNoZWNrc3VtOiBjaGVja3N1bUFkZHJlc3MgfSk7XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICdib29sJylcbiAgICAgICAgcmV0dXJuIGRlY29kZUJvb2woY3Vyc29yKTtcbiAgICBpZiAocGFyYW0udHlwZS5zdGFydHNXaXRoKCdieXRlcycpKVxuICAgICAgICByZXR1cm4gZGVjb2RlQnl0ZXMoY3Vyc29yLCBwYXJhbSwgeyBzdGF0aWNQb3NpdGlvbiB9KTtcbiAgICBpZiAocGFyYW0udHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgcGFyYW0udHlwZS5zdGFydHNXaXRoKCdpbnQnKSlcbiAgICAgICAgcmV0dXJuIGRlY29kZU51bWJlcihjdXJzb3IsIHBhcmFtKTtcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBkZWNvZGVTdHJpbmcoY3Vyc29yLCB7IHN0YXRpY1Bvc2l0aW9uIH0pO1xuICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3IocGFyYW0udHlwZSk7XG59XG5jb25zdCBzaXplT2ZMZW5ndGggPSAzMjtcbmNvbnN0IHNpemVPZk9mZnNldCA9IDMyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFkZHJlc3MoY3Vyc29yLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBjdXJzb3IucmVhZEJ5dGVzKDMyKTtcbiAgICBjb25zdCB3cmFwID0gKGFkZHJlc3MpID0+IGNoZWNrc3VtID8gQWRkcmVzcy5jaGVja3N1bShhZGRyZXNzKSA6IGFkZHJlc3M7XG4gICAgcmV0dXJuIFt3cmFwKEhleC5mcm9tQnl0ZXMoQnl0ZXMuc2xpY2UodmFsdWUsIC0yMCkpKSwgMzJdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUFycmF5KGN1cnNvciwgcGFyYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcywgbGVuZ3RoLCBzdGF0aWNQb3NpdGlvbiB9ID0gb3B0aW9ucztcbiAgICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBpcyBub3Qga25vd24gaW4gYWR2YW5jZSAoZHluYW1pYyBhcnJheSksXG4gICAgLy8gdGhpcyBtZWFucyB3ZSB3aWxsIG5lZWQgdG8gd29uZGVyIG9mZiB0byB0aGUgcG9pbnRlciBhbmQgZGVjb2RlLlxuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBhIGR5bmFtaWMgdHlwZSwgc28gZ2V0IHRoZSBvZmZzZXQgb2YgdGhlIGFycmF5IGRhdGEuXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mT2Zmc2V0KSk7XG4gICAgICAgIC8vIFN0YXJ0IGlzIHRoZSBzdGF0aWMgcG9zaXRpb24gb2YgY3VycmVudCBzbG90ICsgb2Zmc2V0LlxuICAgICAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICBjb25zdCBzdGFydE9mRGF0YSA9IHN0YXJ0ICsgc2l6ZU9mTGVuZ3RoO1xuICAgICAgICAvLyBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgZnJvbSB0aGUgb2Zmc2V0LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKHNpemVPZkxlbmd0aCkpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXJyYXkgaGFzIGFueSBkeW5hbWljIGNoaWxkcmVuLlxuICAgICAgICBjb25zdCBkeW5hbWljQ2hpbGQgPSBoYXNEeW5hbWljQ2hpbGQocGFyYW0pO1xuICAgICAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIGNoaWxkcmVuIGlzIGR5bmFtaWMsIHRoZW4gYWxsIGVsZW1lbnRzIHdpbGwgYmUgb2Zmc2V0IHBvaW50ZXIsIHRodXMgc2l6ZSBvZiBvbmUgc2xvdCAoMzIgYnl0ZXMpLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBlbGVtZW50cyB3aWxsIGJlIHRoZSBzaXplIG9mIHRoZWlyIGVuY29kaW5nIChjb25zdW1lZCBieXRlcykuXG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnRPZkRhdGEgKyAoZHluYW1pY0NoaWxkID8gaSAqIDMyIDogY29uc3VtZWQpKTtcbiAgICAgICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IHN0YXJ0T2ZEYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaXMga25vd24gaW4gYWR2YW5jZSxcbiAgICAvLyBhbmQgdGhlIGxlbmd0aCBvZiBhbiBlbGVtZW50IGRlZXBseSBuZXN0ZWQgaW4gdGhlIGFycmF5IGlzIG5vdCBrbm93bixcbiAgICAvLyB3ZSBuZWVkIHRvIGRlY29kZSB0aGUgb2Zmc2V0IG9mIHRoZSBhcnJheSBkYXRhLlxuICAgIGlmIChoYXNEeW5hbWljQ2hpbGQocGFyYW0pKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBkeW5hbWljIHR5cGVzLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgYXJyYXkgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgLy8gU3RhcnQgaXMgdGhlIHN0YXRpYyBwb3NpdGlvbiBvZiBjdXJyZW50IHNsb3QgKyBvZmZzZXQuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgY3Vyc29yIGFsb25nIHRvIHRoZSBuZXh0IHNsb3QgKG5leHQgb2Zmc2V0IHBvaW50ZXIpLlxuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0ICsgaSAqIDMyKTtcbiAgICAgICAgICAgIGNvbnN0IFtkYXRhXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGFydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWUucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGlzIGtub3duIGluIGFkdmFuY2UgYW5kIHRoZSBhcnJheSBpcyBkZWVwbHkgc3RhdGljLFxuICAgIC8vIHRoZW4gd2UgY2FuIGp1c3QgZGVjb2RlIGVhY2ggZWxlbWVudCBpbiBzZXF1ZW5jZS5cbiAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhdGljUG9zaXRpb24gKyBjb25zdW1lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgdmFsdWUucHVzaChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIFt2YWx1ZSwgY29uc3VtZWRdO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUJvb2woY3Vyc29yKSB7XG4gICAgcmV0dXJuIFtCeXRlcy50b0Jvb2xlYW4oY3Vyc29yLnJlYWRCeXRlcygzMiksIHsgc2l6ZTogMzIgfSksIDMyXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCeXRlcyhjdXJzb3IsIHBhcmFtLCB7IHN0YXRpY1Bvc2l0aW9uIH0pIHtcbiAgICBjb25zdCBbXywgc2l6ZV0gPSBwYXJhbS50eXBlLnNwbGl0KCdieXRlcycpO1xuICAgIGlmICghc2l6ZSkge1xuICAgICAgICAvLyBEZWFsaW5nIHdpdGggZHluYW1pYyB0eXBlcywgc28gZ2V0IHRoZSBvZmZzZXQgb2YgdGhlIGJ5dGVzIGRhdGEuXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAgICAgLy8gU2V0IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3IgdG8gc3RhcnQgb2YgYnl0ZXMgZGF0YS5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBsZW5ndGgsIHdlIGhhdmUgemVybyBkYXRhLlxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgICAgIHJldHVybiBbJzB4JywgMzJdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjdXJzb3IucmVhZEJ5dGVzKGxlbmd0aCk7XG4gICAgICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbSGV4LmZyb21CeXRlcyhkYXRhKSwgMzJdO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IEhleC5mcm9tQnl0ZXMoY3Vyc29yLnJlYWRCeXRlcyhOdW1iZXIucGFyc2VJbnQoc2l6ZSwgMTApLCAzMikpO1xuICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVOdW1iZXIoY3Vyc29yLCBwYXJhbSkge1xuICAgIGNvbnN0IHNpZ25lZCA9IHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgnaW50Jyk7XG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlci5wYXJzZUludChwYXJhbS50eXBlLnNwbGl0KCdpbnQnKVsxXSB8fCAnMjU2JywgMTApO1xuICAgIGNvbnN0IHZhbHVlID0gY3Vyc29yLnJlYWRCeXRlcygzMik7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc2l6ZSA+IDQ4XG4gICAgICAgICAgICA/IEJ5dGVzLnRvQmlnSW50KHZhbHVlLCB7IHNpZ25lZCB9KVxuICAgICAgICAgICAgOiBCeXRlcy50b051bWJlcih2YWx1ZSwgeyBzaWduZWQgfSksXG4gICAgICAgIDMyLFxuICAgIF07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVHVwbGUoY3Vyc29yLCBwYXJhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBzdGF0aWNQb3NpdGlvbiB9ID0gb3B0aW9ucztcbiAgICAvLyBUdXBsZXMgY2FuIGhhdmUgdW5uYW1lZCBjb21wb25lbnRzIChpLmUuIHRoZXkgYXJlIGFycmF5cyksIHNvIHdlIG11c3RcbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgdHVwbGUgaXMgbmFtZWQgb3IgdW5uYW1lZC4gSW4gdGhlIGNhc2Ugb2YgYSBuYW1lZFxuICAgIC8vIHR1cGxlLCB0aGUgdmFsdWUgd2lsbCBiZSBhbiBvYmplY3Qgd2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyB0aGUgbmFtZSBvZiB0aGVcbiAgICAvLyBjb21wb25lbnQuIEluIHRoZSBjYXNlIG9mIGFuIHVubmFtZWQgdHVwbGUsIHRoZSB2YWx1ZSB3aWxsIGJlIGFuIGFycmF5LlxuICAgIGNvbnN0IGhhc1VubmFtZWRDaGlsZCA9IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoID09PSAwIHx8IHBhcmFtLmNvbXBvbmVudHMuc29tZSgoeyBuYW1lIH0pID0+ICFuYW1lKTtcbiAgICAvLyBJbml0aWFsaXplIHRoZSB2YWx1ZSB0byBhbiBvYmplY3Qgb3IgYW4gYXJyYXksIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZVxuICAgIC8vIHR1cGxlIGlzIG5hbWVkIG9yIHVubmFtZWQuXG4gICAgY29uc3QgdmFsdWUgPSBoYXNVbm5hbWVkQ2hpbGQgPyBbXSA6IHt9O1xuICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgLy8gSWYgdGhlIHR1cGxlIGhhcyBhIGR5bmFtaWMgY2hpbGQsIHdlIG11c3QgZmlyc3QgZGVjb2RlIHRoZSBvZmZzZXQgdG8gdGhlXG4gICAgLy8gdHVwbGUgZGF0YS5cbiAgICBpZiAoaGFzRHluYW1pY0NoaWxkKHBhcmFtKSkge1xuICAgICAgICAvLyBEZWFsaW5nIHdpdGggZHluYW1pYyB0eXBlcywgc28gZ2V0IHRoZSBvZmZzZXQgb2YgdGhlIHR1cGxlIGRhdGEuXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mT2Zmc2V0KSk7XG4gICAgICAgIC8vIFN0YXJ0IGlzIHRoZSBzdGF0aWMgcG9zaXRpb24gb2YgcmVmZXJlbmNpbmcgc2xvdCArIG9mZnNldC5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbS5jb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBwYXJhbS5jb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0ICsgY29uc3VtZWQpO1xuICAgICAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBjb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IHN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgICAgICAgICB2YWx1ZVtoYXNVbm5hbWVkQ2hpbGQgPyBpIDogY29tcG9uZW50Py5uYW1lXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgdHVwbGUgaGFzIHN0YXRpYyBjaGlsZHJlbiwgd2UgY2FuIGp1c3QgZGVjb2RlIGVhY2ggY29tcG9uZW50XG4gICAgLy8gaW4gc2VxdWVuY2UuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbS5jb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHBhcmFtLmNvbXBvbmVudHNbaV07XG4gICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgY29tcG9uZW50LCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBzdGF0aWNQb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbHVlW2hhc1VubmFtZWRDaGlsZCA/IGkgOiBjb21wb25lbnQ/Lm5hbWVdID0gZGF0YTtcbiAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgIH1cbiAgICByZXR1cm4gW3ZhbHVlLCBjb25zdW1lZF07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlU3RyaW5nKGN1cnNvciwgeyBzdGF0aWNQb3NpdGlvbiB9KSB7XG4gICAgLy8gR2V0IG9mZnNldCB0byBzdGFydCBvZiBzdHJpbmcgZGF0YS5cbiAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XG4gICAgLy8gU3RhcnQgaXMgdGhlIHN0YXRpYyBwb3NpdGlvbiBvZiBjdXJyZW50IHNsb3QgKyBvZmZzZXQuXG4gICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcbiAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBsZW5ndGgsIHdlIGhhdmUgemVybyBkYXRhIChlbXB0eSBzdHJpbmcpLlxuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gWycnLCAzMl07XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBjdXJzb3IucmVhZEJ5dGVzKGxlbmd0aCwgMzIpO1xuICAgIGNvbnN0IHZhbHVlID0gQnl0ZXMudG9TdHJpbmcoQnl0ZXMudHJpbUxlZnQoZGF0YSkpO1xuICAgIC8vIEFzIHdlIGhhdmUgZ29uZSB3b25kZXJpbmcsIHJlc3RvcmUgdG8gdGhlIG9yaWdpbmFsIHBvc2l0aW9uICsgbmV4dCBzbG90LlxuICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZVBhcmFtZXRlcnMoeyBjaGVja3N1bUFkZHJlc3MsIHBhcmFtZXRlcnMsIHZhbHVlcywgfSkge1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVwYXJlZFBhcmFtZXRlcnMucHVzaChwcmVwYXJlUGFyYW1ldGVyKHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogcGFyYW1ldGVyc1tpXSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNbaV0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXBhcmVkUGFyYW1ldGVycztcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlUGFyYW1ldGVyKHsgY2hlY2tzdW1BZGRyZXNzID0gZmFsc2UsIHBhcmFtZXRlcjogcGFyYW1ldGVyXywgdmFsdWUsIH0pIHtcbiAgICBjb25zdCBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJfO1xuICAgIGNvbnN0IGFycmF5Q29tcG9uZW50cyA9IGdldEFycmF5Q29tcG9uZW50cyhwYXJhbWV0ZXIudHlwZSk7XG4gICAgaWYgKGFycmF5Q29tcG9uZW50cykge1xuICAgICAgICBjb25zdCBbbGVuZ3RoLCB0eXBlXSA9IGFycmF5Q29tcG9uZW50cztcbiAgICAgICAgcmV0dXJuIGVuY29kZUFycmF5KHZhbHVlLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHtcbiAgICAgICAgICAgICAgICAuLi5wYXJhbWV0ZXIsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICd0dXBsZScpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVR1cGxlKHZhbHVlLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHBhcmFtZXRlcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVBZGRyZXNzKHZhbHVlLCB7XG4gICAgICAgICAgICBjaGVja3N1bTogY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJvb2xlYW4odmFsdWUpO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgndWludCcpIHx8IHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ2ludCcpO1xuICAgICAgICBjb25zdCBbLCAsIHNpemUgPSAnMjU2J10gPSBpbnRlZ2VyUmVnZXguZXhlYyhwYXJhbWV0ZXIudHlwZSkgPz8gW107XG4gICAgICAgIHJldHVybiBlbmNvZGVOdW1iZXIodmFsdWUsIHtcbiAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgIHNpemU6IE51bWJlcihzaXplKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCeXRlcyh2YWx1ZSwgeyB0eXBlOiBwYXJhbWV0ZXIudHlwZSB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuSW52YWxpZFR5cGVFcnJvcihwYXJhbWV0ZXIudHlwZSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycykge1xuICAgIC8vIDEuIENvbXB1dGUgdGhlIHNpemUgb2YgdGhlIHN0YXRpYyBwYXJ0IG9mIHRoZSBwYXJhbWV0ZXJzLlxuICAgIGxldCBzdGF0aWNTaXplID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXBhcmVkUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGR5bmFtaWMsIGVuY29kZWQgfSA9IHByZXBhcmVkUGFyYW1ldGVyc1tpXTtcbiAgICAgICAgaWYgKGR5bmFtaWMpXG4gICAgICAgICAgICBzdGF0aWNTaXplICs9IDMyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdGF0aWNTaXplICs9IEhleC5zaXplKGVuY29kZWQpO1xuICAgIH1cbiAgICAvLyAyLiBTcGxpdCB0aGUgcGFyYW1ldGVycyBpbnRvIHN0YXRpYyBhbmQgZHluYW1pYyBwYXJ0cy5cbiAgICBjb25zdCBzdGF0aWNQYXJhbWV0ZXJzID0gW107XG4gICAgY29uc3QgZHluYW1pY1BhcmFtZXRlcnMgPSBbXTtcbiAgICBsZXQgZHluYW1pY1NpemUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgZHluYW1pYywgZW5jb2RlZCB9ID0gcHJlcGFyZWRQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgc3RhdGljUGFyYW1ldGVycy5wdXNoKEhleC5mcm9tTnVtYmVyKHN0YXRpY1NpemUgKyBkeW5hbWljU2l6ZSwgeyBzaXplOiAzMiB9KSk7XG4gICAgICAgICAgICBkeW5hbWljUGFyYW1ldGVycy5wdXNoKGVuY29kZWQpO1xuICAgICAgICAgICAgZHluYW1pY1NpemUgKz0gSGV4LnNpemUoZW5jb2RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0aWNQYXJhbWV0ZXJzLnB1c2goZW5jb2RlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMy4gQ29uY2F0ZW5hdGUgc3RhdGljIGFuZCBkeW5hbWljIHBhcnRzLlxuICAgIHJldHVybiBIZXguY29uY2F0KC4uLnN0YXRpY1BhcmFtZXRlcnMsIC4uLmR5bmFtaWNQYXJhbWV0ZXJzKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVBZGRyZXNzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIEFkZHJlc3MuYXNzZXJ0KHZhbHVlLCB7IHN0cmljdDogY2hlY2tzdW0gfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgIGVuY29kZWQ6IEhleC5wYWRMZWZ0KHZhbHVlLnRvTG93ZXJDYXNlKCkpLFxuICAgIH07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQXJyYXkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcywgbGVuZ3RoLCBwYXJhbWV0ZXIgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZHluYW1pYyA9IGxlbmd0aCA9PT0gbnVsbDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5JbnZhbGlkQXJyYXlFcnJvcih2YWx1ZSk7XG4gICAgaWYgKCFkeW5hbWljICYmIHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5BcnJheUxlbmd0aE1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IGxlbmd0aCxcbiAgICAgICAgICAgIGdpdmVuTGVuZ3RoOiB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgICB0eXBlOiBgJHtwYXJhbWV0ZXIudHlwZX1bJHtsZW5ndGh9XWAsXG4gICAgICAgIH0pO1xuICAgIGxldCBkeW5hbWljQ2hpbGQgPSBmYWxzZTtcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkUGFyYW0gPSBwcmVwYXJlUGFyYW1ldGVyKHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHBhcmFtZXRlcixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmVwYXJlZFBhcmFtLmR5bmFtaWMpXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGQgPSB0cnVlO1xuICAgICAgICBwcmVwYXJlZFBhcmFtZXRlcnMucHVzaChwcmVwYXJlZFBhcmFtKTtcbiAgICB9XG4gICAgaWYgKGR5bmFtaWMgfHwgZHluYW1pY0NoaWxkKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IEhleC5mcm9tTnVtYmVyKHByZXBhcmVkUGFyYW1ldGVycy5sZW5ndGgsIHsgc2l6ZTogMzIgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICAgICAgICAgICAgZW5jb2RlZDogcHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aCA+IDAgPyBIZXguY29uY2F0KGxlbmd0aCwgZGF0YSkgOiBsZW5ndGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkeW5hbWljQ2hpbGQpXG4gICAgICAgICAgICByZXR1cm4geyBkeW5hbWljOiB0cnVlLCBlbmNvZGVkOiBkYXRhIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICBlbmNvZGVkOiBIZXguY29uY2F0KC4uLnByZXBhcmVkUGFyYW1ldGVycy5tYXAoKHsgZW5jb2RlZCB9KSA9PiBlbmNvZGVkKSksXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVCeXRlcyh2YWx1ZSwgeyB0eXBlIH0pIHtcbiAgICBjb25zdCBbLCBwYXJhbWV0ZXJzaXplXSA9IHR5cGUuc3BsaXQoJ2J5dGVzJyk7XG4gICAgY29uc3QgYnl0ZXNTaXplID0gSGV4LnNpemUodmFsdWUpO1xuICAgIGlmICghcGFyYW1ldGVyc2l6ZSkge1xuICAgICAgICBsZXQgdmFsdWVfID0gdmFsdWU7XG4gICAgICAgIC8vIElmIHRoZSBzaXplIGlzIG5vdCBkaXZpc2libGUgYnkgMzIgYnl0ZXMsIHBhZCB0aGUgZW5kXG4gICAgICAgIC8vIHdpdGggZW1wdHkgYnl0ZXMgdG8gdGhlIGNlaWxpbmcgMzIgYnl0ZXMuXG4gICAgICAgIGlmIChieXRlc1NpemUgJSAzMiAhPT0gMClcbiAgICAgICAgICAgIHZhbHVlXyA9IEhleC5wYWRSaWdodCh2YWx1ZV8sIE1hdGguY2VpbCgodmFsdWUubGVuZ3RoIC0gMikgLyAyIC8gMzIpICogMzIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoSGV4LnBhZExlZnQoSGV4LmZyb21OdW1iZXIoYnl0ZXNTaXplLCB7IHNpemU6IDMyIH0pKSwgdmFsdWVfKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzU2l6ZSAhPT0gTnVtYmVyLnBhcnNlSW50KHBhcmFtZXRlcnNpemUsIDEwKSlcbiAgICAgICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZFNpemU6IE51bWJlci5wYXJzZUludChwYXJhbWV0ZXJzaXplLCAxMCksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIHsgZHluYW1pYzogZmFsc2UsIGVuY29kZWQ6IEhleC5wYWRSaWdodCh2YWx1ZSkgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVCb29sZWFuKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcihgSW52YWxpZCBib29sZWFuIHZhbHVlOiBcIiR7dmFsdWV9XCIgKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkuIEV4cGVjdGVkOiBcXGB0cnVlXFxgIG9yIFxcYGZhbHNlXFxgLmApO1xuICAgIHJldHVybiB7IGR5bmFtaWM6IGZhbHNlLCBlbmNvZGVkOiBIZXgucGFkTGVmdChIZXguZnJvbUJvb2xlYW4odmFsdWUpKSB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZU51bWJlcih2YWx1ZSwgeyBzaWduZWQsIHNpemUgfSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgbWF4ID0gMm4gKiogKEJpZ0ludChzaXplKSAtIChzaWduZWQgPyAxbiA6IDBuKSkgLSAxbjtcbiAgICAgICAgY29uc3QgbWluID0gc2lnbmVkID8gLW1heCAtIDFuIDogMG47XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbilcbiAgICAgICAgICAgIHRocm93IG5ldyBIZXguSW50ZWdlck91dE9mUmFuZ2VFcnJvcih7XG4gICAgICAgICAgICAgICAgbWF4OiBtYXgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBtaW46IG1pbi50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplIC8gOCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LmZyb21OdW1iZXIodmFsdWUsIHtcbiAgICAgICAgICAgIHNpemU6IDMyLFxuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVN0cmluZyh2YWx1ZSkge1xuICAgIGNvbnN0IGhleFZhbHVlID0gSGV4LmZyb21TdHJpbmcodmFsdWUpO1xuICAgIGNvbnN0IHBhcnRzTGVuZ3RoID0gTWF0aC5jZWlsKEhleC5zaXplKGhleFZhbHVlKSAvIDMyKTtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHNMZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJ0cy5wdXNoKEhleC5wYWRSaWdodChIZXguc2xpY2UoaGV4VmFsdWUsIGkgKiAzMiwgKGkgKyAxKSAqIDMyKSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICBlbmNvZGVkOiBIZXguY29uY2F0KEhleC5wYWRSaWdodChIZXguZnJvbU51bWJlcihIZXguc2l6ZShoZXhWYWx1ZSksIHsgc2l6ZTogMzIgfSkpLCAuLi5wYXJ0cyksXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVUdXBsZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBwYXJhbWV0ZXIgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlci5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtXyA9IHBhcmFtZXRlci5jb21wb25lbnRzW2ldO1xuICAgICAgICBjb25zdCBpbmRleCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gaSA6IHBhcmFtXy5uYW1lO1xuICAgICAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtZXRlcih7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHBhcmFtXyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpbmRleF0sXG4gICAgICAgIH0pO1xuICAgICAgICBwcmVwYXJlZFBhcmFtZXRlcnMucHVzaChwcmVwYXJlZFBhcmFtKTtcbiAgICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcbiAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljLFxuICAgICAgICBlbmNvZGVkOiBkeW5hbWljXG4gICAgICAgICAgICA/IGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpXG4gICAgICAgICAgICA6IEhleC5jb25jYXQoLi4ucHJlcGFyZWRQYXJhbWV0ZXJzLm1hcCgoeyBlbmNvZGVkIH0pID0+IGVuY29kZWQpKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFycmF5Q29tcG9uZW50cyh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHR5cGUubWF0Y2goL14oLiopXFxbKFxcZCspP1xcXSQvKTtcbiAgICByZXR1cm4gbWF0Y2hlc1xuICAgICAgICA/IC8vIFJldHVybiBgbnVsbGAgaWYgdGhlIGFycmF5IGlzIGR5bmFtaWMuXG4gICAgICAgICAgICBbbWF0Y2hlc1syXSA/IE51bWJlcihtYXRjaGVzWzJdKSA6IG51bGwsIG1hdGNoZXNbMV1dXG4gICAgICAgIDogdW5kZWZpbmVkO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0R5bmFtaWNDaGlsZChwYXJhbSkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gcGFyYW07XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUuZW5kc1dpdGgoJ1tdJykpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlID09PSAndHVwbGUnKVxuICAgICAgICByZXR1cm4gcGFyYW0uY29tcG9uZW50cz8uc29tZShoYXNEeW5hbWljQ2hpbGQpO1xuICAgIGNvbnN0IGFycmF5Q29tcG9uZW50cyA9IGdldEFycmF5Q29tcG9uZW50cyhwYXJhbS50eXBlKTtcbiAgICBpZiAoYXJyYXlDb21wb25lbnRzICYmXG4gICAgICAgIGhhc0R5bmFtaWNDaGlsZCh7XG4gICAgICAgICAgICAuLi5wYXJhbSxcbiAgICAgICAgICAgIHR5cGU6IGFycmF5Q29tcG9uZW50c1sxXSxcbiAgICAgICAgfSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaVBhcmFtZXRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/abiParameters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   charCodeMap: () => (/* binding */ charCodeMap),\n/* harmony export */   charCodeToBase16: () => (/* binding */ charCodeToBase16),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n\n/** @internal */\nfunction assertSize(bytes, size_) {\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) > size_)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\n/** @internal */\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */\nfunction pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ3JDO0FBQ087QUFDUCxRQUFRLDJDQUFVO0FBQ2xCLGtCQUFrQix3REFBdUI7QUFDekMsdUJBQXVCLDJDQUFVO0FBQ2pDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLDBEQUEwRCwyQ0FBVTtBQUNwRSxrQkFBa0Isa0VBQWlDO0FBQ25EO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQVU7QUFDNUIsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLDJDQUFVO0FBQ2xCLGtCQUFrQixrRUFBaUM7QUFDbkQ7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBVTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0M7QUFDdkMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQztBQUN4QyxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzP2EwNDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi4vQnl0ZXMuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNpemUoYnl0ZXMsIHNpemVfKSB7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpID4gc2l6ZV8pXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICAgICAgbWF4U2l6ZTogc2l6ZV8sXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHN0YXJ0ID4gMCAmJiBzdGFydCA+IEJ5dGVzLnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgQnl0ZXMuc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBlbmQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGNoYXJDb2RlTWFwID0ge1xuICAgIHplcm86IDQ4LFxuICAgIG5pbmU6IDU3LFxuICAgIEE6IDY1LFxuICAgIEY6IDcwLFxuICAgIGE6IDk3LFxuICAgIGY6IDEwMixcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gY2hhckNvZGVUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuemVybyAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLm5pbmUpXG4gICAgICAgIHJldHVybiBjaGFyIC0gY2hhckNvZGVNYXAuemVybztcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5BICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5hICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuYSAtIDEwKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIGlmIChieXRlcy5sZW5ndGggPiBzaXplKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnQnl0ZXMnLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gJ3JpZ2h0JztcbiAgICAgICAgcGFkZGVkQnl0ZXNbcGFkRW5kID8gaSA6IHNpemUgLSBpIC0gMV0gPVxuICAgICAgICAgICAgYnl0ZXNbcGFkRW5kID8gaSA6IGJ5dGVzLmxlbmd0aCAtIGkgLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gJ2xlZnQnIH0gPSBvcHRpb25zO1xuICAgIGxldCBkYXRhID0gdmFsdWU7XG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2RpciA9PT0gJ2xlZnQnID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09ICcwJylcbiAgICAgICAgICAgIHNsaWNlTGVuZ3RoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXRhID1cbiAgICAgICAgZGlyID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gZGF0YS5zbGljZShzbGljZUxlbmd0aClcbiAgICAgICAgICAgIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/cursor.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/cursor.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NegativeOffsetError: () => (/* binding */ NegativeOffsetError),\n/* harmony export */   PositionOutOfBoundsError: () => (/* binding */ PositionOutOfBoundsError),\n/* harmony export */   RecursiveReadLimitExceededError: () => (/* binding */ RecursiveReadLimitExceededError),\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n\nconst staticCursor = {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n        if (this.recursiveReadCount >= this.recursiveReadLimit)\n            throw new RecursiveReadLimitExceededError({\n                count: this.recursiveReadCount + 1,\n                limit: this.recursiveReadLimit,\n            });\n    },\n    assertPosition(position) {\n        if (position < 0 || position > this.bytes.length - 1)\n            throw new PositionOutOfBoundsError({\n                length: this.bytes.length,\n                position,\n            });\n    },\n    decrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount(position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return ((this.dataView.getUint16(position) << 8) +\n            this.dataView.getUint8(position + 2));\n    },\n    inspectUint32(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes(bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8(value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16(value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24(value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32(value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes(length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining() {\n        return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return () => (this.position = oldPosition);\n    },\n    _touch() {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n            return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0)\n            this.recursiveReadCount++;\n    },\n};\n/** @internal */\nfunction create(bytes, { recursiveReadLimit = 8_192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n/** @internal */\nclass NegativeOffsetError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ offset }) {\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.NegativeOffsetError'\n        });\n    }\n}\n/** @internal */\nclass PositionOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ length, position }) {\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.PositionOutOfBoundsError'\n        });\n    }\n}\n/** @internal */\nclass RecursiveReadLimitExceededError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ count, limit }) {\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.RecursiveReadLimitExceededError'\n        });\n    }\n}\n//# sourceMappingURL=cursor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2N1cnNvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPLHlCQUF5Qiw2QkFBNkIsSUFBSTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLGlEQUFnQjtBQUN6RCxrQkFBa0IsUUFBUTtBQUMxQiwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QyxpREFBZ0I7QUFDOUQsa0JBQWtCLGtCQUFrQjtBQUNwQyw0QkFBNEIsU0FBUyx3Q0FBd0MsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLDhDQUE4QyxpREFBZ0I7QUFDckUsa0JBQWtCLGNBQWM7QUFDaEMsMkNBQTJDLE1BQU0sdUNBQXVDLE1BQU07QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvY3Vyc29yLmpzPzljMjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4uL0Vycm9ycy5qcyc7XG5jb25zdCBzdGF0aWNDdXJzb3IgPSB7XG4gICAgYnl0ZXM6IG5ldyBVaW50OEFycmF5KCksXG4gICAgZGF0YVZpZXc6IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpLFxuICAgIHBvc2l0aW9uOiAwLFxuICAgIHBvc2l0aW9uUmVhZENvdW50OiBuZXcgTWFwKCksXG4gICAgcmVjdXJzaXZlUmVhZENvdW50OiAwLFxuICAgIHJlY3Vyc2l2ZVJlYWRMaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGFzc2VydFJlYWRMaW1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjdXJzaXZlUmVhZENvdW50ID49IHRoaXMucmVjdXJzaXZlUmVhZExpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvdW50OiB0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCArIDEsXG4gICAgICAgICAgICAgICAgbGltaXQ6IHRoaXMucmVjdXJzaXZlUmVhZExpbWl0LFxuICAgICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBhc3NlcnRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID4gdGhpcy5ieXRlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLmJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVjcmVtZW50UG9zaXRpb24ob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5lZ2F0aXZlT2Zmc2V0RXJyb3IoeyBvZmZzZXQgfSk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiAtIG9mZnNldDtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9LFxuICAgIGdldFJlYWRDb3VudChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvblJlYWRDb3VudC5nZXQocG9zaXRpb24gfHwgdGhpcy5wb3NpdGlvbikgfHwgMDtcbiAgICB9LFxuICAgIGluY3JlbWVudFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBOZWdhdGl2ZU9mZnNldEVycm9yKHsgb2Zmc2V0IH0pO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSxcbiAgICBpbnNwZWN0Qnl0ZShwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzW3Bvc2l0aW9uXTtcbiAgICB9LFxuICAgIGluc3BlY3RCeXRlcyhsZW5ndGgsIHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgbGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDgocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc1twb3NpdGlvbl07XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDE2KHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbik7XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDI0KHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgMik7XG4gICAgICAgIHJldHVybiAoKHRoaXMuZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKSA8PCA4KSArXG4gICAgICAgICAgICB0aGlzLmRhdGFWaWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgMikpO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQzMihwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pO1xuICAgIH0sXG4gICAgcHVzaEJ5dGUoYnl0ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLmJ5dGVzW3RoaXMucG9zaXRpb25dID0gYnl0ZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH0sXG4gICAgcHVzaEJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIGJ5dGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLmJ5dGVzLnNldChieXRlcywgdGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gYnl0ZXMubGVuZ3RoO1xuICAgIH0sXG4gICAgcHVzaFVpbnQ4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH0sXG4gICAgcHVzaFVpbnQxNih2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAxKTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdmFsdWUpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDI7XG4gICAgfSxcbiAgICBwdXNoVWludDI0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIDIpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQxNih0aGlzLnBvc2l0aW9uLCB2YWx1ZSA+PiA4KTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMiwgdmFsdWUgJiB+NDI5NDk2NzA0MCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMztcbiAgICB9LFxuICAgIHB1c2hVaW50MzIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgMyk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDMyKHRoaXMucG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0O1xuICAgIH0sXG4gICAgcmVhZEJ5dGUoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0Qnl0ZSgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRCeXRlcyhsZW5ndGgsIHNpemUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RCeXRlcyhsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IHNpemUgPz8gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDgoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDgoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAxO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDE2KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQxNigpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDI7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50MjQoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDI0KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMztcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQzMigpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50MzIoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQgcmVtYWluaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5sZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xuICAgIH0sXG4gICAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgY29uc3Qgb2xkUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gKCkgPT4gKHRoaXMucG9zaXRpb24gPSBvbGRQb3NpdGlvbik7XG4gICAgfSxcbiAgICBfdG91Y2goKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuZ2V0UmVhZENvdW50KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25SZWFkQ291bnQuc2V0KHRoaXMucG9zaXRpb24sIGNvdW50ICsgMSk7XG4gICAgICAgIGlmIChjb3VudCA+IDApXG4gICAgICAgICAgICB0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCsrO1xuICAgIH0sXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShieXRlcywgeyByZWN1cnNpdmVSZWFkTGltaXQgPSA4XzE5MiB9ID0ge30pIHtcbiAgICBjb25zdCBjdXJzb3IgPSBPYmplY3QuY3JlYXRlKHN0YXRpY0N1cnNvcik7XG4gICAgY3Vyc29yLmJ5dGVzID0gYnl0ZXM7XG4gICAgY3Vyc29yLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgY3Vyc29yLnBvc2l0aW9uUmVhZENvdW50ID0gbmV3IE1hcCgpO1xuICAgIGN1cnNvci5yZWN1cnNpdmVSZWFkTGltaXQgPSByZWN1cnNpdmVSZWFkTGltaXQ7XG4gICAgcmV0dXJuIGN1cnNvcjtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBOZWdhdGl2ZU9mZnNldEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQgfSkge1xuICAgICAgICBzdXBlcihgT2Zmc2V0IFxcYCR7b2Zmc2V0fVxcYCBjYW5ub3QgYmUgbmVnYXRpdmUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDdXJzb3IuTmVnYXRpdmVPZmZzZXRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIFBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbGVuZ3RoLCBwb3NpdGlvbiB9KSB7XG4gICAgICAgIHN1cGVyKGBQb3NpdGlvbiBcXGAke3Bvc2l0aW9ufVxcYCBpcyBvdXQgb2YgYm91bmRzIChcXGAwIDwgcG9zaXRpb24gPCAke2xlbmd0aH1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQ3Vyc29yLlBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIFJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvdW50LCBsaW1pdCB9KSB7XG4gICAgICAgIHN1cGVyKGBSZWN1cnNpdmUgcmVhZCBsaW1pdCBvZiBcXGAke2xpbWl0fVxcYCBleGNlZWRlZCAocmVjdXJzaXZlIHJlYWQgY291bnQ6IFxcYCR7Y291bnR9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5SZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJzb3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/cursor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/entropy.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/entropy.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extraEntropy: () => (/* binding */ extraEntropy),\n/* harmony export */   setExtraEntropy: () => (/* binding */ setExtraEntropy)\n/* harmony export */ });\nlet extraEntropy = false;\n/** @internal */\nfunction setExtraEntropy(entropy) {\n    extraEntropy = entropy;\n}\n//# sourceMappingURL=entropy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2VudHJvcHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvZW50cm9weS5qcz8wOTYyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBsZXQgZXh0cmFFbnRyb3B5ID0gZmFsc2U7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RXh0cmFFbnRyb3B5KGVudHJvcHkpIHtcbiAgICBleHRyYUVudHJvcHkgPSBlbnRyb3B5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW50cm9weS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/entropy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   prettyPrint: () => (/* binding */ prettyPrint)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ \"(ssr)/./node_modules/ox/_esm/core/version.js\");\n\n/** @internal */\nfunction getUrl(url) {\n    return url;\n}\n/** @internal */\nfunction getVersion() {\n    return _version_js__WEBPACK_IMPORTED_MODULE_0__.version;\n}\n/** @internal */\nfunction prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ3hDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsZ0RBQU87QUFDbEI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUcsSUFBSSwyQkFBMkIsRUFBRSxNQUFNO0FBQzlFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lcnJvcnMuanM/YzEyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vdmVyc2lvbi5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKHVybCkge1xuICAgIHJldHVybiB1cmw7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVyc2lvbigpIHtcbiAgICByZXR1cm4gdmVyc2lvbjtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV0dHlQcmludChhcmdzKSB7XG4gICAgaWYgKCFhcmdzKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGFyZ3MpXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IGVudHJpZXMucmVkdWNlKChhY2MsIFtrZXldKSA9PiBNYXRoLm1heChhY2MsIGtleS5sZW5ndGgpLCAwKTtcbiAgICByZXR1cm4gZW50cmllc1xuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAgICR7YCR7a2V5fTpgLnBhZEVuZChtYXhMZW5ndGggKyAxKX0gICR7dmFsdWV9YClcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n/** @internal */\nfunction assertSize(hex, size_) {\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex) > size_)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nfunction pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data === '0')\n        return '0x';\n    if (dir === 'right' && data.length % 2 === 1)\n        return `0x${data}0`;\n    return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUM7QUFDakM7QUFDTztBQUNQLFFBQVEseUNBQVE7QUFDaEIsa0JBQWtCLHNEQUFxQjtBQUN2Qyx1QkFBdUIseUNBQVE7QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsMERBQTBELHlDQUFRO0FBQ2xFLGtCQUFrQixnRUFBK0I7QUFDakQ7QUFDQTtBQUNBLGtCQUFrQix5Q0FBUTtBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFFBQVEseUNBQVE7QUFDaEIsa0JBQWtCLGdFQUErQjtBQUNqRDtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFRO0FBQzFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTywrQkFBK0I7QUFDdEMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsNERBQTREO0FBQzVFO0FBQ0E7QUFDTyxpQ0FBaUM7QUFDeEMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvaGV4LmpzPzcxODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U2l6ZShoZXgsIHNpemVfKSB7XG4gICAgaWYgKEhleC5zaXplKGhleCkgPiBzaXplXylcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEhleC5zaXplKGhleCksXG4gICAgICAgICAgICBtYXhTaXplOiBzaXplXyxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPiAwICYmIHN0YXJ0ID4gSGV4LnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFbmRPZmZzZXQodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBIZXguc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogZW5kLFxuICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgICAgICAgc2l6ZTogSGV4LnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcGFkKGhleF8sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyLCBzaXplID0gMzIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgIHJldHVybiBoZXhfO1xuICAgIGNvbnN0IGhleCA9IGhleF8ucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgaWYgKGhleC5sZW5ndGggPiBzaXplICogMilcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgICAgICAgc2l6ZTogTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnSGV4JyxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIGAweCR7aGV4W2RpciA9PT0gJ3JpZ2h0JyA/ICdwYWRFbmQnIDogJ3BhZFN0YXJ0J10oc2l6ZSAqIDIsICcwJyl9YDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciA9ICdsZWZ0JyB9ID0gb3B0aW9ucztcbiAgICBsZXQgZGF0YSA9IHZhbHVlLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIGxldCBzbGljZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtkaXIgPT09ICdsZWZ0JyA/IGkgOiBkYXRhLmxlbmd0aCAtIGkgLSAxXS50b1N0cmluZygpID09PSAnMCcpXG4gICAgICAgICAgICBzbGljZUxlbmd0aCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZGF0YSA9XG4gICAgICAgIGRpciA9PT0gJ2xlZnQnXG4gICAgICAgICAgICA/IGRhdGEuc2xpY2Uoc2xpY2VMZW5ndGgpXG4gICAgICAgICAgICA6IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBzbGljZUxlbmd0aCk7XG4gICAgaWYgKGRhdGEgPT09ICcwJylcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgaWYgKGRpciA9PT0gJ3JpZ2h0JyAmJiBkYXRhLmxlbmd0aCAlIDIgPT09IDEpXG4gICAgICAgIHJldHVybiBgMHgke2RhdGF9MGA7XG4gICAgcmV0dXJuIGAweCR7ZGF0YX1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/lru.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/lru.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LruMap: () => (/* binding */ LruMap)\n/* harmony export */ });\n/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nclass LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2xydS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvbHJ1LmpzPzU4OGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBNYXAgd2l0aCBhIExSVSAoTGVhc3QgcmVjZW50bHkgdXNlZCkgcG9saWN5LlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWNoZV9yZXBsYWNlbWVudF9wb2xpY2llcyNMUlVcbiAqL1xuZXhwb3J0IGNsYXNzIExydU1hcCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhTaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHN1cGVyLmhhcyhrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm1heFNpemUgJiYgdGhpcy5zaXplID4gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEtleSA9IHRoaXMua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChmaXJzdEtleSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZShmaXJzdEtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bHJ1LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/lru.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/webauthn.js":
/*!********************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/webauthn.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseAsn1Signature: () => (/* binding */ parseAsn1Signature),\n/* harmony export */   parseCredentialPublicKey: () => (/* binding */ parseCredentialPublicKey)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_p256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/p256 */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/p256.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PublicKey.js */ \"(ssr)/./node_modules/ox/_esm/core/PublicKey.js\");\n/* harmony import */ var _WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../WebAuthnP256.js */ \"(ssr)/./node_modules/ox/_esm/core/WebAuthnP256.js\");\n\n\n\n\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */\nfunction parseAsn1Signature(bytes) {\n    const r_start = bytes[4] === 0 ? 5 : 4;\n    const r_end = r_start + 32;\n    const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes.slice(r_start, r_end)));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes.slice(s_start)));\n    return {\n        r,\n        s: s > _noble_curves_p256__WEBPACK_IMPORTED_MODULE_1__.p256.CURVE.n / 2n ? _noble_curves_p256__WEBPACK_IMPORTED_MODULE_1__.p256.CURVE.n - s : s,\n    };\n}\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */\nasync function parseCredentialPublicKey(response) {\n    try {\n        const publicKeyBuffer = response.getPublicKey();\n        if (!publicKeyBuffer)\n            throw new _WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_2__.CredentialCreationFailedError();\n        // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n        const publicKeyBytes = new Uint8Array(publicKeyBuffer);\n        const cryptoKey = await crypto.subtle.importKey('spki', new Uint8Array(publicKeyBytes), {\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n            hash: 'SHA-256',\n        }, true, ['verify']);\n        const publicKey = new Uint8Array(await crypto.subtle.exportKey('raw', cryptoKey));\n        return _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.from(publicKey);\n    }\n    catch (error) {\n        // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n        // so we need to use `attestationObject` to extract the public key.\n        // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n        if (error.message !== 'Permission denied to access object')\n            throw error;\n        const data = new Uint8Array(response.attestationObject);\n        const coordinateLength = 0x20;\n        const cborPrefix = 0x58;\n        const findStart = (key) => {\n            const coordinate = new Uint8Array([key, cborPrefix, coordinateLength]);\n            for (let i = 0; i < data.length - coordinate.length; i++)\n                if (coordinate.every((byte, j) => data[i + j] === byte))\n                    return i + coordinate.length;\n            throw new _WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_2__.CredentialCreationFailedError();\n        };\n        const xStart = findStart(0x21);\n        const yStart = findStart(0x22);\n        return _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.from(new Uint8Array([\n            0x04,\n            ...data.slice(xStart, xStart + coordinateLength),\n            ...data.slice(yStart, yStart + coordinateLength),\n        ]));\n    }\n}\n//# sourceMappingURL=webauthn.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL3dlYmF1dGhuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUEwQztBQUNUO0FBQ1k7QUFDc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUFhO0FBQ2xDLHFCQUFxQiw4Q0FBYTtBQUNsQztBQUNBO0FBQ0EsZUFBZSxvREFBSSxnQkFBZ0Isb0RBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJFQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLCtDQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBLHNCQUFzQiwyRUFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQ0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC93ZWJhdXRobi5qcz81ODhjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHAyNTYgfSBmcm9tICdAbm9ibGUvY3VydmVzL3AyNTYnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBQdWJsaWNLZXkgZnJvbSAnLi4vUHVibGljS2V5LmpzJztcbmltcG9ydCB7IENyZWRlbnRpYWxDcmVhdGlvbkZhaWxlZEVycm9yIH0gZnJvbSAnLi4vV2ViQXV0aG5QMjU2LmpzJztcbi8qKlxuICogUGFyc2VzIGFuIEFTTi4xIHNpZ25hdHVyZSBpbnRvIGEgciBhbmQgcyB2YWx1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXNuMVNpZ25hdHVyZShieXRlcykge1xuICAgIGNvbnN0IHJfc3RhcnQgPSBieXRlc1s0XSA9PT0gMCA/IDUgOiA0O1xuICAgIGNvbnN0IHJfZW5kID0gcl9zdGFydCArIDMyO1xuICAgIGNvbnN0IHNfc3RhcnQgPSBieXRlc1tyX2VuZCArIDJdID09PSAwID8gcl9lbmQgKyAzIDogcl9lbmQgKyAyO1xuICAgIGNvbnN0IHIgPSBCaWdJbnQoSGV4LmZyb21CeXRlcyhieXRlcy5zbGljZShyX3N0YXJ0LCByX2VuZCkpKTtcbiAgICBjb25zdCBzID0gQmlnSW50KEhleC5mcm9tQnl0ZXMoYnl0ZXMuc2xpY2Uoc19zdGFydCkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByLFxuICAgICAgICBzOiBzID4gcDI1Ni5DVVJWRS5uIC8gMm4gPyBwMjU2LkNVUlZFLm4gLSBzIDogcyxcbiAgICB9O1xufVxuLyoqXG4gKiBQYXJzZXMgYSBwdWJsaWMga2V5IGludG8geCBhbmQgeSBjb29yZGluYXRlcyBmcm9tIHRoZSBwdWJsaWMga2V5XG4gKiBkZWZpbmVkIG9uIHRoZSBjcmVkZW50aWFsLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VDcmVkZW50aWFsUHVibGljS2V5KHJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5QnVmZmVyID0gcmVzcG9uc2UuZ2V0UHVibGljS2V5KCk7XG4gICAgICAgIGlmICghcHVibGljS2V5QnVmZmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IENyZWRlbnRpYWxDcmVhdGlvbkZhaWxlZEVycm9yKCk7XG4gICAgICAgIC8vIENvbnZlcnRpbmcgYHB1YmxpY0tleUJ1ZmZlcmAgdGhyb3dzIHdoZW4gY3JlZGVudGlhbCBpcyBjcmVhdGVkIGJ5IDFQYXNzd29yZCBGaXJlZm94IEFkZC1vblxuICAgICAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IG5ldyBVaW50OEFycmF5KHB1YmxpY0tleUJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdzcGtpJywgbmV3IFVpbnQ4QXJyYXkocHVibGljS2V5Qnl0ZXMpLCB7XG4gICAgICAgICAgICBuYW1lOiAnRUNEU0EnLFxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogJ1AtMjU2JyxcbiAgICAgICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgfSwgdHJ1ZSwgWyd2ZXJpZnknXSk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBVaW50OEFycmF5KGF3YWl0IGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBjcnlwdG9LZXkpKTtcbiAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBGYWxsYmFjayBmb3IgMVBhc3N3b3JkIEZpcmVmb3ggQWRkLW9uIHJlc3RyaWN0cyBhY2Nlc3MgdG8gY2VydGFpbiBjcmVkZW50aWFsIHByb3BlcnRpZXNcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byB1c2UgYGF0dGVzdGF0aW9uT2JqZWN0YCB0byBleHRyYWN0IHRoZSBwdWJsaWMga2V5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGFzc3dvcmRsZXNzLWlkL3dlYmF1dGhuL2lzc3Vlcy81MCNpc3N1ZWNvbW1lbnQtMjA3MjkwMjA5NFxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSAhPT0gJ1Blcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyBvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5hdHRlc3RhdGlvbk9iamVjdCk7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVMZW5ndGggPSAweDIwO1xuICAgICAgICBjb25zdCBjYm9yUHJlZml4ID0gMHg1ODtcbiAgICAgICAgY29uc3QgZmluZFN0YXJ0ID0gKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZSA9IG5ldyBVaW50OEFycmF5KFtrZXksIGNib3JQcmVmaXgsIGNvb3JkaW5hdGVMZW5ndGhdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSBjb29yZGluYXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChjb29yZGluYXRlLmV2ZXJ5KChieXRlLCBqKSA9PiBkYXRhW2kgKyBqXSA9PT0gYnl0ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpICsgY29vcmRpbmF0ZS5sZW5ndGg7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3JlZGVudGlhbENyZWF0aW9uRmFpbGVkRXJyb3IoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeFN0YXJ0ID0gZmluZFN0YXJ0KDB4MjEpO1xuICAgICAgICBjb25zdCB5U3RhcnQgPSBmaW5kU3RhcnQoMHgyMik7XG4gICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbShuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAweDA0LFxuICAgICAgICAgICAgLi4uZGF0YS5zbGljZSh4U3RhcnQsIHhTdGFydCArIGNvb3JkaW5hdGVMZW5ndGgpLFxuICAgICAgICAgICAgLi4uZGF0YS5zbGljZSh5U3RhcnQsIHlTdGFydCArIGNvb3JkaW5hdGVMZW5ndGgpLFxuICAgICAgICBdKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViYXV0aG4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/webauthn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/version.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/** @internal */\nconst version = '0.1.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS92ZXJzaW9uLmpzPzA2NzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMC4xLjEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/erc6492/SignatureErc6492.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc6492/SignatureErc6492.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: () => (/* binding */ InvalidWrappedSignatureError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   universalSignatureValidatorAbi: () => (/* binding */ universalSignatureValidatorAbi),\n/* harmony export */   universalSignatureValidatorBytecode: () => (/* binding */ universalSignatureValidatorBytecode),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */\nconst magicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */\nconst universalSignatureValidatorBytecode = '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */\nconst universalSignatureValidatorAbi = [\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'constructor',\n    },\n    {\n        inputs: [\n            {\n                name: '_signer',\n                type: 'address',\n            },\n            {\n                name: '_hash',\n                type: 'bytes32',\n            },\n            {\n                name: '_signature',\n                type: 'bytes',\n            },\n        ],\n        outputs: [\n            {\n                type: 'bool',\n            },\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function',\n        name: 'isValidSig',\n    },\n];\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * SignatureErc6492.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */\nfunction assert(wrapped) {\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(wrapped, -32) !== magicBytes)\n        throw new InvalidWrappedSignatureError(wrapped);\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc6492.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc6492.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nfunction from(wrapped) {\n    if (typeof wrapped === 'string')\n        return unwrap(wrapped);\n    return wrapped;\n}\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const { data, signature, to } = SignatureErc6492.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nfunction unwrap(wrapped) {\n    assert(wrapped);\n    const [to, data, signature] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.decode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from('address, bytes, bytes'), wrapped);\n    return { data, signature, to };\n}\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc6492.wrap({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */\nfunction wrap(value) {\n    const { data, signature, to } = value;\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.encode(_core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_1__.from('address, bytes, bytes'), [\n        to,\n        data,\n        signature,\n    ]), magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const valid = SignatureErc6492.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */\nfunction validate(wrapped) {\n    try {\n        assert(wrapped);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-6492 wrapped signature is invalid. */\nclass InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureErc6492.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureErc6492.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM2NDkyL1NpZ25hdHVyZUVyYzY0OTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ2Q7QUFDTjtBQUN0QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsK0NBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QixLQUFLLGlCQUFpQjtBQUNoRTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLDRCQUE0QixLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQ0FBa0MsMERBQW9CLENBQUMsd0RBQWtCO0FBQ3pFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQyxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxzQkFBc0I7QUFDbEMsV0FBVyxnREFBVSxDQUFDLDBEQUFvQixDQUFDLHdEQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJDQUEyQyxzREFBZ0I7QUFDbEU7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vZXJjNjQ5Mi9TaWduYXR1cmVFcmM2NDkyLmpzPzlmYjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWJpUGFyYW1ldGVycyBmcm9tICcuLi9jb3JlL0FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4uL2NvcmUvRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9jb3JlL0hleC5qcyc7XG4vKipcbiAqIE1hZ2ljIGJ5dGVzIHVzZWQgdG8gaWRlbnRpZnkgRVJDLTY0OTIgd3JhcHBlZCBzaWduYXR1cmVzLlxuICovXG5leHBvcnQgY29uc3QgbWFnaWNCeXRlcyA9ICcweDY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTInO1xuLyoqXG4gKiBEZXBsb3lsZXNzIEVSQy02NDkyIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gYnl0ZWNvZGUuXG4gKi9cbmV4cG9ydCBjb25zdCB1bml2ZXJzYWxTaWduYXR1cmVWYWxpZGF0b3JCeXRlY29kZSA9ICcweDYwODA2MDQwNTIzNDgwMTU2MTAwMTA1NzYwMDA4MGZkNWI1MDYwNDA1MTYxMDY5NDM4MDM4MDYxMDY5NDgzMzk4MTAxNjA0MDgxOTA1MjYxMDAyZjkxNjEwNTFlNTY1YjYwMDA2MTAwM2M4NDg0ODQ2MTAwNDg1NjViOTA1MDgwNjAwMDUyNjAwMTYwMWZmMzViNjAwMDdmNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjYxMDA3NDgzNjEwNDBjNTY1YjAzNjEwMWU3NTc2MDAwNjA2MDgwODQ4MDYwMjAwMTkwNTE4MTAxOTA2MTAwOTI5MTkwNjEwNTc3NTY1YjYwNDA1MTkyOTU1MDkwOTM1MDkxNTA2MDAwOTA2MDAxNjAwMTYwYTAxYjAzODUxNjkwNjEwMGI2OTA4NTkwNjEwNWRkNTY1YjYwMDA2MDQwNTE4MDgzMDM4MTYwMDA4NjVhZjE5MTUwNTAzZDgwNjAwMDgxMTQ2MTAwZjM1NzYwNDA1MTkxNTA2MDFmMTk2MDNmM2QwMTE2ODIwMTYwNDA1MjNkODI1MjNkNjAwMDYwMjA4NDAxM2U2MTAwZjg1NjViNjA2MDkxNTA1YjUwNTA5MDUwODc2MDAxNjAwMTYwYTAxYjAzMTYzYjYwMDAwMzYxMDE2MDU3ODA2MTAxNjA1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAxZTYwMjQ4MjAxNTI3ZjUzNjk2NzZlNjE3NDc1NzI2NTU2NjE2YzY5NjQ2MTc0NmY3MjNhMjA2NDY1NzA2YzZmNzk2ZDY1NmU3NDAwMDA2MDQ0ODIwMTUyNjA2NDAxNWI2MDQwNTE4MDkxMDM5MGZkNWI2MDQwNTE2MzBiMTM1ZDNmNjBlMTFiODA4MjUyOTA2MDAxNjAwMTYwYTAxYjAzOGExNjkwNjMxNjI2YmE3ZTkwNjEwMTkwOTA4YjkwODc5MDYwMDQwMTYxMDVmOTU2NWI2MDIwNjA0MDUxODA4MzAzODE4NjVhZmExNTgwMTU2MTAxYWQ1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA1MDUwNTA2MDQwNTEzZDYwMWYxOTYwMWY4MjAxMTY4MjAxODA2MDQwNTI1MDgxMDE5MDYxMDFkMTkxOTA2MTA2MzM1NjViNjAwMTYwMDE2MGUwMWIwMzE5MTYxNDk0NTA1MDUwNTA1MDYxMDQwNTU2NWI2MDAxNjAwMTYwYTAxYjAzODQxNjNiMTU2MTAyN2E1NzYwNDA1MTYzMGIxMzVkM2Y2MGUxMWI4MDgyNTI5MDYwMDE2MDAxNjBhMDFiMDM4NjE2OTA2MzE2MjZiYTdlOTA2MTAyMjc5MDg3OTA4NzkwNjAwNDAxNjEwNWY5NTY1YjYwMjA2MDQwNTE4MDgzMDM4MTg2NWFmYTE1ODAxNTYxMDI0NDU3M2Q2MDAwODAzZTNkNjAwMGZkNWI1MDUwNTA1MDYwNDA1MTNkNjAxZjE5NjAxZjgyMDExNjgyMDE4MDYwNDA1MjUwODEwMTkwNjEwMjY4OTE5MDYxMDYzMzU2NWI2MDAxNjAwMTYwZTAxYjAzMTkxNjE0OTA1MDYxMDQwNTU2NWI4MTUxNjA0MTE0NjEwMmRmNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwM2E2MDI0ODIwMTUyNjAwMDgwNTE2MDIwNjEwNjc0ODMzOTgxNTE5MTUyNjA0NDgyMDE1MjdmM2EyMDY5NmU3NjYxNmM2OTY0MjA3MzY5Njc2ZTYxNzQ3NTcyNjUyMDZjNjU2ZTY3NzQ2ODAwMDAwMDAwMDAwMDYwNjQ4MjAxNTI2MDg0MDE2MTAxNTc1NjViNjEwMmU3NjEwNDI1NTY1YjUwNjAyMDgyMDE1MTYwNDA4MDg0MDE1MTg0NTE4NTkzOTI2MDAwOTE4NTkxOTA4MTEwNjEwMzBjNTc2MTAzMGM2MTA2NWQ1NjViMDE2MDIwMDE1MTYwZjgxYzkwNTA2MDFiODExNDgwMTU5MDYxMDMyYjU3NTA4MDYwZmYxNjYwMWMxNDE1NWIxNTYxMDM4YzU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDNiNjAyNDgyMDE1MjYwMDA4MDUxNjAyMDYxMDY3NDgzMzk4MTUxOTE1MjYwNDQ4MjAxNTI3ZjNhMjA2OTZlNzY2MTZjNjk2NDIwNzM2OTY3NmU2MTc0NzU3MjY1MjA3NjIwNzY2MTZjNzU2NTAwMDAwMDAwMDA2MDY0ODIwMTUyNjA4NDAxNjEwMTU3NTY1YjYwNDA4MDUxNjAwMDgxNTI2MDIwODEwMTgwODM1Mjg5OTA1MjYwZmY4MzE2OTE4MTAxOTE5MDkxNTI2MDYwODEwMTg0OTA1MjYwODA4MTAxODM5MDUyNjAwMTYwMDE2MGEwMWIwMzg5MTY5MDYwMDE5MDYwYTAwMTYwMjA2MDQwNTE2MDIwODEwMzkwODA4NDAzOTA4NTVhZmExNTgwMTU2MTAzZWE1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA1MDUwNjAyMDYwNDA1MTAzNTE2MDAxNjAwMTYwYTAxYjAzMTYxNDk0NTA1MDUwNTA1MDViOTM5MjUwNTA1MDU2NWI2MDAwNjAyMDgyNTExMDE1NjEwNDFkNTc2MDAwODBmZDViNTA4MDUxMDE1MTkwNTY1YjYwNDA1MTgwNjA2MDAxNjA0MDUyODA2MDAzOTA2MDIwODIwMjgwMzY4MzM3NTA5MTkyOTE1MDUwNTY1YjYwMDE2MDAxNjBhMDFiMDM4MTE2ODExNDYxMDQ1ODU3NjAwMDgwZmQ1YjUwNTY1YjYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDQxNjAwNDUyNjAyNDYwMDBmZDViNjAwMDViODM4MTEwMTU2MTA0OGM1NzgxODEwMTUxODM4MjAxNTI2MDIwMDE2MTA0NzQ1NjViNTA1MDYwMDA5MTAxNTI1NjViNjAwMDgyNjAxZjgzMDExMjYxMDRhNjU3NjAwMDgwZmQ1YjgxNTE2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEwNGJmNTc2MTA0YmY2MTA0NWI1NjViNjA0MDUxNjAxZjgyMDE2MDFmMTk5MDgxMTY2MDNmMDExNjgxMDE2MDAxNjAwMTYwNDAxYjAzODExMTgyODIxMDE3MTU2MTA0ZWQ1NzYxMDRlZDYxMDQ1YjU2NWI2MDQwNTI4MTgxNTI4MzgyMDE2MDIwMDE4NTEwMTU2MTA1MDU1NzYwMDA4MGZkNWI2MTA1MTY4MjYwMjA4MzAxNjAyMDg3MDE2MTA0NzE1NjViOTQ5MzUwNTA1MDUwNTY1YjYwMDA4MDYwMDA2MDYwODQ4NjAzMTIxNTYxMDUzMzU3NjAwMDgwZmQ1YjgzNTE2MTA1M2U4MTYxMDQ0MzU2NWI2MDIwODUwMTUxNjA0MDg2MDE1MTkxOTQ1MDkyNTA2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEwNTYxNTc2MDAwODBmZDViNjEwNTZkODY4Mjg3MDE2MTA0OTU1NjViOTE1MDUwOTI1MDkyNTA5MjU2NWI2MDAwODA2MDAwNjA2MDg0ODYwMzEyMTU2MTA1OGM1NzYwMDA4MGZkNWI4MzUxNjEwNTk3ODE2MTA0NDM1NjViNjAyMDg1MDE1MTkwOTM1MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA1YjM1NzYwMDA4MGZkNWI2MTA1YmY4NjgyODcwMTYxMDQ5NTU2NWI2MDQwODYwMTUxOTA5MzUwOTA1MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTA1NjE1NzYwMDA4MGZkNWI2MDAwODI1MTYxMDVlZjgxODQ2MDIwODcwMTYxMDQ3MTU2NWI5MTkwOTEwMTkyOTE1MDUwNTY1YjgyODE1MjYwNDA2MDIwODIwMTUyNjAwMDgyNTE4MDYwNDA4NDAxNTI2MTA2MWU4MTYwNjA4NTAxNjAyMDg3MDE2MTA0NzE1NjViNjAxZjAxNjAxZjE5MTY5MTkwOTEwMTYwNjAwMTkzOTI1MDUwNTA1NjViNjAwMDYwMjA4Mjg0MDMxMjE1NjEwNjQ1NTc2MDAwODBmZDViODE1MTYwMDE2MDAxNjBlMDFiMDMxOTgxMTY4MTE0NjEwNDA1NTc2MDAwODBmZDViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwMzI2MDA0NTI2MDI0NjAwMGZkZmU1MzY5Njc2ZTYxNzQ3NTcyNjU1NjYxNmM2OTY0NjE3NDZmNzIyMzcyNjU2MzZmNzY2NTcyNTM2OTY3NmU2NTcyJztcbi8qKlxuICogQUJJIGZvciB0aGUgRVJDLTY0OTIgdW5pdmVyc2FsIGRlcGxveWxlc3Mgc2lnbmF0dXJlIHZhbGlkYXRvciBjb250cmFjdC5cbiAqXG4gKiBDb25zdHJ1Y3RvciByZXR1cm4gdmFsdWUgaXMgYDB4MWAgKHZhbGlkKSBvciBgMHgwYCAoaW52YWxpZCkuXG4gKi9cbmV4cG9ydCBjb25zdCB1bml2ZXJzYWxTaWduYXR1cmVWYWxpZGF0b3JBYmkgPSBbXG4gICAge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX3NpZ25lcicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnX2hhc2gnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlczMyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19zaWduYXR1cmUnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAgICAgICAgdHlwZTogJ2NvbnN0cnVjdG9yJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19zaWduZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ19oYXNoJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMzMicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdfc2lnbmF0dXJlJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib29sJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIHN0YXRlTXV0YWJpbGl0eTogJ25vbnBheWFibGUnLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICBuYW1lOiAnaXNWYWxpZFNpZycsXG4gICAgfSxcbl07XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgd3JhcHBlZCBzaWduYXR1cmUgaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM2NDkyIH0gZnJvbSAnb3gvZXJjNjQ5MidcbiAqXG4gKiBTaWduYXR1cmVFcmM2NDkyLmFzc2VydCgnMHhkZWFkYmVlZicpXG4gKiAvLyBAZXJyb3I6IEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3I6IFZhbHVlIGAweGRlYWRiZWVmYCBpcyBhbiBpbnZhbGlkIEVSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHdyYXBwZWQgLSBUaGUgd3JhcHBlZCBzaWduYXR1cmUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHdyYXBwZWQpIHtcbiAgICBpZiAoSGV4LnNsaWNlKHdyYXBwZWQsIC0zMikgIT09IG1hZ2ljQnl0ZXMpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yKHdyYXBwZWQpO1xufVxuLyoqXG4gKiBQYXJzZXMgYW4gW0VSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTY0OTIjc3BlY2lmaWNhdGlvbikgaW50byBpdHMgY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjNjQ5MiB9IGZyb20gJ294L2VyYzY0OTInIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6ICcweC4uLicsXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIC8vIEluc3RhbnRpYXRlIGZyb20gc2VyaWFsaXplZCBmb3JtYXQuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM2NDkyLmZyb20oJzB4Li4uJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogeyBkYXRhOiAnMHguLi4nLCBzaWduYXR1cmU6IHsgLi4uIH0sIHRvOiAnMHguLi4nLCB9IC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiAvLyBJbnN0YW50aWF0ZSBmcm9tIGNvbnN0aXR1ZW50IHBhcnRzLiAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCB3cmFwcGVkID0gU2lnbmF0dXJlRXJjNjQ5Mi5mcm9tKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBkYXRhOiAnMHguLi4nLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICB0bzogJzB4Li4uJywgLy8gWyFjb2RlIGZvY3VzXVxuICogfSlcbiAqIC8vIEBsb2c6IHsgZGF0YTogJzB4Li4uJywgc2lnbmF0dXJlOiB7IC4uLiB9LCB0bzogJzB4Li4uJywgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHdyYXBwZWQgLSBXcmFwcGVkIHNpZ25hdHVyZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFdyYXBwZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh3cmFwcGVkKSB7XG4gICAgaWYgKHR5cGVvZiB3cmFwcGVkID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHVud3JhcCh3cmFwcGVkKTtcbiAgICByZXR1cm4gd3JhcHBlZDtcbn1cbi8qKlxuICogUGFyc2VzIGFuIFtFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02NDkyI3NwZWNpZmljYXRpb24pIGludG8gaXRzIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjNjQ5MiB9IGZyb20gJ294L2VyYzY0OTInXG4gKlxuICogY29uc3QgeyBkYXRhLCBzaWduYXR1cmUsIHRvIH0gPSBTaWduYXR1cmVFcmM2NDkyLnVud3JhcCgnMHguLi4nKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHdyYXBwZWQgLSBXcmFwcGVkIHNpZ25hdHVyZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFdyYXBwZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwKHdyYXBwZWQpIHtcbiAgICBhc3NlcnQod3JhcHBlZCk7XG4gICAgY29uc3QgW3RvLCBkYXRhLCBzaWduYXR1cmVdID0gQWJpUGFyYW1ldGVycy5kZWNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKCdhZGRyZXNzLCBieXRlcywgYnl0ZXMnKSwgd3JhcHBlZCk7XG4gICAgcmV0dXJuIHsgZGF0YSwgc2lnbmF0dXJlLCB0byB9O1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGFuIFtFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZV0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC02NDkyI3NwZWNpZmljYXRpb24pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzY0OTIgfSBmcm9tICdveC9lcmM2NDkyJyAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiAnMHguLi4nLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCB3cmFwcGVkID0gU2lnbmF0dXJlRXJjNjQ5Mi53cmFwKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBkYXRhOiAnMHhkZWFkYmVlZicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlOiBTaWduYXR1cmUudG9IZXgoc2lnbmF0dXJlKSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICB0bzogJzB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYScsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFdyYXBwZWQgc2lnbmF0dXJlIHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFNlcmlhbGl6ZWQgd3JhcHBlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzaWduYXR1cmUsIHRvIH0gPSB2YWx1ZTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oJ2FkZHJlc3MsIGJ5dGVzLCBieXRlcycpLCBbXG4gICAgICAgIHRvLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgXSksIG1hZ2ljQnl0ZXMpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB3cmFwcGVkIHNpZ25hdHVyZS4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHdyYXBwZWQgc2lnbmF0dXJlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzY0OTIgfSBmcm9tICdveC9lcmM2NDkyJ1xuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlRXJjNjQ5Mi52YWxpZGF0ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHdyYXBwZWQgLSBUaGUgd3JhcHBlZCBzaWduYXR1cmUgdG8gdmFsaWRhdGUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHdyYXBwZWQgc2lnbmF0dXJlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHdyYXBwZWQpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQod3JhcHBlZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIEVSQy02NDkyIHdyYXBwZWQgc2lnbmF0dXJlIGlzIGludmFsaWQuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHdyYXBwZWQpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7d3JhcHBlZH1cXGAgaXMgYW4gaW52YWxpZCBFUkMtNjQ5MiB3cmFwcGVkIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZUVyYzY0OTIuSW52YWxpZFdyYXBwZWRTaWduYXR1cmVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2lnbmF0dXJlRXJjNjQ5Mi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/erc6492/SignatureErc6492.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/erc8010/SignatureErc8010.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/erc8010/SignatureErc8010.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidWrappedSignatureError: () => (/* binding */ InvalidWrappedSignatureError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   suffixParameters: () => (/* binding */ suffixParameters),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AbiParameters.js */ \"(ssr)/./node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Authorization.js */ \"(ssr)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Secp256k1.js */ \"(ssr)/./node_modules/ox/_esm/core/Secp256k1.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n\n\n/**\n * Magic bytes used to identify ERC-8010 wrapped signatures.\n */\nconst magicBytes = '0x8010801080108010801080108010801080108010801080108010801080108010';\n/** Suffix ABI parameters for the ERC-8010 wrapped signature. */\nconst suffixParameters = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.from('(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data');\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * SignatureErc8010.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-8010 wrapped signature.\n * ```\n *\n * @param value - The value to assert.\n */\nfunction assert(value) {\n    if (typeof value === 'string') {\n        if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(value, -32) !== magicBytes)\n            throw new InvalidWrappedSignatureError(value);\n    }\n    else\n        _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.assert(value.authorization);\n}\n/**\n * Parses an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc8010.from('0x...') // [!code focus]\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc8010.from({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n * })\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } }\n * ```\n *\n * @param value - Value to parse.\n * @returns Parsed value.\n */\nfunction from(value) {\n    if (typeof value === 'string')\n        return unwrap(value);\n    return value;\n}\n/**\n * Unwraps an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const { authorization, data, signature } = SignatureErc8010.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to unwrap.\n * @returns Unwrapped signature.\n */\nfunction unwrap(wrapped) {\n    assert(wrapped);\n    const suffixLength = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, -64, -32));\n    const suffix = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, -suffixLength - 64, -64);\n    const signature = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(wrapped, 0, -suffixLength - 64);\n    const [auth, to, data] = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(suffixParameters, suffix);\n    const authorization = _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__.from({\n        address: auth.delegation,\n        chainId: Number(auth.chainId),\n        nonce: auth.nonce,\n        yParity: auth.yParity,\n        r: auth.r,\n        s: auth.s,\n    });\n    return {\n        authorization,\n        signature,\n        ...(data && data !== '0x' ? { data, to } : {}),\n    };\n}\n/**\n * Wraps a signature into [ERC-8010 format](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md).\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc8010.wrap({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Values to wrap.\n * @returns Wrapped signature.\n */\nfunction wrap(value) {\n    const { data, signature } = value;\n    assert(value);\n    const self = _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_4__.recoverAddress({\n        payload: _core_Authorization_js__WEBPACK_IMPORTED_MODULE_3__.getSignPayload(value.authorization),\n        signature: _core_Signature_js__WEBPACK_IMPORTED_MODULE_2__.from(value.authorization),\n    });\n    const suffix = _core_AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(suffixParameters, [\n        {\n            ...value.authorization,\n            delegation: value.authorization.address,\n            chainId: BigInt(value.authorization.chainId),\n        },\n        value.to ?? self,\n        data ?? '0x',\n    ]);\n    const suffixLength = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(suffix), { size: 32 });\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(signature, suffix, suffixLength, magicBytes);\n}\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const valid = SignatureErc8010.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param value - The value to validate.\n * @returns `true` if the value is valid, `false` otherwise.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/** Thrown when the ERC-8010 wrapped signature is invalid. */\nclass InvalidWrappedSignatureError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(wrapped) {\n        super(`Value \\`${wrapped}\\` is an invalid ERC-8010 wrapped signature.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureErc8010.InvalidWrappedSignatureError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureErc8010.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM4MDEwL1NpZ25hdHVyZUVyYzgwMTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDQTtBQUNkO0FBQ047QUFDWTtBQUNBO0FBQ2xEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTyx5QkFBeUIsd0RBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLCtDQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCLEtBQUssOEJBQThCLFFBQVE7QUFDMUU7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0EsSUFBSTtBQUNKLGNBQWMsaUJBQWlCLEtBQUssOEJBQThCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSx5QkFBeUIsa0RBQVksQ0FBQywrQ0FBUztBQUMvQyxtQkFBbUIsK0NBQVM7QUFDNUIsc0JBQXNCLCtDQUFTO0FBQy9CLDZCQUE2QiwwREFBb0I7QUFDakQsMEJBQTBCLHdEQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVcsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkMsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwyQ0FBMkM7QUFDM0Msc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBLGlCQUFpQiw4REFBd0I7QUFDekMsaUJBQWlCLGtFQUE0QjtBQUM3QyxtQkFBbUIsb0RBQWM7QUFDakMsS0FBSztBQUNMLG1CQUFtQiwwREFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFjLENBQUMsOENBQVEsWUFBWSxVQUFVO0FBQ3RFLFdBQVcsZ0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLHNEQUFnQjtBQUNsRTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9lcmM4MDEwL1NpZ25hdHVyZUVyYzgwMTAuanM/ZGI4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4uL2NvcmUvQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBBdXRob3JpemF0aW9uIGZyb20gJy4uL2NvcmUvQXV0aG9yaXphdGlvbi5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vY29yZS9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbmltcG9ydCAqIGFzIFNlY3AyNTZrMSBmcm9tICcuLi9jb3JlL1NlY3AyNTZrMS5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi4vY29yZS9TaWduYXR1cmUuanMnO1xuLyoqXG4gKiBNYWdpYyBieXRlcyB1c2VkIHRvIGlkZW50aWZ5IEVSQy04MDEwIHdyYXBwZWQgc2lnbmF0dXJlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hZ2ljQnl0ZXMgPSAnMHg4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwODAxMDgwMTA4MDEwJztcbi8qKiBTdWZmaXggQUJJIHBhcmFtZXRlcnMgZm9yIHRoZSBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZS4gKi9cbmV4cG9ydCBjb25zdCBzdWZmaXhQYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKCcodWludDI1NiBjaGFpbklkLCBhZGRyZXNzIGRlbGVnYXRpb24sIHVpbnQyNTYgbm9uY2UsIHVpbnQ4IHlQYXJpdHksIHVpbnQyNTYgciwgdWludDI1NiBzKSwgYWRkcmVzcyB0bywgYnl0ZXMgZGF0YScpO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIHdyYXBwZWQgc2lnbmF0dXJlIGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRXJjODAxMCB9IGZyb20gJ294L2VyYzgwMTAnXG4gKlxuICogU2lnbmF0dXJlRXJjODAxMC5hc3NlcnQoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkV3JhcHBlZFNpZ25hdHVyZUVycm9yOiBWYWx1ZSBgMHhkZWFkYmVlZmAgaXMgYW4gaW52YWxpZCBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZS5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoSGV4LnNsaWNlKHZhbHVlLCAtMzIpICE9PSBtYWdpY0J5dGVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIFNpZ25hdHVyZS5hc3NlcnQodmFsdWUuYXV0aG9yaXphdGlvbik7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBbRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9qeG9tL0VSQ3MvYmxvYi8xNmY3ZTM4OTFmZmYyZTFlOWMyNWRlYTA0ODU0OTc3MzlkYjhhODE2L0VSQ1MvZXJjLTgwMTAubWQpIGludG8gaXRzIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzgwMTAgfSBmcm9tICdveC9lcmM4MDEwJyAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiAnMHguLi4nLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiAvLyBJbnN0YW50aWF0ZSBmcm9tIHNlcmlhbGl6ZWQgZm9ybWF0LiAvLyBbIWNvZGUgZm9jdXNdXG4gKiBjb25zdCB3cmFwcGVkID0gU2lnbmF0dXJlRXJjODAxMC5mcm9tKCcweC4uLicpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHsgYXV0aG9yaXphdGlvbjogeyAuLi4gfSwgZGF0YTogJzB4Li4uJywgc2lnbmF0dXJlOiB7IC4uLiB9IH0gLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIEluc3RhbnRpYXRlIGZyb20gY29uc3RpdHVlbnQgcGFydHMuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IHdyYXBwZWQgPSBTaWduYXR1cmVFcmM4MDEwLmZyb20oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGF1dGhvcml6YXRpb246IHsgLi4uIH0sIC8vIFshY29kZSBmb2N1c11cbiAqICAgZGF0YTogJzB4Li4uJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pXG4gKiAvLyBAbG9nOiB7IGF1dGhvcml6YXRpb246IHsgLi4uIH0sIGRhdGE6ICcweC4uLicsIHNpZ25hdHVyZTogeyAuLi4gfSB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFBhcnNlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHVud3JhcCh2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBVbndyYXBzIGFuIFtFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZV0oaHR0cHM6Ly9naXRodWIuY29tL2p4b20vRVJDcy9ibG9iLzE2ZjdlMzg5MWZmZjJlMWU5YzI1ZGVhMDQ4NTQ5NzczOWRiOGE4MTYvRVJDUy9lcmMtODAxMC5tZCkgaW50byBpdHMgY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM4MDEwIH0gZnJvbSAnb3gvZXJjODAxMCdcbiAqXG4gKiBjb25zdCB7IGF1dGhvcml6YXRpb24sIGRhdGEsIHNpZ25hdHVyZSB9ID0gU2lnbmF0dXJlRXJjODAxMC51bndyYXAoJzB4Li4uJylcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3cmFwcGVkIC0gV3JhcHBlZCBzaWduYXR1cmUgdG8gdW53cmFwLlxuICogQHJldHVybnMgVW53cmFwcGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcCh3cmFwcGVkKSB7XG4gICAgYXNzZXJ0KHdyYXBwZWQpO1xuICAgIGNvbnN0IHN1ZmZpeExlbmd0aCA9IEhleC50b051bWJlcihIZXguc2xpY2Uod3JhcHBlZCwgLTY0LCAtMzIpKTtcbiAgICBjb25zdCBzdWZmaXggPSBIZXguc2xpY2Uod3JhcHBlZCwgLXN1ZmZpeExlbmd0aCAtIDY0LCAtNjQpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IEhleC5zbGljZSh3cmFwcGVkLCAwLCAtc3VmZml4TGVuZ3RoIC0gNjQpO1xuICAgIGNvbnN0IFthdXRoLCB0bywgZGF0YV0gPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShzdWZmaXhQYXJhbWV0ZXJzLCBzdWZmaXgpO1xuICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICAgICAgICBhZGRyZXNzOiBhdXRoLmRlbGVnYXRpb24sXG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihhdXRoLmNoYWluSWQpLFxuICAgICAgICBub25jZTogYXV0aC5ub25jZSxcbiAgICAgICAgeVBhcml0eTogYXV0aC55UGFyaXR5LFxuICAgICAgICByOiBhdXRoLnIsXG4gICAgICAgIHM6IGF1dGgucyxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhdXRob3JpemF0aW9uLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIC4uLihkYXRhICYmIGRhdGEgIT09ICcweCcgPyB7IGRhdGEsIHRvIH0gOiB7fSksXG4gICAgfTtcbn1cbi8qKlxuICogV3JhcHMgYSBzaWduYXR1cmUgaW50byBbRVJDLTgwMTAgZm9ybWF0XShodHRwczovL2dpdGh1Yi5jb20vanhvbS9FUkNzL2Jsb2IvMTZmN2UzODkxZmZmMmUxZTljMjVkZWEwNDg1NDk3NzM5ZGI4YTgxNi9FUkNTL2VyYy04MDEwLm1kKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVyYzgwMTAgfSBmcm9tICdveC9lcmM4MDEwJyAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiAnMHguLi4nLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCB3cmFwcGVkID0gU2lnbmF0dXJlRXJjODAxMC53cmFwKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBhdXRob3JpemF0aW9uOiB7IC4uLiB9LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGRhdGE6ICcweGRlYWRiZWVmJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmU6IFNpZ25hdHVyZS50b0hleChzaWduYXR1cmUpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZXMgdG8gd3JhcC5cbiAqIEByZXR1cm5zIFdyYXBwZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcCh2YWx1ZSkge1xuICAgIGNvbnN0IHsgZGF0YSwgc2lnbmF0dXJlIH0gPSB2YWx1ZTtcbiAgICBhc3NlcnQodmFsdWUpO1xuICAgIGNvbnN0IHNlbGYgPSBTZWNwMjU2azEucmVjb3ZlckFkZHJlc3Moe1xuICAgICAgICBwYXlsb2FkOiBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKHZhbHVlLmF1dGhvcml6YXRpb24pLFxuICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tKHZhbHVlLmF1dGhvcml6YXRpb24pLFxuICAgIH0pO1xuICAgIGNvbnN0IHN1ZmZpeCA9IEFiaVBhcmFtZXRlcnMuZW5jb2RlKHN1ZmZpeFBhcmFtZXRlcnMsIFtcbiAgICAgICAge1xuICAgICAgICAgICAgLi4udmFsdWUuYXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgIGRlbGVnYXRpb246IHZhbHVlLmF1dGhvcml6YXRpb24uYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQ6IEJpZ0ludCh2YWx1ZS5hdXRob3JpemF0aW9uLmNoYWluSWQpLFxuICAgICAgICB9LFxuICAgICAgICB2YWx1ZS50byA/PyBzZWxmLFxuICAgICAgICBkYXRhID8/ICcweCcsXG4gICAgXSk7XG4gICAgY29uc3Qgc3VmZml4TGVuZ3RoID0gSGV4LmZyb21OdW1iZXIoSGV4LnNpemUoc3VmZml4KSwgeyBzaXplOiAzMiB9KTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChzaWduYXR1cmUsIHN1ZmZpeCwgc3VmZml4TGVuZ3RoLCBtYWdpY0J5dGVzKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgd3JhcHBlZCBzaWduYXR1cmUuIFJldHVybnMgYHRydWVgIGlmIHRoZSB3cmFwcGVkIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFcmM4MDEwIH0gZnJvbSAnb3gvZXJjODAxMCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZUVyYzgwMTAudmFsaWRhdGUoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBFUkMtODAxMCB3cmFwcGVkIHNpZ25hdHVyZSBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVkKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3dyYXBwZWR9XFxgIGlzIGFuIGludmFsaWQgRVJDLTgwMTAgd3JhcHBlZCBzaWduYXR1cmUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmVFcmM4MDEwLkludmFsaWRXcmFwcGVkU2lnbmF0dXJlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hdHVyZUVyYzgwMTAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/erc8010/SignatureErc8010.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/AuthorizationTempo.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/AuthorizationTempo.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcList: () => (/* binding */ fromRpcList),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcList: () => (/* binding */ toRpcList),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _core_Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Rlp.js */ \"(ssr)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SignatureEnvelope.js */ \"(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js\");\n\n\n\n\n/**\n * Converts an EIP-7702 Authorization object into a typed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * Tempo extends EIP-7702 to support secp256k1, P256, and WebAuthn signature types.\n *\n * [Tempo Authorization Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#tempo-authorization-list)\n *\n * @example\n * An Authorization can be instantiated from an EIP-7702 Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures (Secp256k1)\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (P256)\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key and a `prehash` flag indicating whether the payload was hashed\n * before signing.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = P256.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: false,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (P256 WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * hashes the payload internally before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = await WebCryptoP256.sign({\n *   payload: AuthorizationTempo.getSignPayload(authorization),\n *   privateKey,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: true,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @example\n * ### Attaching Signatures (WebAuthn)\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: AuthorizationTempo.getSignPayload(authorization),\n *   credentialId: credential.id,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n *\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple in object format.\n * @param options - AA Authorization options.\n * @returns The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nfunction from(authorization, options = {}) {\n    if (typeof authorization.chainId === 'string')\n        return fromRpc(authorization);\n    if (options.signature) {\n        return { ...authorization, signature: options.signature };\n    }\n    return authorization;\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.Rpc} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0',\n *   },\n * })\n * ```\n *\n * @param authorization - The RPC-formatted AA Authorization.\n * @returns A signed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nfunction fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc(authorization.signature);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        signature,\n    };\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.ListRpc} to an {@link ox#AuthorizationTempo.List}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0',\n *   },\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted AA Authorization list.\n * @returns A signed {@link ox#AuthorizationTempo.List}.\n */\nfunction fromRpcList(authorizationList) {\n    return authorizationList.map((x) => fromRpc(x));\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.Tuple} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a serialized SignatureEnvelope to the end of an AA Authorization tuple.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   signature: {\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple.\n * @returns The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nfunction fromTuple(tuple) {\n    const [chainId, address, nonce, signatureSerialized] = tuple;\n    const args = {\n        address,\n        chainId: chainId === '0x' ? 0 : Number(chainId),\n        nonce: nonce === '0x' ? 0n : BigInt(nonce),\n    };\n    if (signatureSerialized)\n        args.signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.deserialize(signatureSerialized);\n    return from(args);\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.TupleList} to an {@link ox#AuthorizationTempo.List}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a serialized SignatureEnvelope to the end of an AA Authorization tuple.\n *\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorizationList = AuthorizationTempo.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     signature: {\n * // @log:       r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:       s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:       yParity: 0,\n * // @log:     },\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     signature: {\n * // @log:       r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:       s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:       yParity: 0,\n * // @log:     },\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple list.\n * @returns An {@link ox#AuthorizationTempo.List}.\n */\nfunction fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)\n        list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#AuthorizationTempo.AuthorizationTempo} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ### Secp256k1\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature }\n * )\n * ```\n *\n * @example\n * ### P256\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key and a `prehash` flag indicating whether the payload was hashed\n * before signing.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = P256.sign({ payload, privateKey })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   prehash: false,\n *   publicKey,\n *   signature,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @example\n * ### P256 (WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * hashes the payload internally before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const signature = await WebCryptoP256.sign({ payload, privateKey })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   prehash: true,\n *   publicKey,\n *   signature,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @example\n * ### WebAuthn\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { AuthorizationTempo, SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const challenge = AuthorizationTempo.getSignPayload(authorization) // [!code focus]\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge,\n *   credentialId: credential.id,\n * })\n * const signatureEnvelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n * const authorization_signed = AuthorizationTempo.from(\n *   authorization,\n *   { signature: signatureEnvelope }\n * )\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns The sign payload.\n */\nfunction getSignPayload(authorization) {\n    return hash(authorization, { presign: true });\n}\n/**\n * Computes the hash for an {@link ox#AuthorizationTempo.AuthorizationTempo} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = AuthorizationTempo.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns The hash.\n */\nfunction hash(authorization, options = {}) {\n    const { presign } = options;\n    return _core_Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat('0x05', _core_Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(presign\n        ? {\n            address: authorization.address,\n            chainId: authorization.chainId,\n            nonce: authorization.nonce,\n        }\n        : authorization))));\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.AuthorizationTempo} to an {@link ox#AuthorizationTempo.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * })\n * ```\n *\n * @param authorization - An AA Authorization.\n * @returns An RPC-formatted AA Authorization.\n */\nfunction toRpc(authorization) {\n    const { address, chainId, nonce, signature } = authorization;\n    return {\n        address,\n        chainId: _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        signature: _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature),\n    };\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.List} to an {@link ox#AuthorizationTempo.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * }])\n * ```\n *\n * @param authorizationList - An AA Authorization List.\n * @returns An RPC-formatted AA Authorization List.\n */\nfunction toRpcList(authorizationList) {\n    return authorizationList.map((x) => toRpc(x));\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.AuthorizationTempo} to an {@link ox#AuthorizationTempo.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = AuthorizationTempo.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#AuthorizationTempo.AuthorizationTempo}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple.\n */\nfunction toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = authorization.signature\n        ? _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.serialize(authorization.signature)\n        : undefined;\n    return [\n        chainId ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : '0x',\n        address,\n        nonce ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : '0x',\n        ...(signature ? [signature] : []),\n    ];\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.List} to an {@link ox#AuthorizationTempo.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { AuthorizationTempo } from 'ox/tempo'\n *\n * const authorization_1 = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = AuthorizationTempo.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = AuthorizationTempo.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#AuthorizationTempo.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) AA Authorization tuple list.\n */\nfunction toTupleList(list) {\n    if (!list || list.length === 0)\n        return [];\n    const tupleList = [];\n    for (const authorization of list)\n        tupleList.push(toTuple(authorization));\n    return tupleList;\n}\n//# sourceMappingURL=AuthorizationTempo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9BdXRob3JpemF0aW9uVGVtcG8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0Y7QUFDQTtBQUNzQjtBQUM1RDtBQUNBLDJEQUEyRCwrQ0FBK0M7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU8sV0FBVztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxPQUFPLDhCQUE4QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU8sOEJBQThCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLHdDQUF3QztBQUNwRDtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsT0FBTyw4QkFBOEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQ0FBK0M7QUFDaEU7QUFDTyx5Q0FBeUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQyxPQUFPLCtDQUErQztBQUN2RztBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtDQUErQztBQUNyRTtBQUNPO0FBQ1AsWUFBWSwwQkFBMEI7QUFDdEMsc0JBQXNCLDBEQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFDQUFxQyxPQUFPLGlDQUFpQztBQUM3RjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQyxPQUFPLCtDQUErQztBQUN6RztBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtDQUErQztBQUNoRTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOERBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUMsT0FBTyxpQ0FBaUM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnREFBZ0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQ0FBK0M7QUFDOUU7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBLDZCQUE2QixnREFBZ0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQ0FBK0M7QUFDOUU7QUFDQTtBQUNPLHlDQUF5QztBQUNoRCxZQUFZLFVBQVU7QUFDdEIsV0FBVyxvREFBYyxDQUFDLGdEQUFVLFNBQVMsaURBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBZ0QsT0FBTyxnQ0FBZ0M7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQWM7QUFDL0IsZUFBZSxvREFBYztBQUM3QixtQkFBbUIsd0RBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0MsT0FBTyxvQ0FBb0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnREFBZ0QsT0FBTyxrQ0FBa0M7QUFDekc7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0NBQStDO0FBQzlFO0FBQ0E7QUFDTztBQUNQLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0EsVUFBVSw0REFBMkI7QUFDckM7QUFDQTtBQUNBLGtCQUFrQixvREFBYztBQUNoQztBQUNBLGdCQUFnQixvREFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0MsT0FBTyxzQ0FBc0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L19lc20vdGVtcG8vQXV0aG9yaXphdGlvblRlbXBvLmpzPzJiNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuLi9jb3JlL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuLi9jb3JlL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmVFbnZlbG9wZSBmcm9tICcuL1NpZ25hdHVyZUVudmVsb3BlLmpzJztcbi8qKlxuICogQ29udmVydHMgYW4gRUlQLTc3MDIgQXV0aG9yaXphdGlvbiBvYmplY3QgaW50byBhIHR5cGVkIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uQXV0aG9yaXphdGlvblRlbXBvfS5cbiAqXG4gKiBUZW1wbyBleHRlbmRzIEVJUC03NzAyIHRvIHN1cHBvcnQgc2VjcDI1NmsxLCBQMjU2LCBhbmQgV2ViQXV0aG4gc2lnbmF0dXJlIHR5cGVzLlxuICpcbiAqIFtUZW1wbyBBdXRob3JpemF0aW9uIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vZG9jcy50ZW1wby54eXovcHJvdG9jb2wvdHJhbnNhY3Rpb25zL3NwZWMtdGVtcG8tdHJhbnNhY3Rpb24jdGVtcG8tYXV0aG9yaXphdGlvbi1saXN0KVxuICpcbiAqIEBleGFtcGxlXG4gKiBBbiBBdXRob3JpemF0aW9uIGNhbiBiZSBpbnN0YW50aWF0ZWQgZnJvbSBhbiBFSVAtNzcwMiBBdXRob3JpemF0aW9uIHR1cGxlIGluIG9iamVjdCBmb3JtYXQuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXMgKFNlY3AyNTZrMSlcbiAqXG4gKiBTdGFuZGFyZCBFdGhlcmV1bSBFQ0RTQSBzaWduYXR1cmUgdXNpbmcgdGhlIHNlY3AyNTZrMSBjdXJ2ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gU2VjcDI1NmsxLnJhbmRvbVByaXZhdGVLZXkoKVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IEF1dGhvcml6YXRpb25UZW1wby5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleSxcbiAqIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl9zaWduZWQgPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbShcbiAqICAgYXV0aG9yaXphdGlvbixcbiAqICAgeyBzaWduYXR1cmUgfSwgLy8gWyFjb2RlIGZvY3VzXVxuICogKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlcyAoUDI1NilcbiAqXG4gKiBFQ0RTQSBzaWduYXR1cmUgdXNpbmcgdGhlIFAtMjU2IChzZWNwMjU2cjEpIGN1cnZlLiBSZXF1aXJlcyBlbWJlZGRpbmcgdGhlXG4gKiBwdWJsaWMga2V5IGFuZCBhIGBwcmVoYXNoYCBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGF5bG9hZCB3YXMgaGFzaGVkXG4gKiBiZWZvcmUgc2lnbmluZy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUDI1NiB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvLCBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0gPSBQMjU2LmNyZWF0ZUtleVBhaXIoKVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBQMjU2LnNpZ24oe1xuICogICBwYXlsb2FkOiBBdXRob3JpemF0aW9uVGVtcG8uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbiksXG4gKiAgIHByaXZhdGVLZXksXG4gKiB9KVxuICogY29uc3Qgc2lnbmF0dXJlRW52ZWxvcGUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tKHtcbiAqICAgc2lnbmF0dXJlLFxuICogICBwdWJsaWNLZXksXG4gKiAgIHByZWhhc2g6IGZhbHNlLFxuICogfSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uX3NpZ25lZCA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKFxuICogICBhdXRob3JpemF0aW9uLFxuICogICB7IHNpZ25hdHVyZTogc2lnbmF0dXJlRW52ZWxvcGUgfSwgLy8gWyFjb2RlIGZvY3VzXVxuICogKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlcyAoUDI1NiBXZWJDcnlwdG8pXG4gKlxuICogV2hlbiB1c2luZyBXZWJDcnlwdG8ga2V5cywgYHByZWhhc2hgIG11c3QgYmUgYHRydWVgIHNpbmNlIFdlYkNyeXB0byBhbHdheXNcbiAqIGhhc2hlcyB0aGUgcGF5bG9hZCBpbnRlcm5hbGx5IGJlZm9yZSBzaWduaW5nLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFdlYkNyeXB0b1AyNTYgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbywgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gYXdhaXQgV2ViQ3J5cHRvUDI1Ni5jcmVhdGVLZXlQYWlyKClcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDQwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgV2ViQ3J5cHRvUDI1Ni5zaWduKHtcbiAqICAgcGF5bG9hZDogQXV0aG9yaXphdGlvblRlbXBvLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBwcml2YXRlS2V5LFxuICogfSlcbiAqIGNvbnN0IHNpZ25hdHVyZUVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbSh7XG4gKiAgIHNpZ25hdHVyZSxcbiAqICAgcHVibGljS2V5LFxuICogICBwcmVoYXNoOiB0cnVlLFxuICogfSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uX3NpZ25lZCA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKFxuICogICBhdXRob3JpemF0aW9uLFxuICogICB7IHNpZ25hdHVyZTogc2lnbmF0dXJlRW52ZWxvcGUgfSwgLy8gWyFjb2RlIGZvY3VzXVxuICogKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlcyAoV2ViQXV0aG4pXG4gKlxuICogUGFzc2tleS1iYXNlZCBzaWduYXR1cmUgdXNpbmcgV2ViQXV0aG4uIEluY2x1ZGVzIGF1dGhlbnRpY2F0b3IgbWV0YWRhdGFcbiAqIChhdXRoZW50aWNhdG9yRGF0YSBhbmQgY2xpZW50RGF0YUpTT04pIGFsb25nIHdpdGggdGhlIFAtMjU2IHNpZ25hdHVyZSBhbmRcbiAqIHB1YmxpYyBrZXkuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8sIFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgY3JlZGVudGlhbCA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5jcmVhdGVDcmVkZW50aWFsKHsgbmFtZTogJ0V4YW1wbGUnIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA0MG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHsgbWV0YWRhdGEsIHNpZ25hdHVyZSB9ID0gYXdhaXQgV2ViQXV0aG5QMjU2LnNpZ24oe1xuICogICBjaGFsbGVuZ2U6IEF1dGhvcml6YXRpb25UZW1wby5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgY3JlZGVudGlhbElkOiBjcmVkZW50aWFsLmlkLFxuICogfSlcbiAqIGNvbnN0IHNpZ25hdHVyZUVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbSh7XG4gKiAgIHNpZ25hdHVyZSxcbiAqICAgcHVibGljS2V5OiBjcmVkZW50aWFsLnB1YmxpY0tleSxcbiAqICAgbWV0YWRhdGEsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oXG4gKiAgIGF1dGhvcml6YXRpb24sXG4gKiAgIHsgc2lnbmF0dXJlOiBzaWduYXR1cmVFbnZlbG9wZSB9LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBQSBBdXRob3JpemF0aW9uIHR1cGxlIGluIG9iamVjdCBmb3JtYXQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFBIEF1dGhvcml6YXRpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGF1dGhvcml6YXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgYXV0aG9yaXphdGlvbi5jaGFpbklkID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21ScGMoYXV0aG9yaXphdGlvbik7XG4gICAgaWYgKG9wdGlvbnMuc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiB7IC4uLmF1dGhvcml6YXRpb24sIHNpZ25hdHVyZTogb3B0aW9ucy5zaWduYXR1cmUgfTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb247XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uUnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb21ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogJzB4MScsXG4gKiAgIG5vbmNlOiAnMHgxJyxcbiAqICAgc2lnbmF0dXJlOiB7XG4gKiAgICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgICAgcjogJzB4NjM1ZGMyMDMzZTYwMTg1YmIzNjcwOWMyOWM3NWQ2NGVhNTFkZmJkOTFjMzJlZjRiZTE5OGU0Y2ViMTY5ZmI0ZCcsXG4gKiAgICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgICAgeVBhcml0eTogJzB4MCcsXG4gKiAgIH0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUgUlBDLWZvcm1hdHRlZCBBQSBBdXRob3JpemF0aW9uLlxuICogQHJldHVybnMgQSBzaWduZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5BdXRob3JpemF0aW9uVGVtcG99LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tUnBjKGF1dGhvcml6YXRpb24uc2lnbmF0dXJlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBCaWdJbnQobm9uY2UpLFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5MaXN0UnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkxpc3R9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbVJwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6ICcweDEnLFxuICogICBub25jZTogJzB4MScsXG4gKiAgIHNpZ25hdHVyZToge1xuICogICAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICAgIHlQYXJpdHk6ICcweDAnLFxuICogICB9LFxuICogfV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbkxpc3QgLSBUaGUgUlBDLWZvcm1hdHRlZCBBQSBBdXRob3JpemF0aW9uIGxpc3QuXG4gKiBAcmV0dXJucyBBIHNpZ25lZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkxpc3R9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwY0xpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbkxpc3QubWFwKCh4KSA9PiBmcm9tUnBjKHgpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5UdXBsZX0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5BdXRob3JpemF0aW9uVGVtcG99LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tVHVwbGUoW1xuICogICAnMHgxJyxcbiAqICAgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgICcweDMnXG4gKiBdKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDNuXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhcHBlbmQgYSBzZXJpYWxpemVkIFNpZ25hdHVyZUVudmVsb3BlIHRvIHRoZSBlbmQgb2YgYW4gQUEgQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tVHVwbGUoW1xuICogICAnMHgxJyxcbiAqICAgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgICcweDMnLFxuICogICAnMHgwMWEwNjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnLFxuICogXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiAzblxuICogLy8gQGxvZzogICBzaWduYXR1cmU6IHtcbiAqIC8vIEBsb2c6ICAgICByOiBCaWdJbnQoJzB4NjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MCcpLFxuICogLy8gQGxvZzogICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6ICAgfSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0dXBsZSAtIFRoZSBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQUEgQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGUodHVwbGUpIHtcbiAgICBjb25zdCBbY2hhaW5JZCwgYWRkcmVzcywgbm9uY2UsIHNpZ25hdHVyZVNlcmlhbGl6ZWRdID0gdHVwbGU7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogY2hhaW5JZCA9PT0gJzB4JyA/IDAgOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBub25jZSA9PT0gJzB4JyA/IDBuIDogQmlnSW50KG5vbmNlKSxcbiAgICB9O1xuICAgIGlmIChzaWduYXR1cmVTZXJpYWxpemVkKVxuICAgICAgICBhcmdzLnNpZ25hdHVyZSA9IFNpZ25hdHVyZUVudmVsb3BlLmRlc2VyaWFsaXplKHNpZ25hdHVyZVNlcmlhbGl6ZWQpO1xuICAgIHJldHVybiBmcm9tKGFyZ3MpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLlR1cGxlTGlzdH0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5MaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb21UdXBsZUxpc3QoW1xuICogICBbJzB4MScsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgzJ10sXG4gKiAgIFsnMHgzJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDE0J10sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogM24sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhcHBlbmQgYSBzZXJpYWxpemVkIFNpZ25hdHVyZUVudmVsb3BlIHRvIHRoZSBlbmQgb2YgYW4gQUEgQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbVR1cGxlTGlzdChbXG4gKiAgIFsnMHgxJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDMnLCAnMHgwMWEwNjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnXSxcbiAqICAgWycweDMnLCAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJywgJzB4MTQnLCAnMHgwMWEwNjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAzbixcbiAqIC8vIEBsb2c6ICAgICBzaWduYXR1cmU6IHtcbiAqIC8vIEBsb2c6ICAgICAgIHI6IEJpZ0ludCgnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyksXG4gKiAvLyBAbG9nOiAgICAgICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICAgICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6ICAgICB9LFxuICogLy8gQGxvZzogICB9LFxuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMyxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogMjBuLFxuICogLy8gQGxvZzogICAgIHNpZ25hdHVyZToge1xuICogLy8gQGxvZzogICAgICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgICAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgICAgICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogICAgIH0sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGVMaXN0IC0gVGhlIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBQSBBdXRob3JpemF0aW9uIHR1cGxlIGxpc3QuXG4gKiBAcmV0dXJucyBBbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkxpc3R9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlTGlzdCh0dXBsZUxpc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChjb25zdCB0dXBsZSBvZiB0dXBsZUxpc3QpXG4gICAgICAgIGxpc3QucHVzaChmcm9tVHVwbGUodHVwbGUpKTtcbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNpZ24gcGF5bG9hZCBmb3IgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5BdXRob3JpemF0aW9uVGVtcG99IGluIFtFSVAtNzcwMiBmb3JtYXRdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMik6IGBrZWNjYWsyNTYoJzB4MDUnIHx8IHJscChbY2hhaW5faWQsIGFkZHJlc3MsIG5vbmNlXSkpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFNlY3AyNTZrMVxuICpcbiAqIFN0YW5kYXJkIEV0aGVyZXVtIEVDRFNBIHNpZ25hdHVyZSB1c2luZyB0aGUgc2VjcDI1NmsxIGN1cnZlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSBTZWNwMjU2azEucmFuZG9tUHJpdmF0ZUtleSgpXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBBdXRob3JpemF0aW9uVGVtcG8uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZCwgcHJpdmF0ZUtleSB9KVxuICogY29uc3QgYXV0aG9yaXphdGlvbl9zaWduZWQgPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbShcbiAqICAgYXV0aG9yaXphdGlvbixcbiAqICAgeyBzaWduYXR1cmUgfVxuICogKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBQMjU2XG4gKlxuICogRUNEU0Egc2lnbmF0dXJlIHVzaW5nIHRoZSBQLTI1NiAoc2VjcDI1NnIxKSBjdXJ2ZS4gUmVxdWlyZXMgZW1iZWRkaW5nIHRoZVxuICogcHVibGljIGtleSBhbmQgYSBgcHJlaGFzaGAgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHBheWxvYWQgd2FzIGhhc2hlZFxuICogYmVmb3JlIHNpZ25pbmcuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFAyNTYgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbywgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9ID0gUDI1Ni5jcmVhdGVLZXlQYWlyKClcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IEF1dGhvcml6YXRpb25UZW1wby5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gUDI1Ni5zaWduKHsgcGF5bG9hZCwgcHJpdmF0ZUtleSB9KVxuICogY29uc3Qgc2lnbmF0dXJlRW52ZWxvcGUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tKHtcbiAqICAgcHJlaGFzaDogZmFsc2UsXG4gKiAgIHB1YmxpY0tleSxcbiAqICAgc2lnbmF0dXJlLFxuICogfSlcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oXG4gKiAgIGF1dGhvcml6YXRpb24sXG4gKiAgIHsgc2lnbmF0dXJlOiBzaWduYXR1cmVFbnZlbG9wZSB9XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFAyNTYgKFdlYkNyeXB0bylcbiAqXG4gKiBXaGVuIHVzaW5nIFdlYkNyeXB0byBrZXlzLCBgcHJlaGFzaGAgbXVzdCBiZSBgdHJ1ZWAgc2luY2UgV2ViQ3J5cHRvIGFsd2F5c1xuICogaGFzaGVzIHRoZSBwYXlsb2FkIGludGVybmFsbHkgYmVmb3JlIHNpZ25pbmcuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgV2ViQ3J5cHRvUDI1NiB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvLCBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0gPSBhd2FpdCBXZWJDcnlwdG9QMjU2LmNyZWF0ZUtleVBhaXIoKVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gQXV0aG9yaXphdGlvblRlbXBvLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5IH0pXG4gKiBjb25zdCBzaWduYXR1cmVFbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oe1xuICogICBwcmVoYXNoOiB0cnVlLFxuICogICBwdWJsaWNLZXksXG4gKiAgIHNpZ25hdHVyZSxcbiAqIH0pXG4gKiBjb25zdCBhdXRob3JpemF0aW9uX3NpZ25lZCA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tKFxuICogICBhdXRob3JpemF0aW9uLFxuICogICB7IHNpZ25hdHVyZTogc2lnbmF0dXJlRW52ZWxvcGUgfVxuICogKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBXZWJBdXRoblxuICpcbiAqIFBhc3NrZXktYmFzZWQgc2lnbmF0dXJlIHVzaW5nIFdlYkF1dGhuLiBJbmNsdWRlcyBhdXRoZW50aWNhdG9yIG1ldGFkYXRhXG4gKiAoYXV0aGVudGljYXRvckRhdGEgYW5kIGNsaWVudERhdGFKU09OKSBhbG9uZyB3aXRoIHRoZSBQLTI1NiBzaWduYXR1cmUgYW5kXG4gKiBwdWJsaWMga2V5LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFdlYkF1dGhuUDI1NiB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvLCBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCBXZWJBdXRoblAyNTYuY3JlYXRlQ3JlZGVudGlhbCh7IG5hbWU6ICdFeGFtcGxlJyB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBjaGFsbGVuZ2UgPSBBdXRob3JpemF0aW9uVGVtcG8uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHsgbWV0YWRhdGEsIHNpZ25hdHVyZSB9ID0gYXdhaXQgV2ViQXV0aG5QMjU2LnNpZ24oe1xuICogICBjaGFsbGVuZ2UsXG4gKiAgIGNyZWRlbnRpYWxJZDogY3JlZGVudGlhbC5pZCxcbiAqIH0pXG4gKiBjb25zdCBzaWduYXR1cmVFbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oe1xuICogICBzaWduYXR1cmUsXG4gKiAgIHB1YmxpY0tleTogY3JlZGVudGlhbC5wdWJsaWNLZXksXG4gKiAgIG1ldGFkYXRhLFxuICogfSlcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oXG4gKiAgIGF1dGhvcml6YXRpb24sXG4gKiAgIHsgc2lnbmF0dXJlOiBzaWduYXR1cmVFbnZlbG9wZSB9XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKiBAcmV0dXJucyBUaGUgc2lnbiBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbikge1xuICAgIHJldHVybiBoYXNoKGF1dGhvcml6YXRpb24sIHsgcHJlc2lnbjogdHJ1ZSB9KTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGhhc2ggZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uQXV0aG9yaXphdGlvblRlbXBvfSBpbiBbRUlQLTc3MDIgZm9ybWF0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpOiBga2VjY2FrMjU2KCcweDA1JyB8fCBybHAoW2NoYWluX2lkLCBhZGRyZXNzLCBub25jZV0pKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IEF1dGhvcml6YXRpb25UZW1wby5oYXNoKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uQXV0aG9yaXphdGlvblRlbXBvfS5cbiAqIEByZXR1cm5zIFRoZSBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChhdXRob3JpemF0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHByZXNpZ24gfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KEhleC5jb25jYXQoJzB4MDUnLCBSbHAuZnJvbUhleCh0b1R1cGxlKHByZXNpZ25cbiAgICAgICAgPyB7XG4gICAgICAgICAgICBhZGRyZXNzOiBhdXRob3JpemF0aW9uLmFkZHJlc3MsXG4gICAgICAgICAgICBjaGFpbklkOiBhdXRob3JpemF0aW9uLmNoYWluSWQsXG4gICAgICAgICAgICBub25jZTogYXV0aG9yaXphdGlvbi5ub25jZSxcbiAgICAgICAgfVxuICAgICAgICA6IGF1dGhvcml6YXRpb24pKSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb25UZW1wby50b1JwYyh7XG4gKiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMW4sXG4gKiAgIHNpZ25hdHVyZToge1xuICogICAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICAgIHNpZ25hdHVyZToge1xuICogICAgICAgcjogNDQ5NDQ2Mjc4MTMwMDc3NzI4OTczOTE1MzEyMzAwODE2OTUxMDI3MDMyODkxMjMzMzIxODc2OTYxMTUxODExMDQ3MzkyMzkxOTc1MTduLFxuICogICAgICAgczogMzY1Mjg1MDM1MDUxOTI0MzgzMDczNTUxNjQ0NDExMDQwMDEzMTA1NjY1MDUzNTE5ODAzNjkwODUyMDgxNzg3MTI2Nzg3OTkxODExMjBuLFxuICogICAgICAgeVBhcml0eTogMCxcbiAqICAgICB9LFxuICogICB9LFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gQW4gQUEgQXV0aG9yaXphdGlvbi5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgQUEgQXV0aG9yaXphdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlLCBzaWduYXR1cmUgfSA9IGF1dGhvcml6YXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBIZXguZnJvbU51bWJlcihub25jZSksXG4gICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlRW52ZWxvcGUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkxpc3R9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uTGlzdFJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvblRlbXBvLnRvUnBjTGlzdChbe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDFuLFxuICogICBzaWduYXR1cmU6IHtcbiAqICAgICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAqICAgICBzaWduYXR1cmU6IHtcbiAqICAgICAgIHI6IDQ0OTQ0NjI3ODEzMDA3NzcyODk3MzkxNTMxMjMwMDgxNjk1MTAyNzAzMjg5MTIzMzMyMTg3Njk2MTE1MTgxMTA0NzM5MjM5MTk3NTE3bixcbiAqICAgICAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgICAgIHlQYXJpdHk6IDAsXG4gKiAgICAgfSxcbiAqICAgfSxcbiAqIH1dKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb25MaXN0IC0gQW4gQUEgQXV0aG9yaXphdGlvbiBMaXN0LlxuICogQHJldHVybnMgQW4gUlBDLWZvcm1hdHRlZCBBQSBBdXRob3JpemF0aW9uIExpc3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwY0xpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbkxpc3QubWFwKCh4KSA9PiB0b1JwYyh4KSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uQXV0aG9yaXphdGlvblRlbXBvfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLlR1cGxlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb25UZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCB0dXBsZSA9IEF1dGhvcml6YXRpb25UZW1wby50b1R1cGxlKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKiBAcmV0dXJucyBBbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQUEgQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGUoYXV0aG9yaXphdGlvbikge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCwgbm9uY2UgfSA9IGF1dGhvcml6YXRpb247XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXV0aG9yaXphdGlvbi5zaWduYXR1cmVcbiAgICAgICAgPyBTaWduYXR1cmVFbnZlbG9wZS5zZXJpYWxpemUoYXV0aG9yaXphdGlvbi5zaWduYXR1cmUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBbXG4gICAgICAgIGNoYWluSWQgPyBIZXguZnJvbU51bWJlcihjaGFpbklkKSA6ICcweCcsXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIG5vbmNlID8gSGV4LmZyb21OdW1iZXIobm9uY2UpIDogJzB4JyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFtzaWduYXR1cmVdIDogW10pLFxuICAgIF07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uTGlzdH0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb25UZW1wby5UdXBsZUxpc3R9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvblRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl8xID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKiBjb25zdCBhdXRob3JpemF0aW9uXzIgPSBBdXRob3JpemF0aW9uVGVtcG8uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAzLFxuICogICBub25jZTogMjBuLFxuICogfSlcbiAqXG4gKiBjb25zdCB0dXBsZSA9IEF1dGhvcml6YXRpb25UZW1wby50b1R1cGxlTGlzdChbYXV0aG9yaXphdGlvbl8xLCBhdXRob3JpemF0aW9uXzJdKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGlzdCAtIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uTGlzdH0uXG4gKiBAcmV0dXJucyBBbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQUEgQXV0aG9yaXphdGlvbiB0dXBsZSBsaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZUxpc3QobGlzdCkge1xuICAgIGlmICghbGlzdCB8fCBsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHR1cGxlTGlzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgYXV0aG9yaXphdGlvbiBvZiBsaXN0KVxuICAgICAgICB0dXBsZUxpc3QucHVzaCh0b1R1cGxlKGF1dGhvcml6YXRpb24pKTtcbiAgICByZXR1cm4gdHVwbGVMaXN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aG9yaXphdGlvblRlbXBvLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/AuthorizationTempo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/KeyAuthorization.js":
/*!********************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/KeyAuthorization.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toTuple: () => (/* binding */ toTuple)\n/* harmony export */ });\n/* harmony import */ var _core_Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Rlp.js */ \"(ssr)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SignatureEnvelope.js */ \"(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js\");\n\n\n\n\n/**\n * Converts a Key Authorization object into a typed {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * Use this to create an unsigned key authorization, then sign it with the root key using\n * {@link ox#KeyAuthorization.(getSignPayload:function)} and attach the signature. The signed authorization\n * can be included in a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} via the\n * `keyAuthorization` field to provision the access key on-chain.\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n *\n * @example\n * ### Secp256k1 Key\n *\n * Standard Ethereum ECDSA key using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n * ```\n *\n * @example\n * ### WebCryptoP256 Key\n *\n * ```ts twoslash\n * import { Address, WebCryptoP256, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n * const address = Address.fromPublicKey(keyPair.publicKey)\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'p256',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures (Secp256k1)\n *\n * Attach a signature to a Key Authorization using a Secp256k1 private key to\n * authorize another Secp256k1 key on the account.\n *\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = '0x...'\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const rootPrivateKey = '0x...'\n * const signature = Secp256k1.sign({\n *   payload: KeyAuthorization.getSignPayload(authorization),\n *   privateKey: rootPrivateKey,\n * })\n *\n * const authorization_signed = KeyAuthorization.from(authorization, { signature })\n * ```\n *\n * @example\n * ### Attaching Signatures (WebAuthn)\n *\n * Attach a signature to a Key Authorization using a WebAuthn credential to\n * authorize a new WebCryptoP256 key on the account.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Address, Value, WebCryptoP256, WebAuthnP256 } from 'ox'\n * import { KeyAuthorization, SignatureEnvelope } from 'ox/tempo'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n * const address = Address.fromPublicKey(keyPair.publicKey)\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'p256',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: KeyAuthorization.getSignPayload(authorization),\n *   credentialId: credential.id,\n * })\n *\n * const signatureEnvelope = SignatureEnvelope.from({ // [!code focus]\n *   signature, // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   metadata, // [!code focus]\n * })\n * const authorization_signed = KeyAuthorization.from(\n *   authorization,\n *   { signature: signatureEnvelope }, // [!code focus]\n * )\n * ```\n *\n * @param authorization - A Key Authorization tuple in object format.\n * @param options - Key Authorization options.\n * @returns The {@link ox#KeyAuthorization.KeyAuthorization}.\n */\nfunction from(authorization, options = {}) {\n    if (typeof authorization.expiry === 'string')\n        return fromRpc(authorization);\n    if (options.signature)\n        return {\n            ...authorization,\n            signature: _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.from(options.signature),\n        };\n    return authorization;\n}\n/**\n * Converts an {@link ox#AuthorizationTempo.Rpc} to an {@link ox#AuthorizationTempo.AuthorizationTempo}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const keyAuthorization = KeyAuthorization.fromRpc({\n *   expiry: '0x174876e800',\n *   keyId: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   keyType: 'secp256k1',\n *   limits: [{ token: '0x20c0000000000000000000000000000000000001', limit: '0xf4240' }],\n *   signature: {\n *     type: 'secp256k1',\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     yParity: '0x0'\n *   },\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Key Authorization.\n * @returns A signed {@link ox#AuthorizationTempo.AuthorizationTempo}.\n */\nfunction fromRpc(authorization) {\n    const { chainId = '0x0', keyId, expiry = 0, limits, keyType } = authorization;\n    const signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc(authorization.signature);\n    return {\n        address: keyId,\n        chainId: chainId === '0x' ? 0n : _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(chainId),\n        expiry: Number(expiry),\n        limits: limits?.map((limit) => ({\n            token: limit.token,\n            limit: BigInt(limit.limit),\n        })),\n        signature,\n        type: keyType,\n    };\n}\n/**\n * Converts an {@link ox#KeyAuthorization.Tuple} to an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const authorization = KeyAuthorization.fromTuple([\n *   [\n *     '0x',\n *     '0x00',\n *     '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *     '0x174876e800',\n *     [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n *   ],\n *   '0x01a068a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b907e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * ```\n *\n * @example\n * Unsigned Key Authorization tuple (no signature):\n *\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const authorization = KeyAuthorization.fromTuple([\n *   [\n *     '0x',\n *     '0x00',\n *     '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *     '0x174876e800',\n *     [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n *   ],\n * ])\n * ```\n *\n * @param tuple - The Key Authorization tuple.\n * @returns The {@link ox#KeyAuthorization.KeyAuthorization}.\n */\nfunction fromTuple(tuple) {\n    const [authorization, signatureSerialized] = tuple;\n    const [chainId, keyType_hex, keyId, expiry, limits] = authorization;\n    const keyType = (() => {\n        switch (keyType_hex) {\n            case '0x':\n            case '0x00':\n                return 'secp256k1';\n            case '0x01':\n                return 'p256';\n            case '0x02':\n                return 'webAuthn';\n            default:\n                throw new Error(`Invalid key type: ${keyType_hex}`);\n        }\n    })();\n    const args = {\n        address: keyId,\n        expiry: typeof expiry !== 'undefined' ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(expiry) : undefined,\n        type: keyType,\n        ...(chainId !== '0x' ? { chainId: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(chainId) } : {}),\n        ...(typeof expiry !== 'undefined' ? { expiry: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(expiry) } : {}),\n        ...(typeof limits !== 'undefined'\n            ? {\n                limits: limits.map(([token, limit]) => ({\n                    token,\n                    limit: BigInt(limit),\n                })),\n            }\n            : {}),\n    };\n    if (signatureSerialized)\n        args.signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.deserialize(signatureSerialized);\n    return from(args);\n}\n/**\n * Computes the sign payload for an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * The root key must sign this payload to authorize the access key. The resulting signature\n * is attached to the key authorization via {@link ox#KeyAuthorization.(from:function)} with the\n * `signature` option.\n *\n * [Access Keys Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#access-keys)\n *\n * @example\n * ```ts twoslash\n * import { Address, Secp256k1, Value } from 'ox'\n * import { KeyAuthorization } from 'ox/tempo'\n *\n * const privateKey = '0x...'\n * const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n *\n * const authorization = KeyAuthorization.from({\n *   address,\n *   expiry: 1234567890,\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6),\n *   }],\n * })\n *\n * const payload = KeyAuthorization.getSignPayload(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns The sign payload.\n */\nfunction getSignPayload(authorization) {\n    return hash(authorization);\n}\n/**\n * Computes the hash for an {@link ox#KeyAuthorization.KeyAuthorization}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.from({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n * })\n *\n * const hash = KeyAuthorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns The hash.\n */\nfunction hash(authorization) {\n    const [authorizationTuple] = toTuple(authorization);\n    const serialized = _core_Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(authorizationTuple);\n    return _core_Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(serialized);\n}\n/**\n * Converts an {@link ox#KeyAuthorization.KeyAuthorization} to an {@link ox#KeyAuthorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.toRpc({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n *   signature: {\n *     type: 'secp256k1',\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *   },\n * })\n * ```\n *\n * @param authorization - A Key Authorization.\n * @returns An RPC-formatted Key Authorization.\n */\nfunction toRpc(authorization) {\n    const { address, chainId = 0n, expiry, limits, type, signature, } = authorization;\n    return {\n        chainId: chainId === 0n ? '0x' : _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(chainId),\n        expiry: typeof expiry === 'number' ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(expiry) : undefined,\n        limits: limits?.map(({ token, limit }) => ({\n            token,\n            limit: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(limit),\n        })),\n        keyId: address,\n        signature: _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature),\n        keyType: type,\n    };\n}\n/**\n * Converts an {@link ox#KeyAuthorization.KeyAuthorization} to an {@link ox#KeyAuthorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { KeyAuthorization } from 'ox/tempo'\n * import { Value } from 'ox'\n *\n * const authorization = KeyAuthorization.from({\n *   expiry: 1234567890,\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   type: 'secp256k1',\n *   limits: [{\n *     token: '0x20c0000000000000000000000000000000000001',\n *     limit: Value.from('10', 6)\n *   }],\n * })\n *\n * const tuple = KeyAuthorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   '0x174876e800',\n * // @log:   [['0x20c0000000000000000000000000000000000001', '0xf4240']],\n * // @log:   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   'secp256k1',\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#KeyAuthorization.KeyAuthorization}.\n * @returns A Tempo Key Authorization tuple.\n */\nfunction toTuple(authorization) {\n    const { address, chainId = 0n, expiry, limits } = authorization;\n    const signature = authorization.signature\n        ? _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.serialize(authorization.signature)\n        : undefined;\n    const type = (() => {\n        switch (authorization.type) {\n            case 'secp256k1':\n                return '0x';\n            case 'p256':\n                return '0x01';\n            case 'webAuthn':\n                return '0x02';\n            default:\n                throw new Error(`Invalid key type: ${authorization.type}`);\n        }\n    })();\n    const authorizationTuple = [\n        chainId === 0n ? '0x' : _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(chainId),\n        type,\n        address,\n        typeof expiry === 'number' ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(expiry) : undefined,\n        limits?.map((limit) => [limit.token, _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(limit.limit)]) ??\n            undefined,\n    ].filter(Boolean);\n    return [authorizationTuple, ...(signature ? [signature] : [])];\n}\n//# sourceMappingURL=KeyAuthorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9LZXlBdXRob3JpemF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0Y7QUFDQTtBQUNzQjtBQUM1RDtBQUNBLHFEQUFxRCwyQ0FBMkM7QUFDaEc7QUFDQTtBQUNBLElBQUkscURBQXFEO0FBQ3pELHlCQUF5QiwwQ0FBMEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QyxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0Esa0VBQWtFLFlBQVk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUMsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEMsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx1RUFBdUUsV0FBVztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFELFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0EseUNBQXlDLG9EQUFjO0FBQ3ZELDZDQUE2QyxvREFBYztBQUMzRCwrQkFBK0IsY0FBYztBQUM3QztBQUNBLG1CQUFtQixvREFBYztBQUNqQyxTQUFTO0FBQ1Q7QUFDQSxtQkFBbUIsd0RBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUE0QyxPQUFPLGdDQUFnQztBQUNuRztBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQTJDO0FBQzFFO0FBQ0E7QUFDTztBQUNQLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0EsVUFBVSw0REFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUJBQW1CO0FBQ3hFO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDLG9EQUFjO0FBQzlDO0FBQ0E7QUFDQSxxQ0FBcUMsb0RBQWM7QUFDbkQsNkNBQTZDLG9EQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL3RlbXBvL0tleUF1dGhvcml6YXRpb24uanM/YTMyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4uL2NvcmUvSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vY29yZS9IZXguanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4uL2NvcmUvUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZUVudmVsb3BlIGZyb20gJy4vU2lnbmF0dXJlRW52ZWxvcGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0cyBhIEtleSBBdXRob3JpemF0aW9uIG9iamVjdCBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0tleUF1dGhvcml6YXRpb24uS2V5QXV0aG9yaXphdGlvbn0uXG4gKlxuICogVXNlIHRoaXMgdG8gY3JlYXRlIGFuIHVuc2lnbmVkIGtleSBhdXRob3JpemF0aW9uLCB0aGVuIHNpZ24gaXQgd2l0aCB0aGUgcm9vdCBrZXkgdXNpbmdcbiAqIHtAbGluayBveCNLZXlBdXRob3JpemF0aW9uLihnZXRTaWduUGF5bG9hZDpmdW5jdGlvbil9IGFuZCBhdHRhY2ggdGhlIHNpZ25hdHVyZS4gVGhlIHNpZ25lZCBhdXRob3JpemF0aW9uXG4gKiBjYW4gYmUgaW5jbHVkZWQgaW4gYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30gdmlhIHRoZVxuICogYGtleUF1dGhvcml6YXRpb25gIGZpZWxkIHRvIHByb3Zpc2lvbiB0aGUgYWNjZXNzIGtleSBvbi1jaGFpbi5cbiAqXG4gKiBbQWNjZXNzIEtleXMgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbiNhY2Nlc3Mta2V5cylcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFNlY3AyNTZrMSBLZXlcbiAqXG4gKiBTdGFuZGFyZCBFdGhlcmV1bSBFQ0RTQSBrZXkgdXNpbmcgdGhlIHNlY3AyNTZrMSBjdXJ2ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcywgU2VjcDI1NmsxLCBWYWx1ZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgS2V5QXV0aG9yaXphdGlvbiB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSBTZWNwMjU2azEucmFuZG9tUHJpdmF0ZUtleSgpXG4gKiBjb25zdCBhZGRyZXNzID0gQWRkcmVzcy5mcm9tUHVibGljS2V5KFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pKVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBLZXlBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzLFxuICogICBleHBpcnk6IDEyMzQ1Njc4OTAsXG4gKiAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICBsaW1pdHM6IFt7XG4gKiAgICAgdG9rZW46ICcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICAgIGxpbWl0OiBWYWx1ZS5mcm9tKCcxMCcsIDYpLFxuICogICB9XSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFdlYkNyeXB0b1AyNTYgS2V5XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MsIFdlYkNyeXB0b1AyNTYsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3Qga2V5UGFpciA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuY3JlYXRlS2V5UGFpcigpXG4gKiBjb25zdCBhZGRyZXNzID0gQWRkcmVzcy5mcm9tUHVibGljS2V5KGtleVBhaXIucHVibGljS2V5KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBLZXlBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzLFxuICogICBleHBpcnk6IDEyMzQ1Njc4OTAsXG4gKiAgIHR5cGU6ICdwMjU2JyxcbiAqICAgbGltaXRzOiBbe1xuICogICAgIHRva2VuOiAnMHgyMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqICAgICBsaW1pdDogVmFsdWUuZnJvbSgnMTAnLCA2KSxcbiAqICAgfV0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlcyAoU2VjcDI1NmsxKVxuICpcbiAqIEF0dGFjaCBhIHNpZ25hdHVyZSB0byBhIEtleSBBdXRob3JpemF0aW9uIHVzaW5nIGEgU2VjcDI1NmsxIHByaXZhdGUga2V5IHRvXG4gKiBhdXRob3JpemUgYW5vdGhlciBTZWNwMjU2azEga2V5IG9uIHRoZSBhY2NvdW50LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzLCBTZWNwMjU2azEsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9ICcweC4uLidcbiAqIGNvbnN0IGFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkoU2VjcDI1NmsxLmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSkpXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3MsXG4gKiAgIGV4cGlyeTogMTIzNDU2Nzg5MCxcbiAqICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgIGxpbWl0czogW3tcbiAqICAgICB0b2tlbjogJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgbGltaXQ6IFZhbHVlLmZyb20oJzEwJywgNiksXG4gKiAgIH1dLFxuICogfSlcbiAqXG4gKiBjb25zdCByb290UHJpdmF0ZUtleSA9ICcweC4uLidcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogS2V5QXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleTogcm9vdFByaXZhdGVLZXksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25fc2lnbmVkID0gS2V5QXV0aG9yaXphdGlvbi5mcm9tKGF1dGhvcml6YXRpb24sIHsgc2lnbmF0dXJlIH0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzIChXZWJBdXRobilcbiAqXG4gKiBBdHRhY2ggYSBzaWduYXR1cmUgdG8gYSBLZXkgQXV0aG9yaXphdGlvbiB1c2luZyBhIFdlYkF1dGhuIGNyZWRlbnRpYWwgdG9cbiAqIGF1dGhvcml6ZSBhIG5ldyBXZWJDcnlwdG9QMjU2IGtleSBvbiB0aGUgYWNjb3VudC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBZGRyZXNzLCBWYWx1ZSwgV2ViQ3J5cHRvUDI1NiwgV2ViQXV0aG5QMjU2IH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uLCBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGtleVBhaXIgPSBhd2FpdCBXZWJDcnlwdG9QMjU2LmNyZWF0ZUtleVBhaXIoKVxuICogY29uc3QgYWRkcmVzcyA9IEFkZHJlc3MuZnJvbVB1YmxpY0tleShrZXlQYWlyLnB1YmxpY0tleSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzcyxcbiAqICAgZXhwaXJ5OiAxMjM0NTY3ODkwLFxuICogICB0eXBlOiAncDI1NicsXG4gKiAgIGxpbWl0czogW3tcbiAqICAgICB0b2tlbjogJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgbGltaXQ6IFZhbHVlLmZyb20oJzEwJywgNiksXG4gKiAgIH1dLFxuICogfSlcbiAqXG4gKiBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgV2ViQXV0aG5QMjU2LmNyZWF0ZUNyZWRlbnRpYWwoeyBuYW1lOiAnRXhhbXBsZScgfSlcbiAqXG4gKiBjb25zdCB7IG1ldGFkYXRhLCBzaWduYXR1cmUgfSA9IGF3YWl0IFdlYkF1dGhuUDI1Ni5zaWduKHtcbiAqICAgY2hhbGxlbmdlOiBLZXlBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBjcmVkZW50aWFsSWQ6IGNyZWRlbnRpYWwuaWQsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZUVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHB1YmxpY0tleTogY3JlZGVudGlhbC5wdWJsaWNLZXksIC8vIFshY29kZSBmb2N1c11cbiAqICAgbWV0YWRhdGEsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pXG4gKiBjb25zdCBhdXRob3JpemF0aW9uX3NpZ25lZCA9IEtleUF1dGhvcml6YXRpb24uZnJvbShcbiAqICAgYXV0aG9yaXphdGlvbixcbiAqICAgeyBzaWduYXR1cmU6IHNpZ25hdHVyZUVudmVsb3BlIH0sIC8vIFshY29kZSBmb2N1c11cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gQSBLZXkgQXV0aG9yaXphdGlvbiB0dXBsZSBpbiBvYmplY3QgZm9ybWF0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBLZXkgQXV0aG9yaXphdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNLZXlBdXRob3JpemF0aW9uLktleUF1dGhvcml6YXRpb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhdXRob3JpemF0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGF1dGhvcml6YXRpb24uZXhwaXJ5ID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21ScGMoYXV0aG9yaXphdGlvbik7XG4gICAgaWYgKG9wdGlvbnMuc2lnbmF0dXJlKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlRW52ZWxvcGUuZnJvbShvcHRpb25zLnNpZ25hdHVyZSksXG4gICAgICAgIH07XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb247XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uVGVtcG8uUnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3Qga2V5QXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24uZnJvbVJwYyh7XG4gKiAgIGV4cGlyeTogJzB4MTc0ODc2ZTgwMCcsXG4gKiAgIGtleUlkOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAga2V5VHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgIGxpbWl0czogW3sgdG9rZW46ICcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCBsaW1pdDogJzB4ZjQyNDAnIH1dLFxuICogICBzaWduYXR1cmU6IHtcbiAqICAgICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAqICAgICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgICB5UGFyaXR5OiAnMHgwJ1xuICogICB9LFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIFJQQy1mb3JtYXR0ZWQgS2V5IEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBIHNpZ25lZCB7QGxpbmsgb3gjQXV0aG9yaXphdGlvblRlbXBvLkF1dGhvcml6YXRpb25UZW1wb30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGNoYWluSWQgPSAnMHgwJywga2V5SWQsIGV4cGlyeSA9IDAsIGxpbWl0cywga2V5VHlwZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tUnBjKGF1dGhvcml6YXRpb24uc2lnbmF0dXJlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBrZXlJZCxcbiAgICAgICAgY2hhaW5JZDogY2hhaW5JZCA9PT0gJzB4JyA/IDBuIDogSGV4LnRvQmlnSW50KGNoYWluSWQpLFxuICAgICAgICBleHBpcnk6IE51bWJlcihleHBpcnkpLFxuICAgICAgICBsaW1pdHM6IGxpbWl0cz8ubWFwKChsaW1pdCkgPT4gKHtcbiAgICAgICAgICAgIHRva2VuOiBsaW1pdC50b2tlbixcbiAgICAgICAgICAgIGxpbWl0OiBCaWdJbnQobGltaXQubGltaXQpLFxuICAgICAgICB9KSksXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgdHlwZToga2V5VHlwZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5UdXBsZX0gdG8gYW4ge0BsaW5rIG94I0tleUF1dGhvcml6YXRpb24uS2V5QXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24uZnJvbVR1cGxlKFtcbiAqICAgW1xuICogICAgICcweCcsXG4gKiAgICAgJzB4MDAnLFxuICogICAgICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICAgICcweDE3NDg3NmU4MDAnLFxuICogICAgIFtbJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsICcweGY0MjQwJ11dLFxuICogICBdLFxuICogICAnMHgwMWEwNjhhMDIwYTIwOWQzZDU2YzQ2ZjM4Y2M1MGEzM2Y3MDRmNGE5YTEwYTU5Mzc3ZjhkZDc2MmFjNjY5MTBlOWI5MDdlODY1YWQwNWM0MDM1YWI1NzkyNzg3ZDRhMDI5N2E0MzYxN2FlODk3OTMwYTZmZTRkODIyYjhmYWVhNTIwNjQnLFxuICogXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBVbnNpZ25lZCBLZXkgQXV0aG9yaXphdGlvbiB0dXBsZSAobm8gc2lnbmF0dXJlKTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgS2V5QXV0aG9yaXphdGlvbiB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBLZXlBdXRob3JpemF0aW9uLmZyb21UdXBsZShbXG4gKiAgIFtcbiAqICAgICAnMHgnLFxuICogICAgICcweDAwJyxcbiAqICAgICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgICAnMHgxNzQ4NzZlODAwJyxcbiAqICAgICBbWycweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAnMHhmNDI0MCddXSxcbiAqICAgXSxcbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGUgLSBUaGUgS2V5IEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0tleUF1dGhvcml6YXRpb24uS2V5QXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGUodHVwbGUpIHtcbiAgICBjb25zdCBbYXV0aG9yaXphdGlvbiwgc2lnbmF0dXJlU2VyaWFsaXplZF0gPSB0dXBsZTtcbiAgICBjb25zdCBbY2hhaW5JZCwga2V5VHlwZV9oZXgsIGtleUlkLCBleHBpcnksIGxpbWl0c10gPSBhdXRob3JpemF0aW9uO1xuICAgIGNvbnN0IGtleVR5cGUgPSAoKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGtleVR5cGVfaGV4KSB7XG4gICAgICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgICBjYXNlICcweDAwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3NlY3AyNTZrMSc7XG4gICAgICAgICAgICBjYXNlICcweDAxJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3AyNTYnO1xuICAgICAgICAgICAgY2FzZSAnMHgwMic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd3ZWJBdXRobic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBrZXkgdHlwZTogJHtrZXlUeXBlX2hleH1gKTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgYWRkcmVzczoga2V5SWQsXG4gICAgICAgIGV4cGlyeTogdHlwZW9mIGV4cGlyeSAhPT0gJ3VuZGVmaW5lZCcgPyBIZXgudG9OdW1iZXIoZXhwaXJ5KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdHlwZToga2V5VHlwZSxcbiAgICAgICAgLi4uKGNoYWluSWQgIT09ICcweCcgPyB7IGNoYWluSWQ6IEhleC50b0JpZ0ludChjaGFpbklkKSB9IDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGV4cGlyeSAhPT0gJ3VuZGVmaW5lZCcgPyB7IGV4cGlyeTogSGV4LnRvTnVtYmVyKGV4cGlyeSkgfSA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBsaW1pdHMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBsaW1pdHM6IGxpbWl0cy5tYXAoKFt0b2tlbiwgbGltaXRdKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IEJpZ0ludChsaW1pdCksXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgfTtcbiAgICBpZiAoc2lnbmF0dXJlU2VyaWFsaXplZClcbiAgICAgICAgYXJncy5zaWduYXR1cmUgPSBTaWduYXR1cmVFbnZlbG9wZS5kZXNlcmlhbGl6ZShzaWduYXR1cmVTZXJpYWxpemVkKTtcbiAgICByZXR1cm4gZnJvbShhcmdzKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNpZ24gcGF5bG9hZCBmb3IgYW4ge0BsaW5rIG94I0tleUF1dGhvcml6YXRpb24uS2V5QXV0aG9yaXphdGlvbn0uXG4gKlxuICogVGhlIHJvb3Qga2V5IG11c3Qgc2lnbiB0aGlzIHBheWxvYWQgdG8gYXV0aG9yaXplIHRoZSBhY2Nlc3Mga2V5LiBUaGUgcmVzdWx0aW5nIHNpZ25hdHVyZVxuICogaXMgYXR0YWNoZWQgdG8gdGhlIGtleSBhdXRob3JpemF0aW9uIHZpYSB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi4oZnJvbTpmdW5jdGlvbil9IHdpdGggdGhlXG4gKiBgc2lnbmF0dXJlYCBvcHRpb24uXG4gKlxuICogW0FjY2VzcyBLZXlzIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vZG9jcy50ZW1wby54eXovcHJvdG9jb2wvdHJhbnNhY3Rpb25zL3NwZWMtdGVtcG8tdHJhbnNhY3Rpb24jYWNjZXNzLWtleXMpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzLCBTZWNwMjU2azEsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9ICcweC4uLidcbiAqIGNvbnN0IGFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkoU2VjcDI1NmsxLmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSkpXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3MsXG4gKiAgIGV4cGlyeTogMTIzNDU2Nzg5MCxcbiAqICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgIGxpbWl0czogW3tcbiAqICAgICB0b2tlbjogJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgbGltaXQ6IFZhbHVlLmZyb20oJzEwJywgNiksXG4gKiAgIH1dLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gS2V5QXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5LZXlBdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSB7XG4gICAgcmV0dXJuIGhhc2goYXV0aG9yaXphdGlvbik7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBoYXNoIGZvciBhbiB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5LZXlBdXRob3JpemF0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEtleUF1dGhvcml6YXRpb24gfSBmcm9tICdveC90ZW1wbydcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEtleUF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGV4cGlyeTogMTIzNDU2Nzg5MCxcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICBsaW1pdHM6IFt7XG4gKiAgICAgdG9rZW46ICcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICAgIGxpbWl0OiBWYWx1ZS5mcm9tKCcxMCcsIDYpXG4gKiAgIH1dLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gS2V5QXV0aG9yaXphdGlvbi5oYXNoKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNLZXlBdXRob3JpemF0aW9uLktleUF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCBbYXV0aG9yaXphdGlvblR1cGxlXSA9IHRvVHVwbGUoYXV0aG9yaXphdGlvbik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IFJscC5mcm9tSGV4KGF1dGhvcml6YXRpb25UdXBsZSk7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KHNlcmlhbGl6ZWQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5LZXlBdXRob3JpemF0aW9ufSB0byBhbiB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgS2V5QXV0aG9yaXphdGlvbiB9IGZyb20gJ294L3RlbXBvJ1xuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi50b1JwYyh7XG4gKiAgIGV4cGlyeTogMTIzNDU2Nzg5MCxcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICBsaW1pdHM6IFt7XG4gKiAgICAgdG9rZW46ICcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICAgIGxpbWl0OiBWYWx1ZS5mcm9tKCcxMCcsIDYpXG4gKiAgIH1dLFxuICogICBzaWduYXR1cmU6IHtcbiAqICAgICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAqICAgICBzaWduYXR1cmU6IHtcbiAqICAgICAgIHI6IDQ0OTQ0NjI3ODEzMDA3NzcyODk3MzkxNTMxMjMwMDgxNjk1MTAyNzAzMjg5MTIzMzMyMTg3Njk2MTE1MTgxMTA0NzM5MjM5MTk3NTE3bixcbiAqICAgICAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgICAgIHlQYXJpdHk6IDAsXG4gKiAgICAgfSxcbiAqICAgfSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEEgS2V5IEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIEtleSBBdXRob3JpemF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoYXV0aG9yaXphdGlvbikge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCA9IDBuLCBleHBpcnksIGxpbWl0cywgdHlwZSwgc2lnbmF0dXJlLCB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFpbklkOiBjaGFpbklkID09PSAwbiA/ICcweCcgOiBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgZXhwaXJ5OiB0eXBlb2YgZXhwaXJ5ID09PSAnbnVtYmVyJyA/IEhleC5mcm9tTnVtYmVyKGV4cGlyeSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGxpbWl0czogbGltaXRzPy5tYXAoKHsgdG9rZW4sIGxpbWl0IH0pID0+ICh7XG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIGxpbWl0OiBIZXguZnJvbU51bWJlcihsaW1pdCksXG4gICAgICAgIH0pKSxcbiAgICAgICAga2V5SWQ6IGFkZHJlc3MsXG4gICAgICAgIHNpZ25hdHVyZTogU2lnbmF0dXJlRW52ZWxvcGUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICAgICAga2V5VHlwZTogdHlwZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5LZXlBdXRob3JpemF0aW9ufSB0byBhbiB7QGxpbmsgb3gjS2V5QXV0aG9yaXphdGlvbi5UdXBsZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBLZXlBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gvdGVtcG8nXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBLZXlBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBleHBpcnk6IDEyMzQ1Njc4OTAsXG4gKiAgIGFkZHJlc3M6ICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAqICAgbGltaXRzOiBbe1xuICogICAgIHRva2VuOiAnMHgyMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyxcbiAqICAgICBsaW1pdDogVmFsdWUuZnJvbSgnMTAnLCA2KVxuICogICB9XSxcbiAqIH0pXG4gKlxuICogY29uc3QgdHVwbGUgPSBLZXlBdXRob3JpemF0aW9uLnRvVHVwbGUoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICAnMHgxNzQ4NzZlODAwJyxcbiAqIC8vIEBsb2c6ICAgW1snMHgyMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgJzB4ZjQyNDAnXV0sXG4gKiAvLyBAbG9nOiAgICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogLy8gQGxvZzogICAnc2VjcDI1NmsxJyxcbiAqIC8vIEBsb2c6IF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNLZXlBdXRob3JpemF0aW9uLktleUF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgQSBUZW1wbyBLZXkgQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGUoYXV0aG9yaXphdGlvbikge1xuICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCA9IDBuLCBleHBpcnksIGxpbWl0cyB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhdXRob3JpemF0aW9uLnNpZ25hdHVyZVxuICAgICAgICA/IFNpZ25hdHVyZUVudmVsb3BlLnNlcmlhbGl6ZShhdXRob3JpemF0aW9uLnNpZ25hdHVyZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgdHlwZSA9ICgoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoYXV0aG9yaXphdGlvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzZWNwMjU2azEnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnMHgnO1xuICAgICAgICAgICAgY2FzZSAncDI1Nic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICcweDAxJztcbiAgICAgICAgICAgIGNhc2UgJ3dlYkF1dGhuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJzB4MDInO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQga2V5IHR5cGU6ICR7YXV0aG9yaXphdGlvbi50eXBlfWApO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICBjb25zdCBhdXRob3JpemF0aW9uVHVwbGUgPSBbXG4gICAgICAgIGNoYWluSWQgPT09IDBuID8gJzB4JyA6IEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICB0eXBlLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICB0eXBlb2YgZXhwaXJ5ID09PSAnbnVtYmVyJyA/IEhleC5mcm9tTnVtYmVyKGV4cGlyeSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGxpbWl0cz8ubWFwKChsaW1pdCkgPT4gW2xpbWl0LnRva2VuLCBIZXguZnJvbU51bWJlcihsaW1pdC5saW1pdCldKSA/P1xuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIHJldHVybiBbYXV0aG9yaXphdGlvblR1cGxlLCAuLi4oc2lnbmF0dXJlID8gW3NpZ25hdHVyZV0gOiBbXSldO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5QXV0aG9yaXphdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/KeyAuthorization.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js":
/*!*********************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/SignatureEnvelope.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoercionError: () => (/* binding */ CoercionError),\n/* harmony export */   InvalidSerializedError: () => (/* binding */ InvalidSerializedError),\n/* harmony export */   MissingPropertiesError: () => (/* binding */ MissingPropertiesError),\n/* harmony export */   VerificationError: () => (/* binding */ VerificationError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   getType: () => (/* binding */ getType),\n/* harmony export */   magicBytes: () => (/* binding */ magicBytes),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   types: () => (/* binding */ types),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _core_Address_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Json_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _core_P256_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/P256.js */ \"(ssr)/./node_modules/ox/_esm/core/P256.js\");\n/* harmony import */ var _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Secp256k1.js */ \"(ssr)/./node_modules/ox/_esm/core/Secp256k1.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _core_WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/WebAuthnP256.js */ \"(ssr)/./node_modules/ox/_esm/core/WebAuthnP256.js\");\n\n\n\n\n\n\n\n\n/** Signature type identifiers for encoding/decoding */\nconst serializedP256Type = '0x01';\nconst serializedWebAuthnType = '0x02';\nconst serializedKeychainType = '0x03';\n/** Serialized magic identifier for Tempo signature envelopes. */\nconst magicBytes = '0x7777777777777777777777777777777777777777777777777777777777777777'; // 32 \"T\"s\n/** List of supported signature types. */\nconst types = ['secp256k1', 'p256', 'webAuthn'];\n/**\n * Asserts that a {@link ox#SignatureEnvelope.SignatureEnvelope} is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * SignatureEnvelope.assert({\n *   type: 'secp256k1',\n *   signature: {\n *     r: 0n,\n *     s: 0n,\n *     yParity: 0,\n *   },\n * })\n * ```\n *\n * @param envelope - The signature envelope to assert.\n * @throws `CoercionError` if the envelope type cannot be determined.\n */\nfunction assert(envelope) {\n    const type = getType(envelope);\n    if (type === 'secp256k1') {\n        const secp256k1 = envelope;\n        _core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.assert(secp256k1.signature);\n        return;\n    }\n    if (type === 'p256') {\n        const p256 = envelope;\n        const missing = [];\n        if (typeof p256.signature?.r !== 'bigint')\n            missing.push('signature.r');\n        if (typeof p256.signature?.s !== 'bigint')\n            missing.push('signature.s');\n        if (typeof p256.prehash !== 'boolean')\n            missing.push('prehash');\n        if (!p256.publicKey)\n            missing.push('publicKey');\n        else {\n            if (typeof p256.publicKey.x !== 'bigint')\n                missing.push('publicKey.x');\n            if (typeof p256.publicKey.y !== 'bigint')\n                missing.push('publicKey.y');\n        }\n        if (missing.length > 0)\n            throw new MissingPropertiesError({ envelope, missing, type: 'p256' });\n        return;\n    }\n    if (type === 'webAuthn') {\n        const webauthn = envelope;\n        const missing = [];\n        if (typeof webauthn.signature?.r !== 'bigint')\n            missing.push('signature.r');\n        if (typeof webauthn.signature?.s !== 'bigint')\n            missing.push('signature.s');\n        if (!webauthn.metadata)\n            missing.push('metadata');\n        else {\n            if (!webauthn.metadata.authenticatorData)\n                missing.push('metadata.authenticatorData');\n            if (!webauthn.metadata.clientDataJSON)\n                missing.push('metadata.clientDataJSON');\n        }\n        if (!webauthn.publicKey)\n            missing.push('publicKey');\n        else {\n            if (typeof webauthn.publicKey.x !== 'bigint')\n                missing.push('publicKey.x');\n            if (typeof webauthn.publicKey.y !== 'bigint')\n                missing.push('publicKey.y');\n        }\n        if (missing.length > 0)\n            throw new MissingPropertiesError({ envelope, missing, type: 'webAuthn' });\n        return;\n    }\n    if (type === 'keychain') {\n        const keychain = envelope;\n        assert(keychain.inner);\n        return;\n    }\n}\n/**\n * Deserializes a hex-encoded signature envelope into a typed signature object.\n *\n * Wire format detection:\n * - 65 bytes (no prefix): secp256k1 signature\n * - Type `0x01` + 129 bytes: P256 signature (r, s, pubKeyX, pubKeyY, prehash)\n * - Type `0x02` + variable: WebAuthn signature (webauthnData, r, s, pubKeyX, pubKeyY)\n * - Type `0x03` + 20 bytes + inner: Keychain signature (userAddress + inner signature)\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const envelope = SignatureEnvelope.deserialize('0x...')\n * ```\n *\n * @param serialized - The hex-encoded signature envelope to deserialize.\n * @returns The deserialized signature envelope.\n * @throws `CoercionError` if the serialized value cannot be coerced to a valid signature envelope.\n */\nfunction deserialize(value) {\n    const serialized = value.endsWith(magicBytes.slice(2))\n        ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(value, 0, -_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(magicBytes))\n        : value;\n    const size = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(serialized);\n    // Backward compatibility: 65 bytes means secp256k1 without type identifier\n    if (size === 65) {\n        const signature = _core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(serialized);\n        _core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.assert(signature);\n        return { signature, type: 'secp256k1' };\n    }\n    // For all other lengths, first byte is the type identifier\n    const typeId = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(serialized, 0, 1);\n    const data = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(serialized, 1);\n    const dataSize = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(data);\n    if (typeId === serializedP256Type) {\n        // P256: 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY) + 1 (prehash) = 129 bytes\n        if (dataSize !== 129)\n            throw new InvalidSerializedError({\n                reason: `Invalid P256 signature envelope size: expected 129 bytes, got ${dataSize} bytes`,\n                serialized,\n            });\n        return {\n            publicKey: {\n                prefix: 4,\n                x: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 64, 96)),\n                y: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 96, 128)),\n            },\n            prehash: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 128, 129)) !== 0,\n            signature: {\n                r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 0, 32)),\n                s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 32, 64)),\n            },\n            type: 'p256',\n        };\n    }\n    if (typeId === serializedWebAuthnType) {\n        // WebAuthn: variable (webauthnData) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY)\n        // Minimum: 128 bytes (at least some authenticator data + signature components)\n        if (dataSize < 128)\n            throw new InvalidSerializedError({\n                reason: `Invalid WebAuthn signature envelope size: expected at least 128 bytes, got ${dataSize} bytes`,\n                serialized,\n            });\n        const webauthnDataSize = dataSize - 128;\n        const webauthnData = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 0, webauthnDataSize);\n        // Parse webauthnData into authenticatorData and clientDataJSON\n        // According to the Rust code, it's authenticatorData || clientDataJSON\n        // We need to find the split point (minimum authenticatorData is 37 bytes)\n        let authenticatorData;\n        let clientDataJSON;\n        // Try to find the JSON start (clientDataJSON should start with '{')\n        for (let split = 37; split < webauthnDataSize; split++) {\n            const potentialJson = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toString(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(webauthnData, split));\n            if (potentialJson.startsWith('{') && potentialJson.endsWith('}')) {\n                try {\n                    JSON.parse(potentialJson);\n                    authenticatorData = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(webauthnData, 0, split);\n                    clientDataJSON = potentialJson;\n                    break;\n                }\n                catch { }\n            }\n        }\n        if (!authenticatorData || !clientDataJSON)\n            throw new InvalidSerializedError({\n                reason: 'Unable to parse WebAuthn metadata: could not extract valid authenticatorData and clientDataJSON',\n                serialized,\n            });\n        return {\n            publicKey: {\n                prefix: 4,\n                x: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, webauthnDataSize + 64, webauthnDataSize + 96)),\n                y: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, webauthnDataSize + 96, webauthnDataSize + 128)),\n            },\n            metadata: {\n                authenticatorData,\n                clientDataJSON,\n            },\n            signature: {\n                r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, webauthnDataSize, webauthnDataSize + 32)),\n                s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, webauthnDataSize + 32, webauthnDataSize + 64)),\n            },\n            type: 'webAuthn',\n        };\n    }\n    if (typeId === serializedKeychainType) {\n        const userAddress = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 0, 20);\n        const inner = deserialize(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(data, 20));\n        return {\n            userAddress,\n            inner,\n            type: 'keychain',\n        };\n    }\n    throw new InvalidSerializedError({\n        reason: `Unknown signature type identifier: ${typeId}. Expected ${serializedP256Type} (P256) or ${serializedWebAuthnType} (WebAuthn)`,\n        serialized,\n    });\n}\n/**\n * Coerces a value to a signature envelope.\n *\n * Accepts either a serialized hex string or an existing signature envelope object.\n * Use this to wrap raw signatures from {@link ox#Secp256k1.(sign:function)}, {@link ox#P256.(sign:function)},\n * {@link ox#WebCryptoP256.(sign:function)}, or {@link ox#WebAuthnP256.(sign:function)} into the envelope format\n * required by Tempo transactions.\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ### Secp256k1\n *\n * Standard Ethereum ECDSA signature using the secp256k1 curve.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from(signature)\n * ```\n *\n * @example\n * ### P256\n *\n * ECDSA signature using the P-256 (secp256r1) curve. Requires embedding the\n * public key.\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n * })\n * ```\n *\n * @example\n * ### P256 (WebCrypto)\n *\n * When using WebCrypto keys, `prehash` must be `true` since WebCrypto always\n * SHA256 hashes the digest before signing.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebCryptoP256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey,\n *   prehash: true,\n * })\n * ```\n *\n * @example\n * ### WebAuthn\n *\n * Passkey-based signature using WebAuthn. Includes authenticator metadata\n * (authenticatorData and clientDataJSON) along with the P-256 signature and\n * public key.\n *\n * ```ts twoslash\n * // @noErrors\n * import { WebAuthnP256 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: '0xdeadbeef',\n *   credentialId: credential.id,\n * })\n *\n * const envelope = SignatureEnvelope.from({\n *   signature,\n *   publicKey: credential.publicKey,\n *   metadata,\n * })\n * ```\n *\n * @example\n * ### Keychain\n *\n * Wraps another signature type with a user address, used for delegated signing\n * via access keys on behalf of a root account.\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const envelope = SignatureEnvelope.from({\n *   userAddress: '0x1234567890123456789012345678901234567890',\n *   inner: SignatureEnvelope.from(signature),\n * })\n * ```\n *\n * @param value - The value to coerce (either a hex string or signature envelope).\n * @returns The signature envelope.\n */\nfunction from(value) {\n    if (typeof value === 'string')\n        return deserialize(value);\n    if (typeof value === 'object' &&\n        value !== null &&\n        'r' in value &&\n        's' in value &&\n        'yParity' in value)\n        return { signature: value, type: 'secp256k1' };\n    const type = getType(value);\n    return {\n        ...value,\n        ...(type === 'p256' ? { prehash: value.prehash } : {}),\n        type,\n    };\n}\n/**\n * Converts an RPC-formatted signature envelope to a typed signature envelope.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const envelope = SignatureEnvelope.fromRpc({\n *   r: '0x0',\n *   s: '0x0',\n *   yParity: '0x0',\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The RPC signature envelope to convert.\n * @returns The signature envelope with bigint values.\n */\nfunction fromRpc(envelope) {\n    if (envelope.type === 'secp256k1')\n        return {\n            signature: _core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc(envelope),\n            type: 'secp256k1',\n        };\n    if (envelope.type === 'p256') {\n        return {\n            prehash: envelope.prehash,\n            publicKey: {\n                prefix: 4,\n                x: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.pubKeyX),\n                y: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.pubKeyY),\n            },\n            signature: {\n                r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.r),\n                s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.s),\n            },\n            type: 'p256',\n        };\n    }\n    if (envelope.type === 'webAuthn') {\n        const webauthnData = envelope.webauthnData;\n        const webauthnDataSize = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(webauthnData);\n        // Parse webauthnData into authenticatorData and clientDataJSON\n        let authenticatorData;\n        let clientDataJSON;\n        // Try to find the JSON start (clientDataJSON should start with '{')\n        for (let split = 37; split < webauthnDataSize; split++) {\n            const potentialJson = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toString(_core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(webauthnData, split));\n            if (potentialJson.startsWith('{') && potentialJson.endsWith('}')) {\n                try {\n                    JSON.parse(potentialJson);\n                    authenticatorData = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(webauthnData, 0, split);\n                    clientDataJSON = potentialJson;\n                    break;\n                }\n                catch { }\n            }\n        }\n        if (!authenticatorData || !clientDataJSON)\n            throw new InvalidSerializedError({\n                reason: 'Unable to parse WebAuthn metadata: could not extract valid authenticatorData and clientDataJSON',\n                serialized: webauthnData,\n            });\n        return {\n            metadata: {\n                authenticatorData,\n                clientDataJSON,\n            },\n            publicKey: {\n                prefix: 4,\n                x: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.pubKeyX),\n                y: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.pubKeyY),\n            },\n            signature: {\n                r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.r),\n                s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(envelope.s),\n            },\n            type: 'webAuthn',\n        };\n    }\n    if (envelope.type === 'keychain' ||\n        ('userAddress' in envelope && 'signature' in envelope))\n        return {\n            type: 'keychain',\n            userAddress: envelope.userAddress,\n            inner: fromRpc(envelope.signature),\n        };\n    throw new CoercionError({ envelope });\n}\n/**\n * Determines the signature type of an envelope.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const type = SignatureEnvelope.getType({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n * })\n * // @log: 'secp256k1'\n * ```\n *\n * @param envelope - The signature envelope to inspect.\n * @returns The signature type ('secp256k1', 'p256', or 'webAuthn').\n * @throws `CoercionError` if the envelope type cannot be determined.\n */\nfunction getType(envelope) {\n    if (typeof envelope !== 'object' || envelope === null)\n        throw new CoercionError({ envelope });\n    if ('type' in envelope && envelope.type)\n        return envelope.type;\n    // Detect secp256k1 signature (backwards compatibility: also support flat structure)\n    if ('signature' in envelope &&\n        !('publicKey' in envelope) &&\n        typeof envelope.signature === 'object' &&\n        envelope.signature !== null &&\n        'r' in envelope.signature &&\n        's' in envelope.signature &&\n        'yParity' in envelope.signature)\n        return 'secp256k1';\n    // Detect secp256k1 signature (flat structure)\n    if ('r' in envelope && 's' in envelope && 'yParity' in envelope)\n        return 'secp256k1';\n    // Detect P256 signature\n    if ('signature' in envelope &&\n        'prehash' in envelope &&\n        'publicKey' in envelope &&\n        typeof envelope.prehash === 'boolean')\n        return 'p256';\n    // Detect WebAuthn signature\n    if ('signature' in envelope &&\n        'metadata' in envelope &&\n        'publicKey' in envelope)\n        return 'webAuthn';\n    // Detect Keychain signature\n    if ('userAddress' in envelope && 'inner' in envelope)\n        return 'keychain';\n    throw new CoercionError({\n        envelope,\n    });\n}\n/**\n * Serializes a signature envelope to a hex-encoded string.\n *\n * Wire format:\n * - secp256k1: 65 bytes (no type prefix, for backward compatibility)\n * - P256: `0x01` + r (32) + s (32) + pubKeyX (32) + pubKeyY (32) + prehash (1) = 130 bytes\n * - WebAuthn: `0x02` + webauthnData (variable) + r (32) + s (32) + pubKeyX (32) + pubKeyY (32)\n * - Keychain: `0x03` + userAddress (20) + inner signature (recursive)\n *\n * [Signature Types](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types)\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const serialized = SignatureEnvelope.serialize({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The signature envelope to serialize.\n * @returns The hex-encoded serialized signature.\n * @throws `CoercionError` if the envelope cannot be serialized.\n */\nfunction serialize(envelope, options = {}) {\n    const type = getType(envelope);\n    // Backward compatibility: no type identifier for secp256k1\n    if (type === 'secp256k1') {\n        const secp256k1 = envelope;\n        return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.toHex(secp256k1.signature), options.magic ? magicBytes : '0x');\n    }\n    if (type === 'p256') {\n        const p256 = envelope;\n        // Format: 1 byte (type) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY) + 1 (prehash)\n        return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(serializedP256Type, _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.signature.r, { size: 32 }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.signature.s, { size: 32 }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.publicKey.x, { size: 32 }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.publicKey.y, { size: 32 }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.prehash ? 1 : 0, { size: 1 }), options.magic ? magicBytes : '0x');\n    }\n    if (type === 'webAuthn') {\n        const webauthn = envelope;\n        // Format: 1 byte (type) + variable (authenticatorData || clientDataJSON) + 32 (r) + 32 (s) + 32 (pubKeyX) + 32 (pubKeyY)\n        const webauthnData = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(webauthn.metadata.authenticatorData, _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(webauthn.metadata.clientDataJSON));\n        return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(serializedWebAuthnType, webauthnData, _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.signature.r, { size: 32 }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.signature.s, { size: 32 }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.publicKey.x, { size: 32 }), _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.publicKey.y, { size: 32 }), options.magic ? magicBytes : '0x');\n    }\n    if (type === 'keychain') {\n        const keychain = envelope;\n        return _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(serializedKeychainType, keychain.userAddress, serialize(keychain.inner), options.magic ? magicBytes : '0x');\n    }\n    throw new CoercionError({ envelope });\n}\n/**\n * Converts a signature envelope to RPC format.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const rpc = SignatureEnvelope.toRpc({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * ```\n *\n * @param envelope - The signature envelope to convert.\n * @returns The RPC signature envelope with hex values.\n */\nfunction toRpc(envelope) {\n    const type = getType(envelope);\n    if (type === 'secp256k1') {\n        const secp256k1 = envelope;\n        return {\n            ..._core_Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(secp256k1.signature),\n            type: 'secp256k1',\n        };\n    }\n    if (type === 'p256') {\n        const p256 = envelope;\n        return {\n            prehash: p256.prehash,\n            pubKeyX: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.publicKey.x, { size: 32 }),\n            pubKeyY: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.publicKey.y, { size: 32 }),\n            r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.signature.r, { size: 32 }),\n            s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(p256.signature.s, { size: 32 }),\n            type: 'p256',\n        };\n    }\n    if (type === 'webAuthn') {\n        const webauthn = envelope;\n        const webauthnData = _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(webauthn.metadata.authenticatorData, _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(webauthn.metadata.clientDataJSON));\n        return {\n            pubKeyX: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.publicKey.x, { size: 32 }),\n            pubKeyY: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.publicKey.y, { size: 32 }),\n            r: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.signature.r, { size: 32 }),\n            s: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(webauthn.signature.s, { size: 32 }),\n            type: 'webAuthn',\n            webauthnData,\n        };\n    }\n    if (type === 'keychain') {\n        const keychain = envelope;\n        return {\n            type: 'keychain',\n            userAddress: keychain.userAddress,\n            signature: toRpc(keychain.inner),\n        };\n    }\n    throw new CoercionError({ envelope });\n}\n/**\n * Validates a signature envelope. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n *\n * const valid = SignatureEnvelope.validate({\n *   signature: { r: 0n, s: 0n, yParity: 0 },\n *   type: 'secp256k1',\n * })\n * // @log: true\n * ```\n *\n * @param envelope - The signature envelope to validate.\n * @returns `true` if valid, `false` otherwise.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Verifies a signature envelope against a digest/payload.\n *\n * Supports `secp256k1`, `p256`, and `webAuthn` signature types.\n *\n * :::warning\n * `keychain` signatures are not supported and will throw an error.\n * :::\n *\n * @example\n * ### Secp256k1\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const payload = '0xdeadbeef'\n *\n * const signature = Secp256k1.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from(signature)\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### P256\n *\n * For P256 signatures, the `address` or `publicKey` must match the embedded\n * public key in the signature envelope.\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const payload = '0xdeadbeef'\n *\n * const signature = P256.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from({ prehash: false, publicKey, signature })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### WebCryptoP256\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const payload = '0xdeadbeef'\n *\n * const signature = await WebCryptoP256.sign({ payload, privateKey })\n * const envelope = SignatureEnvelope.from({ prehash: true, publicKey, signature })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey,\n * })\n * // @log: true\n * ```\n *\n * @example\n * ### WebAuthnP256\n *\n * ```ts twoslash\n * import { SignatureEnvelope } from 'ox/tempo'\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' })\n * const payload = '0xdeadbeef'\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   challenge: payload,\n *   credentialId: credential.id,\n * })\n * const envelope = SignatureEnvelope.from({\n *   metadata,\n *   signature,\n *   publicKey: credential.publicKey,\n * })\n *\n * const valid = SignatureEnvelope.verify(envelope, {\n *   payload,\n *   publicKey: credential.publicKey,\n * })\n * // @log: true\n * ```\n *\n * @param parameters - Verification parameters.\n * @returns `true` if the signature is valid, `false` otherwise.\n */\nfunction verify(signature, parameters) {\n    const { payload } = parameters;\n    const address = (() => {\n        if (parameters.address)\n            return parameters.address;\n        if (parameters.publicKey)\n            return _core_Address_js__WEBPACK_IMPORTED_MODULE_2__.fromPublicKey(parameters.publicKey);\n        return undefined;\n    })();\n    if (!address)\n        return false;\n    const envelope = from(signature);\n    if (envelope.type === 'secp256k1') {\n        if (!address)\n            return false;\n        return _core_Secp256k1_js__WEBPACK_IMPORTED_MODULE_3__.verify({\n            address,\n            payload,\n            signature: envelope.signature,\n        });\n    }\n    if (envelope.type === 'p256') {\n        const envelopeAddress = _core_Address_js__WEBPACK_IMPORTED_MODULE_2__.fromPublicKey(envelope.publicKey);\n        if (!_core_Address_js__WEBPACK_IMPORTED_MODULE_2__.isEqual(envelopeAddress, address))\n            return false;\n        return _core_P256_js__WEBPACK_IMPORTED_MODULE_4__.verify({\n            hash: envelope.prehash,\n            publicKey: envelope.publicKey,\n            payload,\n            signature: envelope.signature,\n        });\n    }\n    if (envelope.type === 'webAuthn') {\n        const envelopeAddress = _core_Address_js__WEBPACK_IMPORTED_MODULE_2__.fromPublicKey(envelope.publicKey);\n        if (!_core_Address_js__WEBPACK_IMPORTED_MODULE_2__.isEqual(envelopeAddress, address))\n            return false;\n        return _core_WebAuthnP256_js__WEBPACK_IMPORTED_MODULE_5__.verify({\n            challenge: _core_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(payload),\n            metadata: envelope.metadata,\n            publicKey: envelope.publicKey,\n            signature: envelope.signature,\n        });\n    }\n    throw new VerificationError(`Unable to verify signature envelope of type \"${envelope.type}\".`);\n}\n/**\n * Error thrown when a signature envelope cannot be coerced to a valid type.\n */\nclass CoercionError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ envelope }) {\n        super(`Unable to coerce value (\\`${_core_Json_js__WEBPACK_IMPORTED_MODULE_7__.stringify(envelope)}\\`) to a valid signature envelope.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureEnvelope.CoercionError'\n        });\n    }\n}\n/**\n * Error thrown when a signature envelope is missing required properties.\n */\nclass MissingPropertiesError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ envelope, missing, type, }) {\n        super(`Signature envelope of type \"${type}\" is missing required properties: ${missing.map((m) => `\\`${m}\\``).join(', ')}.\\n\\nProvided: ${_core_Json_js__WEBPACK_IMPORTED_MODULE_7__.stringify(envelope)}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureEnvelope.MissingPropertiesError'\n        });\n    }\n}\n/**\n * Error thrown when a serialized signature envelope cannot be deserialized.\n */\nclass InvalidSerializedError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor({ reason, serialized, }) {\n        super(`Unable to deserialize signature envelope: ${reason}`, {\n            metaMessages: [`Serialized: ${serialized}`],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureEnvelope.InvalidSerializedError'\n        });\n    }\n}\n/**\n * Error thrown when a signature envelope fails to verify.\n */\nclass VerificationError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_6__.BaseError {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'SignatureEnvelope.VerificationError'\n        });\n    }\n}\n//# sourceMappingURL=SignatureEnvelope.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9TaWduYXR1cmVFbnZlbG9wZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNGO0FBQ047QUFDRTtBQUNHO0FBQ1U7QUFDSDtBQUNTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5RkFBeUY7QUFDaEc7QUFDTztBQUNQO0FBQ0EsbUJBQW1CLDhDQUE4QztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQ0FBaUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxQ0FBcUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxVQUFVLCtDQUFTLFlBQVksOENBQVE7QUFDdkM7QUFDQSxpQkFBaUIsOENBQVE7QUFDekI7QUFDQTtBQUNBLDBCQUEwQix1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QXFCO0FBQ3JELGFBQWEscURBQWU7QUFDNUI7QUFDQSxlQUFlLHlEQUFzQjtBQUNyQyx1QkFBdUIsOENBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0ZBQWdGLGNBQWM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsc0RBQWdCO0FBQ25ELGtCQUFrQixVQUFVO0FBQzVCLDJDQUEyQyxvREFBYyxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQyxzREFBZ0I7QUFDNUQsa0JBQWtCLDBCQUEwQjtBQUM1Qyw2Q0FBNkMsS0FBSyxvQ0FBb0Msd0JBQXdCLEVBQUUsZ0JBQWdCLGlCQUFpQixvREFBYyxXQUFXO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQyxzREFBZ0I7QUFDNUQsa0JBQWtCLHFCQUFxQjtBQUN2QywyREFBMkQsT0FBTztBQUNsRSwwQ0FBMEMsV0FBVztBQUNyRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLHNEQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL3RlbXBvL1NpZ25hdHVyZUVudmVsb3BlLmpzP2I3OTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuLi9jb3JlL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4uL2NvcmUvRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9jb3JlL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4uL2NvcmUvSnNvbi5qcyc7XG5pbXBvcnQgKiBhcyBveF9QMjU2IGZyb20gJy4uL2NvcmUvUDI1Ni5qcyc7XG5pbXBvcnQgKiBhcyBveF9TZWNwMjU2azEgZnJvbSAnLi4vY29yZS9TZWNwMjU2azEuanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlIGZyb20gJy4uL2NvcmUvU2lnbmF0dXJlLmpzJztcbmltcG9ydCAqIGFzIG94X1dlYkF1dGhuUDI1NiBmcm9tICcuLi9jb3JlL1dlYkF1dGhuUDI1Ni5qcyc7XG4vKiogU2lnbmF0dXJlIHR5cGUgaWRlbnRpZmllcnMgZm9yIGVuY29kaW5nL2RlY29kaW5nICovXG5jb25zdCBzZXJpYWxpemVkUDI1NlR5cGUgPSAnMHgwMSc7XG5jb25zdCBzZXJpYWxpemVkV2ViQXV0aG5UeXBlID0gJzB4MDInO1xuY29uc3Qgc2VyaWFsaXplZEtleWNoYWluVHlwZSA9ICcweDAzJztcbi8qKiBTZXJpYWxpemVkIG1hZ2ljIGlkZW50aWZpZXIgZm9yIFRlbXBvIHNpZ25hdHVyZSBlbnZlbG9wZXMuICovXG5leHBvcnQgY29uc3QgbWFnaWNCeXRlcyA9ICcweDc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3NzcnOyAvLyAzMiBcIlRcInNcbi8qKiBMaXN0IG9mIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXMuICovXG5leHBvcnQgY29uc3QgdHlwZXMgPSBbJ3NlY3AyNTZrMScsICdwMjU2JywgJ3dlYkF1dGhuJ107XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIHtAbGluayBveCNTaWduYXR1cmVFbnZlbG9wZS5TaWduYXR1cmVFbnZlbG9wZX0gaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIFNpZ25hdHVyZUVudmVsb3BlLmFzc2VydCh7XG4gKiAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICBzaWduYXR1cmU6IHtcbiAqICAgICByOiAwbixcbiAqICAgICBzOiAwbixcbiAqICAgICB5UGFyaXR5OiAwLFxuICogICB9LFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBzaWduYXR1cmUgZW52ZWxvcGUgdG8gYXNzZXJ0LlxuICogQHRocm93cyBgQ29lcmNpb25FcnJvcmAgaWYgdGhlIGVudmVsb3BlIHR5cGUgY2Fubm90IGJlIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZW52ZWxvcGUpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZShlbnZlbG9wZSk7XG4gICAgaWYgKHR5cGUgPT09ICdzZWNwMjU2azEnKSB7XG4gICAgICAgIGNvbnN0IHNlY3AyNTZrMSA9IGVudmVsb3BlO1xuICAgICAgICBTaWduYXR1cmUuYXNzZXJ0KHNlY3AyNTZrMS5zaWduYXR1cmUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAncDI1NicpIHtcbiAgICAgICAgY29uc3QgcDI1NiA9IGVudmVsb3BlO1xuICAgICAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgcDI1Ni5zaWduYXR1cmU/LnIgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdzaWduYXR1cmUucicpO1xuICAgICAgICBpZiAodHlwZW9mIHAyNTYuc2lnbmF0dXJlPy5zICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaCgnc2lnbmF0dXJlLnMnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwMjU2LnByZWhhc2ggIT09ICdib29sZWFuJylcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaCgncHJlaGFzaCcpO1xuICAgICAgICBpZiAoIXAyNTYucHVibGljS2V5KVxuICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdwdWJsaWNLZXknKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAyNTYucHVibGljS2V5LnggIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCgncHVibGljS2V5LngnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcDI1Ni5wdWJsaWNLZXkueSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdwdWJsaWNLZXkueScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IGVudmVsb3BlLCBtaXNzaW5nLCB0eXBlOiAncDI1NicgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICd3ZWJBdXRobicpIHtcbiAgICAgICAgY29uc3Qgd2ViYXV0aG4gPSBlbnZlbG9wZTtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIHdlYmF1dGhuLnNpZ25hdHVyZT8uciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goJ3NpZ25hdHVyZS5yJyk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2ViYXV0aG4uc2lnbmF0dXJlPy5zICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaCgnc2lnbmF0dXJlLnMnKTtcbiAgICAgICAgaWYgKCF3ZWJhdXRobi5tZXRhZGF0YSlcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaCgnbWV0YWRhdGEnKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXdlYmF1dGhuLm1ldGFkYXRhLmF1dGhlbnRpY2F0b3JEYXRhKVxuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCgnbWV0YWRhdGEuYXV0aGVudGljYXRvckRhdGEnKTtcbiAgICAgICAgICAgIGlmICghd2ViYXV0aG4ubWV0YWRhdGEuY2xpZW50RGF0YUpTT04pXG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdtZXRhZGF0YS5jbGllbnREYXRhSlNPTicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2ViYXV0aG4ucHVibGljS2V5KVxuICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdwdWJsaWNLZXknKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdlYmF1dGhuLnB1YmxpY0tleS54ICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goJ3B1YmxpY0tleS54Jyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdlYmF1dGhuLnB1YmxpY0tleS55ICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goJ3B1YmxpY0tleS55Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgZW52ZWxvcGUsIG1pc3NpbmcsIHR5cGU6ICd3ZWJBdXRobicgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdrZXljaGFpbicpIHtcbiAgICAgICAgY29uc3Qga2V5Y2hhaW4gPSBlbnZlbG9wZTtcbiAgICAgICAgYXNzZXJ0KGtleWNoYWluLmlubmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEgaGV4LWVuY29kZWQgc2lnbmF0dXJlIGVudmVsb3BlIGludG8gYSB0eXBlZCBzaWduYXR1cmUgb2JqZWN0LlxuICpcbiAqIFdpcmUgZm9ybWF0IGRldGVjdGlvbjpcbiAqIC0gNjUgYnl0ZXMgKG5vIHByZWZpeCk6IHNlY3AyNTZrMSBzaWduYXR1cmVcbiAqIC0gVHlwZSBgMHgwMWAgKyAxMjkgYnl0ZXM6IFAyNTYgc2lnbmF0dXJlIChyLCBzLCBwdWJLZXlYLCBwdWJLZXlZLCBwcmVoYXNoKVxuICogLSBUeXBlIGAweDAyYCArIHZhcmlhYmxlOiBXZWJBdXRobiBzaWduYXR1cmUgKHdlYmF1dGhuRGF0YSwgciwgcywgcHViS2V5WCwgcHViS2V5WSlcbiAqIC0gVHlwZSBgMHgwM2AgKyAyMCBieXRlcyArIGlubmVyOiBLZXljaGFpbiBzaWduYXR1cmUgKHVzZXJBZGRyZXNzICsgaW5uZXIgc2lnbmF0dXJlKVxuICpcbiAqIFtTaWduYXR1cmUgVHlwZXNdKGh0dHBzOi8vZG9jcy50ZW1wby54eXovcHJvdG9jb2wvdHJhbnNhY3Rpb25zL3NwZWMtdGVtcG8tdHJhbnNhY3Rpb24jc2lnbmF0dXJlLXR5cGVzKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmRlc2VyaWFsaXplKCcweC4uLicpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBoZXgtZW5jb2RlZCBzaWduYXR1cmUgZW52ZWxvcGUgdG8gZGVzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgZGVzZXJpYWxpemVkIHNpZ25hdHVyZSBlbnZlbG9wZS5cbiAqIEB0aHJvd3MgYENvZXJjaW9uRXJyb3JgIGlmIHRoZSBzZXJpYWxpemVkIHZhbHVlIGNhbm5vdCBiZSBjb2VyY2VkIHRvIGEgdmFsaWQgc2lnbmF0dXJlIGVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUodmFsdWUpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gdmFsdWUuZW5kc1dpdGgobWFnaWNCeXRlcy5zbGljZSgyKSlcbiAgICAgICAgPyBIZXguc2xpY2UodmFsdWUsIDAsIC1IZXguc2l6ZShtYWdpY0J5dGVzKSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICBjb25zdCBzaXplID0gSGV4LnNpemUoc2VyaWFsaXplZCk7XG4gICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogNjUgYnl0ZXMgbWVhbnMgc2VjcDI1NmsxIHdpdGhvdXQgdHlwZSBpZGVudGlmaWVyXG4gICAgaWYgKHNpemUgPT09IDY1KSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tSGV4KHNlcmlhbGl6ZWQpO1xuICAgICAgICBTaWduYXR1cmUuYXNzZXJ0KHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiB7IHNpZ25hdHVyZSwgdHlwZTogJ3NlY3AyNTZrMScgfTtcbiAgICB9XG4gICAgLy8gRm9yIGFsbCBvdGhlciBsZW5ndGhzLCBmaXJzdCBieXRlIGlzIHRoZSB0eXBlIGlkZW50aWZpZXJcbiAgICBjb25zdCB0eXBlSWQgPSBIZXguc2xpY2Uoc2VyaWFsaXplZCwgMCwgMSk7XG4gICAgY29uc3QgZGF0YSA9IEhleC5zbGljZShzZXJpYWxpemVkLCAxKTtcbiAgICBjb25zdCBkYXRhU2l6ZSA9IEhleC5zaXplKGRhdGEpO1xuICAgIGlmICh0eXBlSWQgPT09IHNlcmlhbGl6ZWRQMjU2VHlwZSkge1xuICAgICAgICAvLyBQMjU2OiAzMiAocikgKyAzMiAocykgKyAzMiAocHViS2V5WCkgKyAzMiAocHViS2V5WSkgKyAxIChwcmVoYXNoKSA9IDEyOSBieXRlc1xuICAgICAgICBpZiAoZGF0YVNpemUgIT09IDEyOSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXplZEVycm9yKHtcbiAgICAgICAgICAgICAgICByZWFzb246IGBJbnZhbGlkIFAyNTYgc2lnbmF0dXJlIGVudmVsb3BlIHNpemU6IGV4cGVjdGVkIDEyOSBieXRlcywgZ290ICR7ZGF0YVNpemV9IGJ5dGVzYCxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwdWJsaWNLZXk6IHtcbiAgICAgICAgICAgICAgICBwcmVmaXg6IDQsXG4gICAgICAgICAgICAgICAgeDogSGV4LnRvQmlnSW50KEhleC5zbGljZShkYXRhLCA2NCwgOTYpKSxcbiAgICAgICAgICAgICAgICB5OiBIZXgudG9CaWdJbnQoSGV4LnNsaWNlKGRhdGEsIDk2LCAxMjgpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVoYXNoOiBIZXgudG9OdW1iZXIoSGV4LnNsaWNlKGRhdGEsIDEyOCwgMTI5KSkgIT09IDAsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHtcbiAgICAgICAgICAgICAgICByOiBIZXgudG9CaWdJbnQoSGV4LnNsaWNlKGRhdGEsIDAsIDMyKSksXG4gICAgICAgICAgICAgICAgczogSGV4LnRvQmlnSW50KEhleC5zbGljZShkYXRhLCAzMiwgNjQpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiAncDI1NicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlSWQgPT09IHNlcmlhbGl6ZWRXZWJBdXRoblR5cGUpIHtcbiAgICAgICAgLy8gV2ViQXV0aG46IHZhcmlhYmxlICh3ZWJhdXRobkRhdGEpICsgMzIgKHIpICsgMzIgKHMpICsgMzIgKHB1YktleVgpICsgMzIgKHB1YktleVkpXG4gICAgICAgIC8vIE1pbmltdW06IDEyOCBieXRlcyAoYXQgbGVhc3Qgc29tZSBhdXRoZW50aWNhdG9yIGRhdGEgKyBzaWduYXR1cmUgY29tcG9uZW50cylcbiAgICAgICAgaWYgKGRhdGFTaXplIDwgMTI4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHJlYXNvbjogYEludmFsaWQgV2ViQXV0aG4gc2lnbmF0dXJlIGVudmVsb3BlIHNpemU6IGV4cGVjdGVkIGF0IGxlYXN0IDEyOCBieXRlcywgZ290ICR7ZGF0YVNpemV9IGJ5dGVzYCxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdlYmF1dGhuRGF0YVNpemUgPSBkYXRhU2l6ZSAtIDEyODtcbiAgICAgICAgY29uc3Qgd2ViYXV0aG5EYXRhID0gSGV4LnNsaWNlKGRhdGEsIDAsIHdlYmF1dGhuRGF0YVNpemUpO1xuICAgICAgICAvLyBQYXJzZSB3ZWJhdXRobkRhdGEgaW50byBhdXRoZW50aWNhdG9yRGF0YSBhbmQgY2xpZW50RGF0YUpTT05cbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBSdXN0IGNvZGUsIGl0J3MgYXV0aGVudGljYXRvckRhdGEgfHwgY2xpZW50RGF0YUpTT05cbiAgICAgICAgLy8gV2UgbmVlZCB0byBmaW5kIHRoZSBzcGxpdCBwb2ludCAobWluaW11bSBhdXRoZW50aWNhdG9yRGF0YSBpcyAzNyBieXRlcylcbiAgICAgICAgbGV0IGF1dGhlbnRpY2F0b3JEYXRhO1xuICAgICAgICBsZXQgY2xpZW50RGF0YUpTT047XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBKU09OIHN0YXJ0IChjbGllbnREYXRhSlNPTiBzaG91bGQgc3RhcnQgd2l0aCAneycpXG4gICAgICAgIGZvciAobGV0IHNwbGl0ID0gMzc7IHNwbGl0IDwgd2ViYXV0aG5EYXRhU2l6ZTsgc3BsaXQrKykge1xuICAgICAgICAgICAgY29uc3QgcG90ZW50aWFsSnNvbiA9IEhleC50b1N0cmluZyhIZXguc2xpY2Uod2ViYXV0aG5EYXRhLCBzcGxpdCkpO1xuICAgICAgICAgICAgaWYgKHBvdGVudGlhbEpzb24uc3RhcnRzV2l0aCgneycpICYmIHBvdGVudGlhbEpzb24uZW5kc1dpdGgoJ30nKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UocG90ZW50aWFsSnNvbik7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JEYXRhID0gSGV4LnNsaWNlKHdlYmF1dGhuRGF0YSwgMCwgc3BsaXQpO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnREYXRhSlNPTiA9IHBvdGVudGlhbEpzb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWF1dGhlbnRpY2F0b3JEYXRhIHx8ICFjbGllbnREYXRhSlNPTilcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXplZEVycm9yKHtcbiAgICAgICAgICAgICAgICByZWFzb246ICdVbmFibGUgdG8gcGFyc2UgV2ViQXV0aG4gbWV0YWRhdGE6IGNvdWxkIG5vdCBleHRyYWN0IHZhbGlkIGF1dGhlbnRpY2F0b3JEYXRhIGFuZCBjbGllbnREYXRhSlNPTicsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiB7XG4gICAgICAgICAgICAgICAgcHJlZml4OiA0LFxuICAgICAgICAgICAgICAgIHg6IEhleC50b0JpZ0ludChIZXguc2xpY2UoZGF0YSwgd2ViYXV0aG5EYXRhU2l6ZSArIDY0LCB3ZWJhdXRobkRhdGFTaXplICsgOTYpKSxcbiAgICAgICAgICAgICAgICB5OiBIZXgudG9CaWdJbnQoSGV4LnNsaWNlKGRhdGEsIHdlYmF1dGhuRGF0YVNpemUgKyA5Niwgd2ViYXV0aG5EYXRhU2l6ZSArIDEyOCkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgYXV0aGVudGljYXRvckRhdGEsXG4gICAgICAgICAgICAgICAgY2xpZW50RGF0YUpTT04sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmF0dXJlOiB7XG4gICAgICAgICAgICAgICAgcjogSGV4LnRvQmlnSW50KEhleC5zbGljZShkYXRhLCB3ZWJhdXRobkRhdGFTaXplLCB3ZWJhdXRobkRhdGFTaXplICsgMzIpKSxcbiAgICAgICAgICAgICAgICBzOiBIZXgudG9CaWdJbnQoSGV4LnNsaWNlKGRhdGEsIHdlYmF1dGhuRGF0YVNpemUgKyAzMiwgd2ViYXV0aG5EYXRhU2l6ZSArIDY0KSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZTogJ3dlYkF1dGhuJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVJZCA9PT0gc2VyaWFsaXplZEtleWNoYWluVHlwZSkge1xuICAgICAgICBjb25zdCB1c2VyQWRkcmVzcyA9IEhleC5zbGljZShkYXRhLCAwLCAyMCk7XG4gICAgICAgIGNvbnN0IGlubmVyID0gZGVzZXJpYWxpemUoSGV4LnNsaWNlKGRhdGEsIDIwKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyQWRkcmVzcyxcbiAgICAgICAgICAgIGlubmVyLFxuICAgICAgICAgICAgdHlwZTogJ2tleWNoYWluJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkRXJyb3Ioe1xuICAgICAgICByZWFzb246IGBVbmtub3duIHNpZ25hdHVyZSB0eXBlIGlkZW50aWZpZXI6ICR7dHlwZUlkfS4gRXhwZWN0ZWQgJHtzZXJpYWxpemVkUDI1NlR5cGV9IChQMjU2KSBvciAke3NlcmlhbGl6ZWRXZWJBdXRoblR5cGV9IChXZWJBdXRobilgLFxuICAgICAgICBzZXJpYWxpemVkLFxuICAgIH0pO1xufVxuLyoqXG4gKiBDb2VyY2VzIGEgdmFsdWUgdG8gYSBzaWduYXR1cmUgZW52ZWxvcGUuXG4gKlxuICogQWNjZXB0cyBlaXRoZXIgYSBzZXJpYWxpemVkIGhleCBzdHJpbmcgb3IgYW4gZXhpc3Rpbmcgc2lnbmF0dXJlIGVudmVsb3BlIG9iamVjdC5cbiAqIFVzZSB0aGlzIHRvIHdyYXAgcmF3IHNpZ25hdHVyZXMgZnJvbSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0sIHtAbGluayBveCNQMjU2LihzaWduOmZ1bmN0aW9uKX0sXG4gKiB7QGxpbmsgb3gjV2ViQ3J5cHRvUDI1Ni4oc2lnbjpmdW5jdGlvbil9LCBvciB7QGxpbmsgb3gjV2ViQXV0aG5QMjU2LihzaWduOmZ1bmN0aW9uKX0gaW50byB0aGUgZW52ZWxvcGUgZm9ybWF0XG4gKiByZXF1aXJlZCBieSBUZW1wbyB0cmFuc2FjdGlvbnMuXG4gKlxuICogW1NpZ25hdHVyZSBUeXBlc10oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbiNzaWduYXR1cmUtdHlwZXMpXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBTZWNwMjU2azFcbiAqXG4gKiBTdGFuZGFyZCBFdGhlcmV1bSBFQ0RTQSBzaWduYXR1cmUgdXNpbmcgdGhlIHNlY3AyNTZrMSBjdXJ2ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHByaXZhdGVLZXkgPSBTZWNwMjU2azEucmFuZG9tUHJpdmF0ZUtleSgpXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQ6ICcweGRlYWRiZWVmJywgcHJpdmF0ZUtleSB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbShzaWduYXR1cmUpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFAyNTZcbiAqXG4gKiBFQ0RTQSBzaWduYXR1cmUgdXNpbmcgdGhlIFAtMjU2IChzZWNwMjU2cjEpIGN1cnZlLiBSZXF1aXJlcyBlbWJlZGRpbmcgdGhlXG4gKiBwdWJsaWMga2V5LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQMjU2IH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0gPSBQMjU2LmNyZWF0ZUtleVBhaXIoKVxuICogY29uc3Qgc2lnbmF0dXJlID0gUDI1Ni5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5IH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tKHtcbiAqICAgc2lnbmF0dXJlLFxuICogICBwdWJsaWNLZXksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBQMjU2IChXZWJDcnlwdG8pXG4gKlxuICogV2hlbiB1c2luZyBXZWJDcnlwdG8ga2V5cywgYHByZWhhc2hgIG11c3QgYmUgYHRydWVgIHNpbmNlIFdlYkNyeXB0byBhbHdheXNcbiAqIFNIQTI1NiBoYXNoZXMgdGhlIGRpZ2VzdCBiZWZvcmUgc2lnbmluZy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBXZWJDcnlwdG9QMjU2IH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH0gPSBhd2FpdCBXZWJDcnlwdG9QMjU2LmNyZWF0ZUtleVBhaXIoKVxuICogY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgV2ViQ3J5cHRvUDI1Ni5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5IH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tKHtcbiAqICAgc2lnbmF0dXJlLFxuICogICBwdWJsaWNLZXksXG4gKiAgIHByZWhhc2g6IHRydWUsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBXZWJBdXRoblxuICpcbiAqIFBhc3NrZXktYmFzZWQgc2lnbmF0dXJlIHVzaW5nIFdlYkF1dGhuLiBJbmNsdWRlcyBhdXRoZW50aWNhdG9yIG1ldGFkYXRhXG4gKiAoYXV0aGVudGljYXRvckRhdGEgYW5kIGNsaWVudERhdGFKU09OKSBhbG9uZyB3aXRoIHRoZSBQLTI1NiBzaWduYXR1cmUgYW5kXG4gKiBwdWJsaWMga2V5LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFdlYkF1dGhuUDI1NiB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBjcmVkZW50aWFsID0gYXdhaXQgV2ViQXV0aG5QMjU2LmNyZWF0ZUNyZWRlbnRpYWwoe1xuICogICBuYW1lOiAnRXhhbXBsZScsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHsgbWV0YWRhdGEsIHNpZ25hdHVyZSB9ID0gYXdhaXQgV2ViQXV0aG5QMjU2LnNpZ24oe1xuICogICBjaGFsbGVuZ2U6ICcweGRlYWRiZWVmJyxcbiAqICAgY3JlZGVudGlhbElkOiBjcmVkZW50aWFsLmlkLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oe1xuICogICBzaWduYXR1cmUsXG4gKiAgIHB1YmxpY0tleTogY3JlZGVudGlhbC5wdWJsaWNLZXksXG4gKiAgIG1ldGFkYXRhLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgS2V5Y2hhaW5cbiAqXG4gKiBXcmFwcyBhbm90aGVyIHNpZ25hdHVyZSB0eXBlIHdpdGggYSB1c2VyIGFkZHJlc3MsIHVzZWQgZm9yIGRlbGVnYXRlZCBzaWduaW5nXG4gKiB2aWEgYWNjZXNzIGtleXMgb24gYmVoYWxmIG9mIGEgcm9vdCBhY2NvdW50LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFNlY3AyNTZrMS5yYW5kb21Qcml2YXRlS2V5KClcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZDogJzB4ZGVhZGJlZWYnLCBwcml2YXRlS2V5IH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tKHtcbiAqICAgdXNlckFkZHJlc3M6ICcweDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTIzNDU2Nzg5MDEyMzQ1Njc4OTAnLFxuICogICBpbm5lcjogU2lnbmF0dXJlRW52ZWxvcGUuZnJvbShzaWduYXR1cmUpLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb2VyY2UgKGVpdGhlciBhIGhleCBzdHJpbmcgb3Igc2lnbmF0dXJlIGVudmVsb3BlKS5cbiAqIEByZXR1cm5zIFRoZSBzaWduYXR1cmUgZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgJ3InIGluIHZhbHVlICYmXG4gICAgICAgICdzJyBpbiB2YWx1ZSAmJlxuICAgICAgICAneVBhcml0eScgaW4gdmFsdWUpXG4gICAgICAgIHJldHVybiB7IHNpZ25hdHVyZTogdmFsdWUsIHR5cGU6ICdzZWNwMjU2azEnIH07XG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAuLi4odHlwZSA9PT0gJ3AyNTYnID8geyBwcmVoYXNoOiB2YWx1ZS5wcmVoYXNoIH0gOiB7fSksXG4gICAgICAgIHR5cGUsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gUlBDLWZvcm1hdHRlZCBzaWduYXR1cmUgZW52ZWxvcGUgdG8gYSB0eXBlZCBzaWduYXR1cmUgZW52ZWxvcGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbVJwYyh7XG4gKiAgIHI6ICcweDAnLFxuICogICBzOiAnMHgwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBSUEMgc2lnbmF0dXJlIGVudmVsb3BlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmF0dXJlIGVudmVsb3BlIHdpdGggYmlnaW50IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMoZW52ZWxvcGUpIHtcbiAgICBpZiAoZW52ZWxvcGUudHlwZSA9PT0gJ3NlY3AyNTZrMScpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaWduYXR1cmU6IFNpZ25hdHVyZS5mcm9tUnBjKGVudmVsb3BlKSxcbiAgICAgICAgICAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICAgICAgICB9O1xuICAgIGlmIChlbnZlbG9wZS50eXBlID09PSAncDI1NicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZWhhc2g6IGVudmVsb3BlLnByZWhhc2gsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHtcbiAgICAgICAgICAgICAgICBwcmVmaXg6IDQsXG4gICAgICAgICAgICAgICAgeDogSGV4LnRvQmlnSW50KGVudmVsb3BlLnB1YktleVgpLFxuICAgICAgICAgICAgICAgIHk6IEhleC50b0JpZ0ludChlbnZlbG9wZS5wdWJLZXlZKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWduYXR1cmU6IHtcbiAgICAgICAgICAgICAgICByOiBIZXgudG9CaWdJbnQoZW52ZWxvcGUuciksXG4gICAgICAgICAgICAgICAgczogSGV4LnRvQmlnSW50KGVudmVsb3BlLnMpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGU6ICdwMjU2JyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGVudmVsb3BlLnR5cGUgPT09ICd3ZWJBdXRobicpIHtcbiAgICAgICAgY29uc3Qgd2ViYXV0aG5EYXRhID0gZW52ZWxvcGUud2ViYXV0aG5EYXRhO1xuICAgICAgICBjb25zdCB3ZWJhdXRobkRhdGFTaXplID0gSGV4LnNpemUod2ViYXV0aG5EYXRhKTtcbiAgICAgICAgLy8gUGFyc2Ugd2ViYXV0aG5EYXRhIGludG8gYXV0aGVudGljYXRvckRhdGEgYW5kIGNsaWVudERhdGFKU09OXG4gICAgICAgIGxldCBhdXRoZW50aWNhdG9yRGF0YTtcbiAgICAgICAgbGV0IGNsaWVudERhdGFKU09OO1xuICAgICAgICAvLyBUcnkgdG8gZmluZCB0aGUgSlNPTiBzdGFydCAoY2xpZW50RGF0YUpTT04gc2hvdWxkIHN0YXJ0IHdpdGggJ3snKVxuICAgICAgICBmb3IgKGxldCBzcGxpdCA9IDM3OyBzcGxpdCA8IHdlYmF1dGhuRGF0YVNpemU7IHNwbGl0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbEpzb24gPSBIZXgudG9TdHJpbmcoSGV4LnNsaWNlKHdlYmF1dGhuRGF0YSwgc3BsaXQpKTtcbiAgICAgICAgICAgIGlmIChwb3RlbnRpYWxKc29uLnN0YXJ0c1dpdGgoJ3snKSAmJiBwb3RlbnRpYWxKc29uLmVuZHNXaXRoKCd9JykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKHBvdGVudGlhbEpzb24pO1xuICAgICAgICAgICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YSA9IEhleC5zbGljZSh3ZWJhdXRobkRhdGEsIDAsIHNwbGl0KTtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50RGF0YUpTT04gPSBwb3RlbnRpYWxKc29uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhdXRoZW50aWNhdG9yRGF0YSB8fCAhY2xpZW50RGF0YUpTT04pXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICAgICAgcmVhc29uOiAnVW5hYmxlIHRvIHBhcnNlIFdlYkF1dGhuIG1ldGFkYXRhOiBjb3VsZCBub3QgZXh0cmFjdCB2YWxpZCBhdXRoZW50aWNhdG9yRGF0YSBhbmQgY2xpZW50RGF0YUpTT04nLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHdlYmF1dGhuRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YSxcbiAgICAgICAgICAgICAgICBjbGllbnREYXRhSlNPTixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHtcbiAgICAgICAgICAgICAgICBwcmVmaXg6IDQsXG4gICAgICAgICAgICAgICAgeDogSGV4LnRvQmlnSW50KGVudmVsb3BlLnB1YktleVgpLFxuICAgICAgICAgICAgICAgIHk6IEhleC50b0JpZ0ludChlbnZlbG9wZS5wdWJLZXlZKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWduYXR1cmU6IHtcbiAgICAgICAgICAgICAgICByOiBIZXgudG9CaWdJbnQoZW52ZWxvcGUuciksXG4gICAgICAgICAgICAgICAgczogSGV4LnRvQmlnSW50KGVudmVsb3BlLnMpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGU6ICd3ZWJBdXRobicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChlbnZlbG9wZS50eXBlID09PSAna2V5Y2hhaW4nIHx8XG4gICAgICAgICgndXNlckFkZHJlc3MnIGluIGVudmVsb3BlICYmICdzaWduYXR1cmUnIGluIGVudmVsb3BlKSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdrZXljaGFpbicsXG4gICAgICAgICAgICB1c2VyQWRkcmVzczogZW52ZWxvcGUudXNlckFkZHJlc3MsXG4gICAgICAgICAgICBpbm5lcjogZnJvbVJwYyhlbnZlbG9wZS5zaWduYXR1cmUpLFxuICAgICAgICB9O1xuICAgIHRocm93IG5ldyBDb2VyY2lvbkVycm9yKHsgZW52ZWxvcGUgfSk7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIHNpZ25hdHVyZSB0eXBlIG9mIGFuIGVudmVsb3BlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCB0eXBlID0gU2lnbmF0dXJlRW52ZWxvcGUuZ2V0VHlwZSh7XG4gKiAgIHNpZ25hdHVyZTogeyByOiAwbiwgczogMG4sIHlQYXJpdHk6IDAgfSxcbiAqIH0pXG4gKiAvLyBAbG9nOiAnc2VjcDI1NmsxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHNpZ25hdHVyZSBlbnZlbG9wZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMgVGhlIHNpZ25hdHVyZSB0eXBlICgnc2VjcDI1NmsxJywgJ3AyNTYnLCBvciAnd2ViQXV0aG4nKS5cbiAqIEB0aHJvd3MgYENvZXJjaW9uRXJyb3JgIGlmIHRoZSBlbnZlbG9wZSB0eXBlIGNhbm5vdCBiZSBkZXRlcm1pbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZShlbnZlbG9wZSkge1xuICAgIGlmICh0eXBlb2YgZW52ZWxvcGUgIT09ICdvYmplY3QnIHx8IGVudmVsb3BlID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgQ29lcmNpb25FcnJvcih7IGVudmVsb3BlIH0pO1xuICAgIGlmICgndHlwZScgaW4gZW52ZWxvcGUgJiYgZW52ZWxvcGUudHlwZSlcbiAgICAgICAgcmV0dXJuIGVudmVsb3BlLnR5cGU7XG4gICAgLy8gRGV0ZWN0IHNlY3AyNTZrMSBzaWduYXR1cmUgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBhbHNvIHN1cHBvcnQgZmxhdCBzdHJ1Y3R1cmUpXG4gICAgaWYgKCdzaWduYXR1cmUnIGluIGVudmVsb3BlICYmXG4gICAgICAgICEoJ3B1YmxpY0tleScgaW4gZW52ZWxvcGUpICYmXG4gICAgICAgIHR5cGVvZiBlbnZlbG9wZS5zaWduYXR1cmUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGVudmVsb3BlLnNpZ25hdHVyZSAhPT0gbnVsbCAmJlxuICAgICAgICAncicgaW4gZW52ZWxvcGUuc2lnbmF0dXJlICYmXG4gICAgICAgICdzJyBpbiBlbnZlbG9wZS5zaWduYXR1cmUgJiZcbiAgICAgICAgJ3lQYXJpdHknIGluIGVudmVsb3BlLnNpZ25hdHVyZSlcbiAgICAgICAgcmV0dXJuICdzZWNwMjU2azEnO1xuICAgIC8vIERldGVjdCBzZWNwMjU2azEgc2lnbmF0dXJlIChmbGF0IHN0cnVjdHVyZSlcbiAgICBpZiAoJ3InIGluIGVudmVsb3BlICYmICdzJyBpbiBlbnZlbG9wZSAmJiAneVBhcml0eScgaW4gZW52ZWxvcGUpXG4gICAgICAgIHJldHVybiAnc2VjcDI1NmsxJztcbiAgICAvLyBEZXRlY3QgUDI1NiBzaWduYXR1cmVcbiAgICBpZiAoJ3NpZ25hdHVyZScgaW4gZW52ZWxvcGUgJiZcbiAgICAgICAgJ3ByZWhhc2gnIGluIGVudmVsb3BlICYmXG4gICAgICAgICdwdWJsaWNLZXknIGluIGVudmVsb3BlICYmXG4gICAgICAgIHR5cGVvZiBlbnZlbG9wZS5wcmVoYXNoID09PSAnYm9vbGVhbicpXG4gICAgICAgIHJldHVybiAncDI1Nic7XG4gICAgLy8gRGV0ZWN0IFdlYkF1dGhuIHNpZ25hdHVyZVxuICAgIGlmICgnc2lnbmF0dXJlJyBpbiBlbnZlbG9wZSAmJlxuICAgICAgICAnbWV0YWRhdGEnIGluIGVudmVsb3BlICYmXG4gICAgICAgICdwdWJsaWNLZXknIGluIGVudmVsb3BlKVxuICAgICAgICByZXR1cm4gJ3dlYkF1dGhuJztcbiAgICAvLyBEZXRlY3QgS2V5Y2hhaW4gc2lnbmF0dXJlXG4gICAgaWYgKCd1c2VyQWRkcmVzcycgaW4gZW52ZWxvcGUgJiYgJ2lubmVyJyBpbiBlbnZlbG9wZSlcbiAgICAgICAgcmV0dXJuICdrZXljaGFpbic7XG4gICAgdGhyb3cgbmV3IENvZXJjaW9uRXJyb3Ioe1xuICAgICAgICBlbnZlbG9wZSxcbiAgICB9KTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHNpZ25hdHVyZSBlbnZlbG9wZSB0byBhIGhleC1lbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBXaXJlIGZvcm1hdDpcbiAqIC0gc2VjcDI1NmsxOiA2NSBieXRlcyAobm8gdHlwZSBwcmVmaXgsIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICogLSBQMjU2OiBgMHgwMWAgKyByICgzMikgKyBzICgzMikgKyBwdWJLZXlYICgzMikgKyBwdWJLZXlZICgzMikgKyBwcmVoYXNoICgxKSA9IDEzMCBieXRlc1xuICogLSBXZWJBdXRobjogYDB4MDJgICsgd2ViYXV0aG5EYXRhICh2YXJpYWJsZSkgKyByICgzMikgKyBzICgzMikgKyBwdWJLZXlYICgzMikgKyBwdWJLZXlZICgzMilcbiAqIC0gS2V5Y2hhaW46IGAweDAzYCArIHVzZXJBZGRyZXNzICgyMCkgKyBpbm5lciBzaWduYXR1cmUgKHJlY3Vyc2l2ZSlcbiAqXG4gKiBbU2lnbmF0dXJlIFR5cGVzXShodHRwczovL2RvY3MudGVtcG8ueHl6L3Byb3RvY29sL3RyYW5zYWN0aW9ucy9zcGVjLXRlbXBvLXRyYW5zYWN0aW9uI3NpZ25hdHVyZS10eXBlcylcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFNpZ25hdHVyZUVudmVsb3BlLnNlcmlhbGl6ZSh7XG4gKiAgIHNpZ25hdHVyZTogeyByOiAwbiwgczogMG4sIHlQYXJpdHk6IDAgfSxcbiAqICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHNpZ25hdHVyZSBlbnZlbG9wZSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgaGV4LWVuY29kZWQgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKiBAdGhyb3dzIGBDb2VyY2lvbkVycm9yYCBpZiB0aGUgZW52ZWxvcGUgY2Fubm90IGJlIHNlcmlhbGl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUoZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKGVudmVsb3BlKTtcbiAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBubyB0eXBlIGlkZW50aWZpZXIgZm9yIHNlY3AyNTZrMVxuICAgIGlmICh0eXBlID09PSAnc2VjcDI1NmsxJykge1xuICAgICAgICBjb25zdCBzZWNwMjU2azEgPSBlbnZlbG9wZTtcbiAgICAgICAgcmV0dXJuIEhleC5jb25jYXQoU2lnbmF0dXJlLnRvSGV4KHNlY3AyNTZrMS5zaWduYXR1cmUpLCBvcHRpb25zLm1hZ2ljID8gbWFnaWNCeXRlcyA6ICcweCcpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3AyNTYnKSB7XG4gICAgICAgIGNvbnN0IHAyNTYgPSBlbnZlbG9wZTtcbiAgICAgICAgLy8gRm9ybWF0OiAxIGJ5dGUgKHR5cGUpICsgMzIgKHIpICsgMzIgKHMpICsgMzIgKHB1YktleVgpICsgMzIgKHB1YktleVkpICsgMSAocHJlaGFzaClcbiAgICAgICAgcmV0dXJuIEhleC5jb25jYXQoc2VyaWFsaXplZFAyNTZUeXBlLCBIZXguZnJvbU51bWJlcihwMjU2LnNpZ25hdHVyZS5yLCB7IHNpemU6IDMyIH0pLCBIZXguZnJvbU51bWJlcihwMjU2LnNpZ25hdHVyZS5zLCB7IHNpemU6IDMyIH0pLCBIZXguZnJvbU51bWJlcihwMjU2LnB1YmxpY0tleS54LCB7IHNpemU6IDMyIH0pLCBIZXguZnJvbU51bWJlcihwMjU2LnB1YmxpY0tleS55LCB7IHNpemU6IDMyIH0pLCBIZXguZnJvbU51bWJlcihwMjU2LnByZWhhc2ggPyAxIDogMCwgeyBzaXplOiAxIH0pLCBvcHRpb25zLm1hZ2ljID8gbWFnaWNCeXRlcyA6ICcweCcpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3dlYkF1dGhuJykge1xuICAgICAgICBjb25zdCB3ZWJhdXRobiA9IGVudmVsb3BlO1xuICAgICAgICAvLyBGb3JtYXQ6IDEgYnl0ZSAodHlwZSkgKyB2YXJpYWJsZSAoYXV0aGVudGljYXRvckRhdGEgfHwgY2xpZW50RGF0YUpTT04pICsgMzIgKHIpICsgMzIgKHMpICsgMzIgKHB1YktleVgpICsgMzIgKHB1YktleVkpXG4gICAgICAgIGNvbnN0IHdlYmF1dGhuRGF0YSA9IEhleC5jb25jYXQod2ViYXV0aG4ubWV0YWRhdGEuYXV0aGVudGljYXRvckRhdGEsIEhleC5mcm9tU3RyaW5nKHdlYmF1dGhuLm1ldGFkYXRhLmNsaWVudERhdGFKU09OKSk7XG4gICAgICAgIHJldHVybiBIZXguY29uY2F0KHNlcmlhbGl6ZWRXZWJBdXRoblR5cGUsIHdlYmF1dGhuRGF0YSwgSGV4LmZyb21OdW1iZXIod2ViYXV0aG4uc2lnbmF0dXJlLnIsIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHdlYmF1dGhuLnNpZ25hdHVyZS5zLCB7IHNpemU6IDMyIH0pLCBIZXguZnJvbU51bWJlcih3ZWJhdXRobi5wdWJsaWNLZXkueCwgeyBzaXplOiAzMiB9KSwgSGV4LmZyb21OdW1iZXIod2ViYXV0aG4ucHVibGljS2V5LnksIHsgc2l6ZTogMzIgfSksIG9wdGlvbnMubWFnaWMgPyBtYWdpY0J5dGVzIDogJzB4Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAna2V5Y2hhaW4nKSB7XG4gICAgICAgIGNvbnN0IGtleWNoYWluID0gZW52ZWxvcGU7XG4gICAgICAgIHJldHVybiBIZXguY29uY2F0KHNlcmlhbGl6ZWRLZXljaGFpblR5cGUsIGtleWNoYWluLnVzZXJBZGRyZXNzLCBzZXJpYWxpemUoa2V5Y2hhaW4uaW5uZXIpLCBvcHRpb25zLm1hZ2ljID8gbWFnaWNCeXRlcyA6ICcweCcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQ29lcmNpb25FcnJvcih7IGVudmVsb3BlIH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpZ25hdHVyZSBlbnZlbG9wZSB0byBSUEMgZm9ybWF0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBycGMgPSBTaWduYXR1cmVFbnZlbG9wZS50b1JwYyh7XG4gKiAgIHNpZ25hdHVyZTogeyByOiAwbiwgczogMG4sIHlQYXJpdHk6IDAgfSxcbiAqICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHNpZ25hdHVyZSBlbnZlbG9wZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIFJQQyBzaWduYXR1cmUgZW52ZWxvcGUgd2l0aCBoZXggdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoZW52ZWxvcGUpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0VHlwZShlbnZlbG9wZSk7XG4gICAgaWYgKHR5cGUgPT09ICdzZWNwMjU2azEnKSB7XG4gICAgICAgIGNvbnN0IHNlY3AyNTZrMSA9IGVudmVsb3BlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uU2lnbmF0dXJlLnRvUnBjKHNlY3AyNTZrMS5zaWduYXR1cmUpLFxuICAgICAgICAgICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAncDI1NicpIHtcbiAgICAgICAgY29uc3QgcDI1NiA9IGVudmVsb3BlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlaGFzaDogcDI1Ni5wcmVoYXNoLFxuICAgICAgICAgICAgcHViS2V5WDogSGV4LmZyb21OdW1iZXIocDI1Ni5wdWJsaWNLZXkueCwgeyBzaXplOiAzMiB9KSxcbiAgICAgICAgICAgIHB1YktleVk6IEhleC5mcm9tTnVtYmVyKHAyNTYucHVibGljS2V5LnksIHsgc2l6ZTogMzIgfSksXG4gICAgICAgICAgICByOiBIZXguZnJvbU51bWJlcihwMjU2LnNpZ25hdHVyZS5yLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICAgICAgczogSGV4LmZyb21OdW1iZXIocDI1Ni5zaWduYXR1cmUucywgeyBzaXplOiAzMiB9KSxcbiAgICAgICAgICAgIHR5cGU6ICdwMjU2JyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICd3ZWJBdXRobicpIHtcbiAgICAgICAgY29uc3Qgd2ViYXV0aG4gPSBlbnZlbG9wZTtcbiAgICAgICAgY29uc3Qgd2ViYXV0aG5EYXRhID0gSGV4LmNvbmNhdCh3ZWJhdXRobi5tZXRhZGF0YS5hdXRoZW50aWNhdG9yRGF0YSwgSGV4LmZyb21TdHJpbmcod2ViYXV0aG4ubWV0YWRhdGEuY2xpZW50RGF0YUpTT04pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YktleVg6IEhleC5mcm9tTnVtYmVyKHdlYmF1dGhuLnB1YmxpY0tleS54LCB7IHNpemU6IDMyIH0pLFxuICAgICAgICAgICAgcHViS2V5WTogSGV4LmZyb21OdW1iZXIod2ViYXV0aG4ucHVibGljS2V5LnksIHsgc2l6ZTogMzIgfSksXG4gICAgICAgICAgICByOiBIZXguZnJvbU51bWJlcih3ZWJhdXRobi5zaWduYXR1cmUuciwgeyBzaXplOiAzMiB9KSxcbiAgICAgICAgICAgIHM6IEhleC5mcm9tTnVtYmVyKHdlYmF1dGhuLnNpZ25hdHVyZS5zLCB7IHNpemU6IDMyIH0pLFxuICAgICAgICAgICAgdHlwZTogJ3dlYkF1dGhuJyxcbiAgICAgICAgICAgIHdlYmF1dGhuRGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdrZXljaGFpbicpIHtcbiAgICAgICAgY29uc3Qga2V5Y2hhaW4gPSBlbnZlbG9wZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdrZXljaGFpbicsXG4gICAgICAgICAgICB1c2VyQWRkcmVzczoga2V5Y2hhaW4udXNlckFkZHJlc3MsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHRvUnBjKGtleWNoYWluLmlubmVyKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IENvZXJjaW9uRXJyb3IoeyBlbnZlbG9wZSB9KTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgc2lnbmF0dXJlIGVudmVsb3BlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZUVudmVsb3BlLnZhbGlkYXRlKHtcbiAqICAgc2lnbmF0dXJlOiB7IHI6IDBuLCBzOiAwbiwgeVBhcml0eTogMCB9LFxuICogICB0eXBlOiAnc2VjcDI1NmsxJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgc2lnbmF0dXJlIGVudmVsb3BlIHRvIHZhbGlkYXRlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKGVudmVsb3BlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVmVyaWZpZXMgYSBzaWduYXR1cmUgZW52ZWxvcGUgYWdhaW5zdCBhIGRpZ2VzdC9wYXlsb2FkLlxuICpcbiAqIFN1cHBvcnRzIGBzZWNwMjU2azFgLCBgcDI1NmAsIGFuZCBgd2ViQXV0aG5gIHNpZ25hdHVyZSB0eXBlcy5cbiAqXG4gKiA6Ojp3YXJuaW5nXG4gKiBga2V5Y2hhaW5gIHNpZ25hdHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFNlY3AyNTZrMVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmVFbnZlbG9wZSB9IGZyb20gJ294L3RlbXBvJ1xuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFNlY3AyNTZrMS5yYW5kb21Qcml2YXRlS2V5KClcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoeyBwcml2YXRlS2V5IH0pXG4gKiBjb25zdCBwYXlsb2FkID0gJzB4ZGVhZGJlZWYnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5IH0pXG4gKiBjb25zdCBlbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oc2lnbmF0dXJlKVxuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlRW52ZWxvcGUudmVyaWZ5KGVudmVsb3BlLCB7XG4gKiAgIHBheWxvYWQsXG4gKiAgIHB1YmxpY0tleSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIFAyNTZcbiAqXG4gKiBGb3IgUDI1NiBzaWduYXR1cmVzLCB0aGUgYGFkZHJlc3NgIG9yIGBwdWJsaWNLZXlgIG11c3QgbWF0Y2ggdGhlIGVtYmVkZGVkXG4gKiBwdWJsaWMga2V5IGluIHRoZSBzaWduYXR1cmUgZW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKiBpbXBvcnQgeyBQMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHJpdmF0ZUtleSA9IFAyNTYucmFuZG9tUHJpdmF0ZUtleSgpXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQMjU2LmdldFB1YmxpY0tleSh7IHByaXZhdGVLZXkgfSlcbiAqIGNvbnN0IHBheWxvYWQgPSAnMHhkZWFkYmVlZidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBQMjU2LnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5IH0pXG4gKiBjb25zdCBlbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oeyBwcmVoYXNoOiBmYWxzZSwgcHVibGljS2V5LCBzaWduYXR1cmUgfSlcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZUVudmVsb3BlLnZlcmlmeShlbnZlbG9wZSwge1xuICogICBwYXlsb2FkLFxuICogICBwdWJsaWNLZXksXG4gKiB9KVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBXZWJDcnlwdG9QMjU2XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZUVudmVsb3BlIH0gZnJvbSAnb3gvdGVtcG8nXG4gKiBpbXBvcnQgeyBXZWJDcnlwdG9QMjU2IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgeyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfSA9IGF3YWl0IFdlYkNyeXB0b1AyNTYuY3JlYXRlS2V5UGFpcigpXG4gKiBjb25zdCBwYXlsb2FkID0gJzB4ZGVhZGJlZWYnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgV2ViQ3J5cHRvUDI1Ni5zaWduKHsgcGF5bG9hZCwgcHJpdmF0ZUtleSB9KVxuICogY29uc3QgZW52ZWxvcGUgPSBTaWduYXR1cmVFbnZlbG9wZS5mcm9tKHsgcHJlaGFzaDogdHJ1ZSwgcHVibGljS2V5LCBzaWduYXR1cmUgfSlcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZUVudmVsb3BlLnZlcmlmeShlbnZlbG9wZSwge1xuICogICBwYXlsb2FkLFxuICogICBwdWJsaWNLZXksXG4gKiB9KVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBXZWJBdXRoblAyNTZcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlRW52ZWxvcGUgfSBmcm9tICdveC90ZW1wbydcbiAqIGltcG9ydCB7IFdlYkF1dGhuUDI1NiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBhd2FpdCBXZWJBdXRoblAyNTYuY3JlYXRlQ3JlZGVudGlhbCh7IG5hbWU6ICdFeGFtcGxlJyB9KVxuICogY29uc3QgcGF5bG9hZCA9ICcweGRlYWRiZWVmJ1xuICpcbiAqIGNvbnN0IHsgbWV0YWRhdGEsIHNpZ25hdHVyZSB9ID0gYXdhaXQgV2ViQXV0aG5QMjU2LnNpZ24oe1xuICogICBjaGFsbGVuZ2U6IHBheWxvYWQsXG4gKiAgIGNyZWRlbnRpYWxJZDogY3JlZGVudGlhbC5pZCxcbiAqIH0pXG4gKiBjb25zdCBlbnZlbG9wZSA9IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oe1xuICogICBtZXRhZGF0YSxcbiAqICAgc2lnbmF0dXJlLFxuICogICBwdWJsaWNLZXk6IGNyZWRlbnRpYWwucHVibGljS2V5LFxuICogfSlcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFNpZ25hdHVyZUVudmVsb3BlLnZlcmlmeShlbnZlbG9wZSwge1xuICogICBwYXlsb2FkLFxuICogICBwdWJsaWNLZXk6IGNyZWRlbnRpYWwucHVibGljS2V5LFxuICogfSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gVmVyaWZpY2F0aW9uIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgeyBwYXlsb2FkIH0gPSBwYXJhbWV0ZXJzO1xuICAgIGNvbnN0IGFkZHJlc3MgPSAoKCkgPT4ge1xuICAgICAgICBpZiAocGFyYW1ldGVycy5hZGRyZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnMuYWRkcmVzcztcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMucHVibGljS2V5KVxuICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MuZnJvbVB1YmxpY0tleShwYXJhbWV0ZXJzLnB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSkoKTtcbiAgICBpZiAoIWFkZHJlc3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBlbnZlbG9wZSA9IGZyb20oc2lnbmF0dXJlKTtcbiAgICBpZiAoZW52ZWxvcGUudHlwZSA9PT0gJ3NlY3AyNTZrMScpIHtcbiAgICAgICAgaWYgKCFhZGRyZXNzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gb3hfU2VjcDI1NmsxLnZlcmlmeSh7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZW52ZWxvcGUuc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudmVsb3BlLnR5cGUgPT09ICdwMjU2Jykge1xuICAgICAgICBjb25zdCBlbnZlbG9wZUFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkoZW52ZWxvcGUucHVibGljS2V5KTtcbiAgICAgICAgaWYgKCFBZGRyZXNzLmlzRXF1YWwoZW52ZWxvcGVBZGRyZXNzLCBhZGRyZXNzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG94X1AyNTYudmVyaWZ5KHtcbiAgICAgICAgICAgIGhhc2g6IGVudmVsb3BlLnByZWhhc2gsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IGVudmVsb3BlLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGVudmVsb3BlLnNpZ25hdHVyZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnZlbG9wZS50eXBlID09PSAnd2ViQXV0aG4nKSB7XG4gICAgICAgIGNvbnN0IGVudmVsb3BlQWRkcmVzcyA9IEFkZHJlc3MuZnJvbVB1YmxpY0tleShlbnZlbG9wZS5wdWJsaWNLZXkpO1xuICAgICAgICBpZiAoIUFkZHJlc3MuaXNFcXVhbChlbnZlbG9wZUFkZHJlc3MsIGFkZHJlc3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gb3hfV2ViQXV0aG5QMjU2LnZlcmlmeSh7XG4gICAgICAgICAgICBjaGFsbGVuZ2U6IEhleC5mcm9tKHBheWxvYWQpLFxuICAgICAgICAgICAgbWV0YWRhdGE6IGVudmVsb3BlLm1ldGFkYXRhLFxuICAgICAgICAgICAgcHVibGljS2V5OiBlbnZlbG9wZS5wdWJsaWNLZXksXG4gICAgICAgICAgICBzaWduYXR1cmU6IGVudmVsb3BlLnNpZ25hdHVyZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBWZXJpZmljYXRpb25FcnJvcihgVW5hYmxlIHRvIHZlcmlmeSBzaWduYXR1cmUgZW52ZWxvcGUgb2YgdHlwZSBcIiR7ZW52ZWxvcGUudHlwZX1cIi5gKTtcbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gYSBzaWduYXR1cmUgZW52ZWxvcGUgY2Fubm90IGJlIGNvZXJjZWQgdG8gYSB2YWxpZCB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgQ29lcmNpb25FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZW52ZWxvcGUgfSkge1xuICAgICAgICBzdXBlcihgVW5hYmxlIHRvIGNvZXJjZSB2YWx1ZSAoXFxgJHtKc29uLnN0cmluZ2lmeShlbnZlbG9wZSl9XFxgKSB0byBhIHZhbGlkIHNpZ25hdHVyZSBlbnZlbG9wZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZUVudmVsb3BlLkNvZXJjaW9uRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gYSBzaWduYXR1cmUgZW52ZWxvcGUgaXMgbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgY2xhc3MgTWlzc2luZ1Byb3BlcnRpZXNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZW52ZWxvcGUsIG1pc3NpbmcsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpZ25hdHVyZSBlbnZlbG9wZSBvZiB0eXBlIFwiJHt0eXBlfVwiIGlzIG1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydGllczogJHttaXNzaW5nLm1hcCgobSkgPT4gYFxcYCR7bX1cXGBgKS5qb2luKCcsICcpfS5cXG5cXG5Qcm92aWRlZDogJHtKc29uLnN0cmluZ2lmeShlbnZlbG9wZSl9YCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmVFbnZlbG9wZS5NaXNzaW5nUHJvcGVydGllc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGEgc2VyaWFsaXplZCBzaWduYXR1cmUgZW52ZWxvcGUgY2Fubm90IGJlIGRlc2VyaWFsaXplZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHJlYXNvbiwgc2VyaWFsaXplZCwgfSkge1xuICAgICAgICBzdXBlcihgVW5hYmxlIHRvIGRlc2VyaWFsaXplIHNpZ25hdHVyZSBlbnZlbG9wZTogJHtyZWFzb259YCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbYFNlcmlhbGl6ZWQ6ICR7c2VyaWFsaXplZH1gXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmVFbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGEgc2lnbmF0dXJlIGVudmVsb3BlIGZhaWxzIHRvIHZlcmlmeS5cbiAqL1xuZXhwb3J0IGNsYXNzIFZlcmlmaWNhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmVFbnZlbG9wZS5WZXJpZmljYXRpb25FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2lnbmF0dXJlRW52ZWxvcGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/TokenId.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_esm/tempo/TokenId.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAddress: () => (/* binding */ fromAddress),\n/* harmony export */   toAddress: () => (/* binding */ toAddress)\n/* harmony export */ });\n/* harmony import */ var _core_Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\nconst tip20Prefix = '0x20c0';\n/**\n * Converts a token ID or address to a token ID.\n *\n * TIP-20 is Tempo's native token standard for stablecoins with deterministic addresses\n * derived from sequential token IDs (prefix `0x20c0`).\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const tokenId = TokenId.from(1n)\n * ```\n *\n * @param tokenIdOrAddress - The token ID or address.\n * @returns The token ID.\n */\nfunction from(tokenIdOrAddress) {\n    if (typeof tokenIdOrAddress === 'bigint' ||\n        typeof tokenIdOrAddress === 'number')\n        return BigInt(tokenIdOrAddress);\n    return fromAddress(tokenIdOrAddress);\n}\n/**\n * Converts a TIP-20 token address to a token ID.\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const tokenId = TokenId.fromAddress('0x20c00000000000000000000000000000000000000001')\n * ```\n *\n * @param address - The token address.\n * @returns The token ID.\n */\nfunction fromAddress(address) {\n    if (!address.toLowerCase().startsWith(tip20Prefix))\n        throw new Error('invalid tip20 address.');\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.toBigInt(_core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(address, tip20Prefix.length));\n}\n/**\n * Converts a TIP-20 token ID to an address.\n *\n * [TIP-20 Token Standard](https://docs.tempo.xyz/protocol/tip20/overview)\n *\n * @example\n * ```ts twoslash\n * import { TokenId } from 'ox/tempo'\n *\n * const address = TokenId.toAddress(1n)\n * ```\n *\n * @param tokenId - The token ID.\n * @returns The address.\n */\nfunction toAddress(tokenId) {\n    if (typeof tokenId === 'string') {\n        _core_Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(tokenId);\n        return tokenId;\n    }\n    const tokenIdHex = _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(tokenId, { size: 18 });\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(tip20Prefix, tokenIdHex);\n}\n//# sourceMappingURL=TokenId.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9Ub2tlbklkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThDO0FBQ1I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsV0FBVyxrREFBWSxDQUFDLCtDQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsUUFBUSxvREFBYztBQUN0QjtBQUNBO0FBQ0EsdUJBQXVCLG9EQUFjLFlBQVksVUFBVTtBQUMzRCxXQUFXLGdEQUFVO0FBQ3JCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9fZXNtL3RlbXBvL1Rva2VuSWQuanM/NWY1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4uL2NvcmUvQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vY29yZS9IZXguanMnO1xuY29uc3QgdGlwMjBQcmVmaXggPSAnMHgyMGMwJztcbi8qKlxuICogQ29udmVydHMgYSB0b2tlbiBJRCBvciBhZGRyZXNzIHRvIGEgdG9rZW4gSUQuXG4gKlxuICogVElQLTIwIGlzIFRlbXBvJ3MgbmF0aXZlIHRva2VuIHN0YW5kYXJkIGZvciBzdGFibGVjb2lucyB3aXRoIGRldGVybWluaXN0aWMgYWRkcmVzc2VzXG4gKiBkZXJpdmVkIGZyb20gc2VxdWVudGlhbCB0b2tlbiBJRHMgKHByZWZpeCBgMHgyMGMwYCkuXG4gKlxuICogW1RJUC0yMCBUb2tlbiBTdGFuZGFyZF0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90aXAyMC9vdmVydmlldylcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRva2VuSWQgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCB0b2tlbklkID0gVG9rZW5JZC5mcm9tKDFuKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHRva2VuSWRPckFkZHJlc3MgLSBUaGUgdG9rZW4gSUQgb3IgYWRkcmVzcy5cbiAqIEByZXR1cm5zIFRoZSB0b2tlbiBJRC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odG9rZW5JZE9yQWRkcmVzcykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5JZE9yQWRkcmVzcyA9PT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgdHlwZW9mIHRva2VuSWRPckFkZHJlc3MgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gQmlnSW50KHRva2VuSWRPckFkZHJlc3MpO1xuICAgIHJldHVybiBmcm9tQWRkcmVzcyh0b2tlbklkT3JBZGRyZXNzKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBUSVAtMjAgdG9rZW4gYWRkcmVzcyB0byBhIHRva2VuIElELlxuICpcbiAqIFtUSVAtMjAgVG9rZW4gU3RhbmRhcmRdKGh0dHBzOi8vZG9jcy50ZW1wby54eXovcHJvdG9jb2wvdGlwMjAvb3ZlcnZpZXcpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUb2tlbklkIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgdG9rZW5JZCA9IFRva2VuSWQuZnJvbUFkZHJlc3MoJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFkZHJlc3MgLSBUaGUgdG9rZW4gYWRkcmVzcy5cbiAqIEByZXR1cm5zIFRoZSB0b2tlbiBJRC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBpZiAoIWFkZHJlc3MudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHRpcDIwUHJlZml4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRpcDIwIGFkZHJlc3MuJyk7XG4gICAgcmV0dXJuIEhleC50b0JpZ0ludChIZXguc2xpY2UoYWRkcmVzcywgdGlwMjBQcmVmaXgubGVuZ3RoKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgVElQLTIwIHRva2VuIElEIHRvIGFuIGFkZHJlc3MuXG4gKlxuICogW1RJUC0yMCBUb2tlbiBTdGFuZGFyZF0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90aXAyMC9vdmVydmlldylcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRva2VuSWQgfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBhZGRyZXNzID0gVG9rZW5JZC50b0FkZHJlc3MoMW4pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSB0b2tlbiBJRC5cbiAqIEByZXR1cm5zIFRoZSBhZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9BZGRyZXNzKHRva2VuSWQpIHtcbiAgICBpZiAodHlwZW9mIHRva2VuSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIEFkZHJlc3MuYXNzZXJ0KHRva2VuSWQpO1xuICAgICAgICByZXR1cm4gdG9rZW5JZDtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5JZEhleCA9IEhleC5mcm9tTnVtYmVyKHRva2VuSWQsIHsgc2l6ZTogMTggfSk7XG4gICAgcmV0dXJuIEhleC5jb25jYXQodGlwMjBQcmVmaXgsIHRva2VuSWRIZXgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9rZW5JZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/TokenId.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/Transaction.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/Transaction.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcType: () => (/* binding */ fromRpcType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcType: () => (/* binding */ toRpcType)\n/* harmony export */ });\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _core_Transaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Transaction.js */ \"(ssr)/./node_modules/ox/_esm/core/Transaction.js\");\n/* harmony import */ var _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AuthorizationTempo.js */ \"(ssr)/./node_modules/ox/_esm/tempo/AuthorizationTempo.js\");\n/* harmony import */ var _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./KeyAuthorization.js */ \"(ssr)/./node_modules/ox/_esm/tempo/KeyAuthorization.js\");\n/* harmony import */ var _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SignatureEnvelope.js */ \"(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js\");\n\n\n\n\n\n\n/** Type to RPC Type mapping. */\nconst toRpcType = {\n    ..._core_Transaction_js__WEBPACK_IMPORTED_MODULE_0__.toRpcType,\n    tempo: '0x76',\n};\n/** RPC Type to Type mapping. */\nconst fromRpcType = {\n    ..._core_Transaction_js__WEBPACK_IMPORTED_MODULE_0__.fromRpcType,\n    '0x76': 'tempo',\n};\n/**\n * Converts an {@link ox#Transaction.Rpc} to an {@link ox#Transaction.Transaction}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox/tempo'\n *\n * const transaction = Transaction.fromRpc({\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   nonce: '0x357',\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: '0x12f296f',\n *   calls: [\n *     {\n *       input: '0xdeadbeef',\n *       to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *       value: '0x9b6e64a8ec60000',\n *     },\n *   ],\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n *   transactionIndex: '0x2',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   value: '0x9b6e64a8ec60000',\n *   gas: '0x43f5d',\n *   maxFeePerGas: '0x2ca6ae494',\n *   maxPriorityFeePerGas: '0x41cc3c0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   signature: {\n *     r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *     s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *     type: 'secp256k1',\n *     yParity: '0x0',\n *   },\n *   chainId: '0x1',\n *   accessList: [],\n *   type: '0x76',\n * })\n * ```\n *\n * @param transaction - The RPC transaction to convert.\n * @returns An instantiated {@link ox#Transaction.Transaction}.\n */\nfunction fromRpc(transaction, _options = {}) {\n    if (!transaction)\n        return null;\n    const transaction_ = _core_Transaction_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc(transaction);\n    transaction_.type = fromRpcType[transaction.type];\n    if (transaction.aaAuthorizationList) {\n        transaction_.authorizationList = _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_1__.fromRpcList(transaction.aaAuthorizationList);\n        delete transaction_.aaAuthorizationList;\n    }\n    if (transaction.calls)\n        transaction_.calls = transaction.calls.map((call) => ({\n            to: call.to,\n            value: call.value && call.value !== '0x' ? BigInt(call.value) : undefined,\n            // @ts-expect-error\n            data: call.input || call.data || '0x',\n        }));\n    if (transaction.feeToken)\n        transaction_.feeToken = transaction.feeToken;\n    if (transaction.nonceKey)\n        transaction_.nonceKey = BigInt(transaction.nonceKey);\n    if (transaction.signature)\n        transaction_.signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_2__.fromRpc(transaction.signature);\n    if (transaction.validAfter)\n        transaction_.validAfter = Number(transaction.validAfter);\n    if (transaction.validBefore)\n        transaction_.validBefore = Number(transaction.validBefore);\n    if (transaction.keyAuthorization)\n        transaction_.keyAuthorization = _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_3__.fromRpc(transaction.keyAuthorization);\n    if (transaction.feePayerSignature) {\n        transaction_.feePayerSignature = _core_Signature_js__WEBPACK_IMPORTED_MODULE_4__.fromRpc(transaction.feePayerSignature);\n        transaction_.feePayerSignature.v = _core_Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(transaction_.feePayerSignature.yParity);\n    }\n    return transaction_;\n}\n/**\n * Converts an {@link ox#Transaction.Transaction} to an {@link ox#Transaction.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Transaction } from 'ox/tempo'\n *\n * const transaction = Transaction.toRpc({\n *   accessList: [],\n *   blockHash:\n *     '0xc350d807505fb835650f0013632c5515592987ba169bbc6626d9fc54d91f0f0b',\n *   blockNumber: 19868015n,\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x3fc91a3afd70395cd496c647d5a6cc9d4b2b7fad',\n *       value: 700000000000000000n,\n *     },\n *   ],\n *   chainId: 1,\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n *   from: '0x814e5e0e31016b9a7f138c76b7e7b2bb5c1ab6a6',\n *   gas: 278365n,\n *   hash: '0x353fdfc38a2f26115daadee9f5b8392ce62b84f410957967e2ed56b35338cdd0',\n *   input:\n *     '0x3593564c000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000006643504700000000000000000000000000000000000000000000000000000000000000040b080604000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec600000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000009b6e64a8ec60000000000000000000000000000000000000000000000000000019124bb5ae978c000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b80000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b8000000000000000000000000000000fee13a103a10d593b9ae06b3e05f2e7e1c00000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000060000000000000000000000000c56c7a0eaa804f854b536a5f3d5f49d2ec4b12b800000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000190240001b9872b',\n *   maxFeePerGas: 11985937556n,\n *   maxPriorityFeePerGas: 68993984n,\n *   nonce: 855n,\n *   signature: {\n *     signature: {\n *       r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *       s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *       yParity: 0,\n *     },\n *     type: 'secp256k1',\n *   },\n *   transactionIndex: 2,\n *   type: 'tempo',\n * })\n * ```\n *\n * @param transaction - The transaction to convert.\n * @returns An RPC-formatted transaction.\n */\nfunction toRpc(transaction, _options) {\n    const rpc = _core_Transaction_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(transaction);\n    rpc.type = toRpcType[transaction.type];\n    if (transaction.authorizationList)\n        rpc.aaAuthorizationList = _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_1__.toRpcList(transaction.authorizationList);\n    if (transaction.calls)\n        rpc.calls = transaction.calls.map((call) => ({\n            to: call.to,\n            value: call.value ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_5__.fromNumber(call.value) : undefined,\n            data: call.data,\n        }));\n    if (transaction.feeToken)\n        rpc.feeToken = transaction.feeToken;\n    if (transaction.keyAuthorization)\n        rpc.keyAuthorization = _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_3__.toRpc(transaction.keyAuthorization);\n    if (transaction.feePayerSignature) {\n        rpc.feePayerSignature = _core_Signature_js__WEBPACK_IMPORTED_MODULE_4__.toRpc(transaction.feePayerSignature);\n        rpc.feePayerSignature.v = _core_Hex_js__WEBPACK_IMPORTED_MODULE_5__.fromNumber(_core_Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(transaction.feePayerSignature?.yParity));\n    }\n    if (transaction.signature)\n        rpc.signature = _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_2__.toRpc(transaction.signature);\n    if (typeof transaction.validAfter === 'number')\n        rpc.validAfter = _core_Hex_js__WEBPACK_IMPORTED_MODULE_5__.fromNumber(transaction.validAfter);\n    if (typeof transaction.validBefore === 'number')\n        rpc.validBefore = _core_Hex_js__WEBPACK_IMPORTED_MODULE_5__.fromNumber(transaction.validBefore);\n    return rpc;\n}\n//# sourceMappingURL=Transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UcmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ1k7QUFDTztBQUNLO0FBQ0o7QUFDRTtBQUM1RDtBQUNPO0FBQ1AsT0FBTywyREFBd0I7QUFDL0I7QUFDQTtBQUNBO0FBQ087QUFDUCxPQUFPLDZEQUEwQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCLE9BQU8saUNBQWlDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUNBQWlDO0FBQzlEO0FBQ08sMkNBQTJDO0FBQ2xEO0FBQ0E7QUFDQSx5QkFBeUIseURBQXNCO0FBQy9DO0FBQ0E7QUFDQSx5Q0FBeUMsK0RBQThCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwREFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5REFBd0I7QUFDaEU7QUFDQSx5Q0FBeUMsdURBQWlCO0FBQzFELDJDQUEyQywwREFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLE9BQU8seUJBQXlCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCLHVEQUFvQjtBQUNwQztBQUNBO0FBQ0Esa0NBQWtDLDZEQUE0QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQWM7QUFDOUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVEQUFzQjtBQUNyRDtBQUNBLGdDQUFnQyxxREFBZTtBQUMvQyxrQ0FBa0Msb0RBQWMsQ0FBQywwREFBb0I7QUFDckU7QUFDQTtBQUNBLHdCQUF3Qix3REFBdUI7QUFDL0M7QUFDQSx5QkFBeUIsb0RBQWM7QUFDdkM7QUFDQSwwQkFBMEIsb0RBQWM7QUFDeEM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UcmFuc2FjdGlvbi5qcz9iYzEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9jb3JlL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi4vY29yZS9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgb3hfVHJhbnNhY3Rpb24gZnJvbSAnLi4vY29yZS9UcmFuc2FjdGlvbi5qcyc7XG5pbXBvcnQgKiBhcyBBdXRob3JpemF0aW9uVGVtcG8gZnJvbSAnLi9BdXRob3JpemF0aW9uVGVtcG8uanMnO1xuaW1wb3J0ICogYXMgS2V5QXV0aG9yaXphdGlvbiBmcm9tICcuL0tleUF1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlRW52ZWxvcGUgZnJvbSAnLi9TaWduYXR1cmVFbnZlbG9wZS5qcyc7XG4vKiogVHlwZSB0byBSUEMgVHlwZSBtYXBwaW5nLiAqL1xuZXhwb3J0IGNvbnN0IHRvUnBjVHlwZSA9IHtcbiAgICAuLi5veF9UcmFuc2FjdGlvbi50b1JwY1R5cGUsXG4gICAgdGVtcG86ICcweDc2Jyxcbn07XG4vKiogUlBDIFR5cGUgdG8gVHlwZSBtYXBwaW5nLiAqL1xuZXhwb3J0IGNvbnN0IGZyb21ScGNUeXBlID0ge1xuICAgIC4uLm94X1RyYW5zYWN0aW9uLmZyb21ScGNUeXBlLFxuICAgICcweDc2JzogJ3RlbXBvJyxcbn07XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbi5ScGN9IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbi5UcmFuc2FjdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb24uZnJvbVJwYyh7XG4gKiAgIGhhc2g6ICcweDM1M2ZkZmMzOGEyZjI2MTE1ZGFhZGVlOWY1YjgzOTJjZTYyYjg0ZjQxMDk1Nzk2N2UyZWQ1NmIzNTMzOGNkZDAnLFxuICogICBub25jZTogJzB4MzU3JyxcbiAqICAgYmxvY2tIYXNoOlxuICogICAgICcweGMzNTBkODA3NTA1ZmI4MzU2NTBmMDAxMzYzMmM1NTE1NTkyOTg3YmExNjliYmM2NjI2ZDlmYzU0ZDkxZjBmMGInLFxuICogICBibG9ja051bWJlcjogJzB4MTJmMjk2ZicsXG4gKiAgIGNhbGxzOiBbXG4gKiAgICAge1xuICogICAgICAgaW5wdXQ6ICcweGRlYWRiZWVmJyxcbiAqICAgICAgIHRvOiAnMHgzZmM5MWEzYWZkNzAzOTVjZDQ5NmM2NDdkNWE2Y2M5ZDRiMmI3ZmFkJyxcbiAqICAgICAgIHZhbHVlOiAnMHg5YjZlNjRhOGVjNjAwMDAnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIGZlZVRva2VuOiAnMHgyMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdHJhbnNhY3Rpb25JbmRleDogJzB4MicsXG4gKiAgIGZyb206ICcweDgxNGU1ZTBlMzEwMTZiOWE3ZjEzOGM3NmI3ZTdiMmJiNWMxYWI2YTYnLFxuICogICB2YWx1ZTogJzB4OWI2ZTY0YThlYzYwMDAwJyxcbiAqICAgZ2FzOiAnMHg0M2Y1ZCcsXG4gKiAgIG1heEZlZVBlckdhczogJzB4MmNhNmFlNDk0JyxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6ICcweDQxY2MzYzAnLFxuICogICBpbnB1dDpcbiAqICAgICAnMHgzNTkzNTY0YzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NjQzNTA0NzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwYjA4MDYwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkxMjRiYjVhZTk3OGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzAyYWFhMzliMjIzZmU4ZDBhMGU1YzRmMjdlYWQ5MDgzYzc1NmNjMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZlZTEzYTEwM2ExMGQ1OTNiOWFlMDZiM2UwNWYyZTdlMWMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDI0MDAwMWI5ODcyYicsXG4gKiAgIHNpZ25hdHVyZToge1xuICogICAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICAgIHM6ICcweDUwYzI2NjdhYzRjNzcxMDcyNzQ2YWNmZGNmMWYxNDgzMzM2ZGNjYThiZDJkZjQ3Y2Q4MzE3NWRiZTYwZjA1NDAnLFxuICogICAgIHR5cGU6ICdzZWNwMjU2azEnLFxuICogICAgIHlQYXJpdHk6ICcweDAnLFxuICogICB9LFxuICogICBjaGFpbklkOiAnMHgxJyxcbiAqICAgYWNjZXNzTGlzdDogW10sXG4gKiAgIHR5cGU6ICcweDc2JyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgUlBDIHRyYW5zYWN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1RyYW5zYWN0aW9uLlRyYW5zYWN0aW9ufS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGModHJhbnNhY3Rpb24sIF9vcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB0cmFuc2FjdGlvbl8gPSBveF9UcmFuc2FjdGlvbi5mcm9tUnBjKHRyYW5zYWN0aW9uKTtcbiAgICB0cmFuc2FjdGlvbl8udHlwZSA9IGZyb21ScGNUeXBlW3RyYW5zYWN0aW9uLnR5cGVdO1xuICAgIGlmICh0cmFuc2FjdGlvbi5hYUF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgICAgIHRyYW5zYWN0aW9uXy5hdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb25UZW1wby5mcm9tUnBjTGlzdCh0cmFuc2FjdGlvbi5hYUF1dGhvcml6YXRpb25MaXN0KTtcbiAgICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uXy5hYUF1dGhvcml6YXRpb25MaXN0O1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24uY2FsbHMpXG4gICAgICAgIHRyYW5zYWN0aW9uXy5jYWxscyA9IHRyYW5zYWN0aW9uLmNhbGxzLm1hcCgoY2FsbCkgPT4gKHtcbiAgICAgICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICAgICAgdmFsdWU6IGNhbGwudmFsdWUgJiYgY2FsbC52YWx1ZSAhPT0gJzB4JyA/IEJpZ0ludChjYWxsLnZhbHVlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGRhdGE6IGNhbGwuaW5wdXQgfHwgY2FsbC5kYXRhIHx8ICcweCcsXG4gICAgICAgIH0pKTtcbiAgICBpZiAodHJhbnNhY3Rpb24uZmVlVG9rZW4pXG4gICAgICAgIHRyYW5zYWN0aW9uXy5mZWVUb2tlbiA9IHRyYW5zYWN0aW9uLmZlZVRva2VuO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUtleSlcbiAgICAgICAgdHJhbnNhY3Rpb25fLm5vbmNlS2V5ID0gQmlnSW50KHRyYW5zYWN0aW9uLm5vbmNlS2V5KTtcbiAgICBpZiAodHJhbnNhY3Rpb24uc2lnbmF0dXJlKVxuICAgICAgICB0cmFuc2FjdGlvbl8uc2lnbmF0dXJlID0gU2lnbmF0dXJlRW52ZWxvcGUuZnJvbVJwYyh0cmFuc2FjdGlvbi5zaWduYXR1cmUpO1xuICAgIGlmICh0cmFuc2FjdGlvbi52YWxpZEFmdGVyKVxuICAgICAgICB0cmFuc2FjdGlvbl8udmFsaWRBZnRlciA9IE51bWJlcih0cmFuc2FjdGlvbi52YWxpZEFmdGVyKTtcbiAgICBpZiAodHJhbnNhY3Rpb24udmFsaWRCZWZvcmUpXG4gICAgICAgIHRyYW5zYWN0aW9uXy52YWxpZEJlZm9yZSA9IE51bWJlcih0cmFuc2FjdGlvbi52YWxpZEJlZm9yZSk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmtleUF1dGhvcml6YXRpb24pXG4gICAgICAgIHRyYW5zYWN0aW9uXy5rZXlBdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi5mcm9tUnBjKHRyYW5zYWN0aW9uLmtleUF1dGhvcml6YXRpb24pO1xuICAgIGlmICh0cmFuc2FjdGlvbi5mZWVQYXllclNpZ25hdHVyZSkge1xuICAgICAgICB0cmFuc2FjdGlvbl8uZmVlUGF5ZXJTaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbVJwYyh0cmFuc2FjdGlvbi5mZWVQYXllclNpZ25hdHVyZSk7XG4gICAgICAgIHRyYW5zYWN0aW9uXy5mZWVQYXllclNpZ25hdHVyZS52ID0gU2lnbmF0dXJlLnlQYXJpdHlUb1YodHJhbnNhY3Rpb25fLmZlZVBheWVyU2lnbmF0dXJlLnlQYXJpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNhY3Rpb25fO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb24uVHJhbnNhY3Rpb259IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbi5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCB0cmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uLnRvUnBjKHtcbiAqICAgYWNjZXNzTGlzdDogW10sXG4gKiAgIGJsb2NrSGFzaDpcbiAqICAgICAnMHhjMzUwZDgwNzUwNWZiODM1NjUwZjAwMTM2MzJjNTUxNTU5Mjk4N2JhMTY5YmJjNjYyNmQ5ZmM1NGQ5MWYwZjBiJyxcbiAqICAgYmxvY2tOdW1iZXI6IDE5ODY4MDE1bixcbiAqICAgY2FsbHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgICB0bzogJzB4M2ZjOTFhM2FmZDcwMzk1Y2Q0OTZjNjQ3ZDVhNmNjOWQ0YjJiN2ZhZCcsXG4gKiAgICAgICB2YWx1ZTogNzAwMDAwMDAwMDAwMDAwMDAwbixcbiAqICAgICB9LFxuICogICBdLFxuICogICBjaGFpbklkOiAxLFxuICogICBmZWVUb2tlbjogJzB4MjBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGZyb206ICcweDgxNGU1ZTBlMzEwMTZiOWE3ZjEzOGM3NmI3ZTdiMmJiNWMxYWI2YTYnLFxuICogICBnYXM6IDI3ODM2NW4sXG4gKiAgIGhhc2g6ICcweDM1M2ZkZmMzOGEyZjI2MTE1ZGFhZGVlOWY1YjgzOTJjZTYyYjg0ZjQxMDk1Nzk2N2UyZWQ1NmIzNTMzOGNkZDAnLFxuICogICBpbnB1dDpcbiAqICAgICAnMHgzNTkzNTY0YzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NjQzNTA0NzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwYjA4MDYwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5YjZlNjRhOGVjNjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTkxMjRiYjVhZTk3OGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzAyYWFhMzliMjIzZmU4ZDBhMGU1YzRmMjdlYWQ5MDgzYzc1NmNjMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYzU2YzdhMGVhYTgwNGY4NTRiNTM2YTVmM2Q1ZjQ5ZDJlYzRiMTJiODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZlZTEzYTEwM2ExMGQ1OTNiOWFlMDZiM2UwNWYyZTdlMWMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGM1NmM3YTBlYWE4MDRmODU0YjUzNmE1ZjNkNWY0OWQyZWM0YjEyYjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE5MDI0MDAwMWI5ODcyYicsXG4gKiAgIG1heEZlZVBlckdhczogMTE5ODU5Mzc1NTZuLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogNjg5OTM5ODRuLFxuICogICBub25jZTogODU1bixcbiAqICAgc2lnbmF0dXJlOiB7XG4gKiAgICAgc2lnbmF0dXJlOiB7XG4gKiAgICAgICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgICAgICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgICAgICB5UGFyaXR5OiAwLFxuICogICAgIH0sXG4gKiAgICAgdHlwZTogJ3NlY3AyNTZrMScsXG4gKiAgIH0sXG4gKiAgIHRyYW5zYWN0aW9uSW5kZXg6IDIsXG4gKiAgIHR5cGU6ICd0ZW1wbycsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIHRyYW5zYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGModHJhbnNhY3Rpb24sIF9vcHRpb25zKSB7XG4gICAgY29uc3QgcnBjID0gb3hfVHJhbnNhY3Rpb24udG9ScGModHJhbnNhY3Rpb24pO1xuICAgIHJwYy50eXBlID0gdG9ScGNUeXBlW3RyYW5zYWN0aW9uLnR5cGVdO1xuICAgIGlmICh0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdClcbiAgICAgICAgcnBjLmFhQXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uVGVtcG8udG9ScGNMaXN0KHRyYW5zYWN0aW9uLmF1dGhvcml6YXRpb25MaXN0KTtcbiAgICBpZiAodHJhbnNhY3Rpb24uY2FsbHMpXG4gICAgICAgIHJwYy5jYWxscyA9IHRyYW5zYWN0aW9uLmNhbGxzLm1hcCgoY2FsbCkgPT4gKHtcbiAgICAgICAgICAgIHRvOiBjYWxsLnRvLFxuICAgICAgICAgICAgdmFsdWU6IGNhbGwudmFsdWUgPyBIZXguZnJvbU51bWJlcihjYWxsLnZhbHVlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRhdGE6IGNhbGwuZGF0YSxcbiAgICAgICAgfSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5mZWVUb2tlbilcbiAgICAgICAgcnBjLmZlZVRva2VuID0gdHJhbnNhY3Rpb24uZmVlVG9rZW47XG4gICAgaWYgKHRyYW5zYWN0aW9uLmtleUF1dGhvcml6YXRpb24pXG4gICAgICAgIHJwYy5rZXlBdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi50b1JwYyh0cmFuc2FjdGlvbi5rZXlBdXRob3JpemF0aW9uKTtcbiAgICBpZiAodHJhbnNhY3Rpb24uZmVlUGF5ZXJTaWduYXR1cmUpIHtcbiAgICAgICAgcnBjLmZlZVBheWVyU2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvUnBjKHRyYW5zYWN0aW9uLmZlZVBheWVyU2lnbmF0dXJlKTtcbiAgICAgICAgcnBjLmZlZVBheWVyU2lnbmF0dXJlLnYgPSBIZXguZnJvbU51bWJlcihTaWduYXR1cmUueVBhcml0eVRvVih0cmFuc2FjdGlvbi5mZWVQYXllclNpZ25hdHVyZT8ueVBhcml0eSkpO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24uc2lnbmF0dXJlKVxuICAgICAgICBycGMuc2lnbmF0dXJlID0gU2lnbmF0dXJlRW52ZWxvcGUudG9ScGModHJhbnNhY3Rpb24uc2lnbmF0dXJlKTtcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLnZhbGlkQWZ0ZXIgPT09ICdudW1iZXInKVxuICAgICAgICBycGMudmFsaWRBZnRlciA9IEhleC5mcm9tTnVtYmVyKHRyYW5zYWN0aW9uLnZhbGlkQWZ0ZXIpO1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24udmFsaWRCZWZvcmUgPT09ICdudW1iZXInKVxuICAgICAgICBycGMudmFsaWRCZWZvcmUgPSBIZXguZnJvbU51bWJlcih0cmFuc2FjdGlvbi52YWxpZEJlZm9yZSk7XG4gICAgcmV0dXJuIHJwYztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/Transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/TransactionRequest.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/TransactionRequest.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_TransactionRequest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/TransactionRequest.js */ \"(ssr)/./node_modules/ox/_esm/core/TransactionRequest.js\");\n/* harmony import */ var _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AuthorizationTempo.js */ \"(ssr)/./node_modules/ox/_esm/tempo/AuthorizationTempo.js\");\n/* harmony import */ var _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./KeyAuthorization.js */ \"(ssr)/./node_modules/ox/_esm/tempo/KeyAuthorization.js\");\n/* harmony import */ var _TokenId_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TokenId.js */ \"(ssr)/./node_modules/ox/_esm/tempo/TokenId.js\");\n/* harmony import */ var _Transaction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Transaction.js */ \"(ssr)/./node_modules/ox/_esm/tempo/Transaction.js\");\n\n\n\n\n\n\n/**\n * Converts a {@link ox#TransactionRequest.TransactionRequest} to a {@link ox#TransactionRequest.Rpc}.\n *\n * @see {@link https://docs.tempo.xyz/protocol/transactions Tempo Transactions}\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { TransactionRequest } from 'ox/tempo'\n *\n * const request = TransactionRequest.toRpc({\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0xcafebabecafebabecafebabecafebabecafebabe',\n *   }],\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n * })\n * ```\n *\n * @example\n * ### Using with a Provider\n *\n * You can use {@link ox#Provider.(from:function)} to instantiate an EIP-1193 Provider and\n * send a transaction to the Wallet using the `eth_sendTransaction` method.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider, Value } from 'ox'\n * import { TransactionRequest } from 'ox/tempo'\n *\n * const provider = Provider.from(window.ethereum!)\n *\n * const request = TransactionRequest.toRpc({\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0xcafebabecafebabecafebabecafebabecafebabe',\n *   }],\n *   feeToken: '0x20c0000000000000000000000000000000000000',\n * })\n *\n * const hash = await provider.request({ // [!code focus]\n *   method: 'eth_sendTransaction', // [!code focus]\n *   params: [request], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param request - The request to convert.\n * @returns An RPC request.\n */\nfunction toRpc(request) {\n    const request_rpc = _core_TransactionRequest_js__WEBPACK_IMPORTED_MODULE_0__.toRpc({\n        ...request,\n        authorizationList: undefined,\n    });\n    if (request.authorizationList)\n        request_rpc.authorizationList = _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_1__.toRpcList(request.authorizationList);\n    if (request.calls)\n        request_rpc.calls = request.calls.map((call) => ({\n            to: call.to,\n            value: call.value ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(call.value) : '0x',\n            data: call.data ?? '0x',\n        }));\n    if (typeof request.feeToken !== 'undefined')\n        request_rpc.feeToken = _TokenId_js__WEBPACK_IMPORTED_MODULE_3__.toAddress(request.feeToken);\n    if (request.keyAuthorization)\n        request_rpc.keyAuthorization = _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_4__.toRpc(request.keyAuthorization);\n    if (typeof request.validBefore !== 'undefined')\n        request_rpc.validBefore = _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(request.validBefore);\n    if (typeof request.validAfter !== 'undefined')\n        request_rpc.validAfter = _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(request.validAfter);\n    const nonceKey = (() => {\n        if (request.nonceKey === 'random')\n            return _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.random(6);\n        if (typeof request.nonceKey === 'bigint')\n            return _core_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(request.nonceKey);\n        return undefined;\n    })();\n    if (nonceKey)\n        request_rpc.nonceKey = nonceKey;\n    if (typeof request.calls !== 'undefined' ||\n        typeof request.feeToken !== 'undefined' ||\n        typeof request.keyAuthorization !== 'undefined' ||\n        typeof request.nonceKey !== 'undefined' ||\n        typeof request.validBefore !== 'undefined' ||\n        typeof request.validAfter !== 'undefined' ||\n        request.type === 'tempo') {\n        request_rpc.type = _Transaction_js__WEBPACK_IMPORTED_MODULE_5__.toRpcType.tempo;\n        delete request_rpc.data;\n        delete request_rpc.input;\n        delete request_rpc.to;\n        delete request_rpc.value;\n    }\n    return request_rpc;\n}\n//# sourceMappingURL=TransactionRequest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UcmFuc2FjdGlvblJlcXVlc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzQztBQUNpQztBQUNUO0FBQ0o7QUFDbEI7QUFDUTtBQUNoRDtBQUNBLGVBQWUsZ0RBQWdELE1BQU0sZ0NBQWdDO0FBQ3JHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUNBQW1DO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx3QkFBd0IsOERBQTJCO0FBQ25EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0MsNkRBQTRCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxvREFBYztBQUM5QztBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQixrREFBaUI7QUFDaEQ7QUFDQSx1Q0FBdUMsdURBQXNCO0FBQzdEO0FBQ0Esa0NBQWtDLG9EQUFjO0FBQ2hEO0FBQ0EsaUNBQWlDLG9EQUFjO0FBQy9DO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQVU7QUFDN0I7QUFDQSxtQkFBbUIsb0RBQWM7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNEQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UcmFuc2FjdGlvblJlcXVlc3QuanM/YWY1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vY29yZS9IZXguanMnO1xuaW1wb3J0ICogYXMgb3hfVHJhbnNhY3Rpb25SZXF1ZXN0IGZyb20gJy4uL2NvcmUvVHJhbnNhY3Rpb25SZXF1ZXN0LmpzJztcbmltcG9ydCAqIGFzIEF1dGhvcml6YXRpb25UZW1wbyBmcm9tICcuL0F1dGhvcml6YXRpb25UZW1wby5qcyc7XG5pbXBvcnQgKiBhcyBLZXlBdXRob3JpemF0aW9uIGZyb20gJy4vS2V5QXV0aG9yaXphdGlvbi5qcyc7XG5pbXBvcnQgKiBhcyBUb2tlbklkIGZyb20gJy4vVG9rZW5JZC5qcyc7XG5pbXBvcnQgKiBhcyBUcmFuc2FjdGlvbiBmcm9tICcuL1RyYW5zYWN0aW9uLmpzJztcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25SZXF1ZXN0LlRyYW5zYWN0aW9uUmVxdWVzdH0gdG8gYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25SZXF1ZXN0LlJwY30uXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMgVGVtcG8gVHJhbnNhY3Rpb25zfVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uUmVxdWVzdCB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHJlcXVlc3QgPSBUcmFuc2FjdGlvblJlcXVlc3QudG9ScGMoe1xuICogICBjYWxsczogW3tcbiAqICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgdG86ICcweGNhZmViYWJlY2FmZWJhYmVjYWZlYmFiZWNhZmViYWJlY2FmZWJhYmUnLFxuICogICB9XSxcbiAqICAgZmVlVG9rZW46ICcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgVXNpbmcgd2l0aCBhIFByb3ZpZGVyXG4gKlxuICogWW91IGNhbiB1c2Uge0BsaW5rIG94I1Byb3ZpZGVyLihmcm9tOmZ1bmN0aW9uKX0gdG8gaW5zdGFudGlhdGUgYW4gRUlQLTExOTMgUHJvdmlkZXIgYW5kXG4gKiBzZW5kIGEgdHJhbnNhY3Rpb24gdG8gdGhlIFdhbGxldCB1c2luZyB0aGUgYGV0aF9zZW5kVHJhbnNhY3Rpb25gIG1ldGhvZC5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0ICdveC93aW5kb3cnXG4gKiBpbXBvcnQgeyBQcm92aWRlciwgVmFsdWUgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uUmVxdWVzdCB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IHByb3ZpZGVyID0gUHJvdmlkZXIuZnJvbSh3aW5kb3cuZXRoZXJldW0hKVxuICpcbiAqIGNvbnN0IHJlcXVlc3QgPSBUcmFuc2FjdGlvblJlcXVlc3QudG9ScGMoe1xuICogICBjYWxsczogW3tcbiAqICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgdG86ICcweGNhZmViYWJlY2FmZWJhYmVjYWZlYmFiZWNhZmViYWJlY2FmZWJhYmUnLFxuICogICB9XSxcbiAqICAgZmVlVG9rZW46ICcweDIwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gYXdhaXQgcHJvdmlkZXIucmVxdWVzdCh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgbWV0aG9kOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsIC8vIFshY29kZSBmb2N1c11cbiAqICAgcGFyYW1zOiBbcmVxdWVzdF0sIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3QgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQyByZXF1ZXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlcXVlc3RfcnBjID0gb3hfVHJhbnNhY3Rpb25SZXF1ZXN0LnRvUnBjKHtcbiAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3Q6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgICBpZiAocmVxdWVzdC5hdXRob3JpemF0aW9uTGlzdClcbiAgICAgICAgcmVxdWVzdF9ycGMuYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uVGVtcG8udG9ScGNMaXN0KHJlcXVlc3QuYXV0aG9yaXphdGlvbkxpc3QpO1xuICAgIGlmIChyZXF1ZXN0LmNhbGxzKVxuICAgICAgICByZXF1ZXN0X3JwYy5jYWxscyA9IHJlcXVlc3QuY2FsbHMubWFwKChjYWxsKSA9PiAoe1xuICAgICAgICAgICAgdG86IGNhbGwudG8sXG4gICAgICAgICAgICB2YWx1ZTogY2FsbC52YWx1ZSA/IEhleC5mcm9tTnVtYmVyKGNhbGwudmFsdWUpIDogJzB4JyxcbiAgICAgICAgICAgIGRhdGE6IGNhbGwuZGF0YSA/PyAnMHgnLFxuICAgICAgICB9KSk7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmZlZVRva2VuICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmVxdWVzdF9ycGMuZmVlVG9rZW4gPSBUb2tlbklkLnRvQWRkcmVzcyhyZXF1ZXN0LmZlZVRva2VuKTtcbiAgICBpZiAocmVxdWVzdC5rZXlBdXRob3JpemF0aW9uKVxuICAgICAgICByZXF1ZXN0X3JwYy5rZXlBdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi50b1JwYyhyZXF1ZXN0LmtleUF1dGhvcml6YXRpb24pO1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC52YWxpZEJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJlcXVlc3RfcnBjLnZhbGlkQmVmb3JlID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC52YWxpZEJlZm9yZSk7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LnZhbGlkQWZ0ZXIgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXF1ZXN0X3JwYy52YWxpZEFmdGVyID0gSGV4LmZyb21OdW1iZXIocmVxdWVzdC52YWxpZEFmdGVyKTtcbiAgICBjb25zdCBub25jZUtleSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChyZXF1ZXN0Lm5vbmNlS2V5ID09PSAncmFuZG9tJylcbiAgICAgICAgICAgIHJldHVybiBIZXgucmFuZG9tKDYpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3Qubm9uY2VLZXkgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIEhleC5mcm9tTnVtYmVyKHJlcXVlc3Qubm9uY2VLZXkpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pKCk7XG4gICAgaWYgKG5vbmNlS2V5KVxuICAgICAgICByZXF1ZXN0X3JwYy5ub25jZUtleSA9IG5vbmNlS2V5O1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5jYWxscyAhPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIHJlcXVlc3QuZmVlVG9rZW4gIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiByZXF1ZXN0LmtleUF1dGhvcml6YXRpb24gIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiByZXF1ZXN0Lm5vbmNlS2V5ICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2YgcmVxdWVzdC52YWxpZEJlZm9yZSAhPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgdHlwZW9mIHJlcXVlc3QudmFsaWRBZnRlciAhPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgcmVxdWVzdC50eXBlID09PSAndGVtcG8nKSB7XG4gICAgICAgIHJlcXVlc3RfcnBjLnR5cGUgPSBUcmFuc2FjdGlvbi50b1JwY1R5cGUudGVtcG87XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0X3JwYy5kYXRhO1xuICAgICAgICBkZWxldGUgcmVxdWVzdF9ycGMuaW5wdXQ7XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0X3JwYy50bztcbiAgICAgICAgZGVsZXRlIHJlcXVlc3RfcnBjLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdF9ycGM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvblJlcXVlc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/TransactionRequest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/tempo/TxEnvelopeTempo.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_esm/tempo/TxEnvelopeTempo.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CallsEmptyError: () => (/* binding */ CallsEmptyError),\n/* harmony export */   InvalidValidityWindowError: () => (/* binding */ InvalidValidityWindowError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   feePayerMagic: () => (/* binding */ feePayerMagic),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getFeePayerSignPayload: () => (/* binding */ getFeePayerSignPayload),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializedType: () => (/* binding */ serializedType),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _core_AccessList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/AccessList.js */ \"(ssr)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _core_Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Address.js */ \"(ssr)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _core_Errors_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../core/Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _core_Hash_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../core/Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _core_Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Rlp.js */ \"(ssr)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _core_Signature_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/Signature.js */ \"(ssr)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _core_TxEnvelope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/TxEnvelope.js */ \"(ssr)/./node_modules/ox/_esm/core/TxEnvelope.js\");\n/* harmony import */ var _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AuthorizationTempo.js */ \"(ssr)/./node_modules/ox/_esm/tempo/AuthorizationTempo.js\");\n/* harmony import */ var _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./KeyAuthorization.js */ \"(ssr)/./node_modules/ox/_esm/tempo/KeyAuthorization.js\");\n/* harmony import */ var _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SignatureEnvelope.js */ \"(ssr)/./node_modules/ox/_esm/tempo/SignatureEnvelope.js\");\n/* harmony import */ var _TokenId_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TokenId.js */ \"(ssr)/./node_modules/ox/_esm/tempo/TokenId.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst feePayerMagic = '0x78';\nconst serializedType = '0x76';\nconst type = 'tempo';\n/**\n * Asserts a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [{ to: '0x0000000000000000000000000000000000000000', value: 0n }],\n *   chainId: 1,\n *   maxFeePerGas: 1000000000n,\n * })\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nfunction assert(envelope) {\n    const { calls, chainId, maxFeePerGas, maxPriorityFeePerGas, validBefore, validAfter, } = envelope;\n    // Calls must not be empty\n    if (!calls || calls.length === 0)\n        throw new CallsEmptyError();\n    // validBefore must be greater than validAfter if both are set\n    if (typeof validBefore === 'number' &&\n        typeof validAfter === 'number' &&\n        validBefore <= validAfter) {\n        throw new InvalidValidityWindowError({\n            validBefore: validBefore,\n            validAfter: validAfter,\n        });\n    }\n    // Validate each call\n    if (calls)\n        for (const call of calls)\n            if (call.to)\n                _core_Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(call.to, { strict: false });\n    // Validate chain ID\n    if (chainId <= 0)\n        throw new _core_TxEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidChainIdError({ chainId });\n    // Validate max fee per gas\n    if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)\n        throw new _core_TxEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.FeeCapTooHighError({\n            feeCap: maxFeePerGas,\n        });\n    if (maxPriorityFeePerGas &&\n        maxFeePerGas &&\n        maxPriorityFeePerGas > maxFeePerGas)\n        throw new _core_TxEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.TipAboveFeeCapError({\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n        });\n}\n/**\n * Deserializes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.deserialize('0x76f84a0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0808080')\n * // @log: {\n * // @log:   type: 'tempo',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   calls: [{ to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8', value: 1000000000000000000n }],\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nfunction deserialize(serialized) {\n    const transactionArray = _core_Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.slice(serialized, 1));\n    const [chainId, maxPriorityFeePerGas, maxFeePerGas, gas, calls, accessList, nonceKey, nonce, validBefore, validAfter, feeToken, feePayerSignatureOrSender, authorizationList, keyAuthorizationOrSignature, maybeSignature,] = transactionArray;\n    const keyAuthorization = Array.isArray(keyAuthorizationOrSignature)\n        ? keyAuthorizationOrSignature\n        : undefined;\n    const signature = keyAuthorization\n        ? maybeSignature\n        : keyAuthorizationOrSignature;\n    if (!(transactionArray.length === 13 ||\n        transactionArray.length === 14 ||\n        transactionArray.length === 15))\n        throw new _core_TxEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSerializedError({\n            attributes: {\n                authorizationList,\n                chainId,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                calls,\n                accessList,\n                keyAuthorization,\n                nonceKey,\n                nonce,\n                validBefore,\n                validAfter,\n                feeToken,\n                feePayerSignatureOrSender,\n                ...(transactionArray.length > 12\n                    ? {\n                        signature,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        chainId: Number(chainId),\n        type,\n    };\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce))\n        transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonceKey))\n        transaction.nonceKey = nonceKey === '0x' ? 0n : BigInt(nonceKey);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(validBefore) && validBefore !== '0x')\n        transaction.validBefore = Number(validBefore);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(validAfter) && validAfter !== '0x')\n        transaction.validAfter = Number(validAfter);\n    if (_core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(feeToken) && feeToken !== '0x')\n        transaction.feeToken = feeToken;\n    // Parse calls array\n    if (calls && calls !== '0x') {\n        const callsArray = calls;\n        transaction.calls = callsArray.map((callTuple) => {\n            const [to, value, data] = callTuple;\n            const call = {};\n            if (to && to !== '0x')\n                call.to = to;\n            if (value && value !== '0x')\n                call.value = BigInt(value);\n            if (data && data !== '0x')\n                call.data = data;\n            return call;\n        });\n    }\n    if (accessList?.length !== 0 && accessList !== '0x')\n        transaction.accessList = _core_AccessList_js__WEBPACK_IMPORTED_MODULE_4__.fromTupleList(accessList);\n    if (authorizationList?.length !== 0 && authorizationList !== '0x')\n        transaction.authorizationList = _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_5__.fromTupleList(authorizationList);\n    if (feePayerSignatureOrSender !== '0x' &&\n        feePayerSignatureOrSender !== undefined) {\n        if (feePayerSignatureOrSender === '0x00' ||\n            _core_Address_js__WEBPACK_IMPORTED_MODULE_0__.validate(feePayerSignatureOrSender))\n            transaction.feePayerSignature = null;\n        else\n            transaction.feePayerSignature = _core_Signature_js__WEBPACK_IMPORTED_MODULE_6__.fromTuple(feePayerSignatureOrSender);\n    }\n    if (keyAuthorization)\n        transaction.keyAuthorization = _KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_7__.fromTuple(keyAuthorization);\n    const signatureEnvelope = signature\n        ? _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_8__.deserialize(signature)\n        : undefined;\n    if (signatureEnvelope)\n        transaction = {\n            ...transaction,\n            signature: signatureEnvelope,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into a Tempo Transaction Envelope.\n *\n * Use this to create transaction envelopes with Tempo-specific features like batched calls,\n * fee tokens, access keys, and scheduled execution. Attach a signature using the `signature`\n * option after signing with {@link ox#TxEnvelopeTempo.(getSignPayload:function)}.\n *\n * [Tempo Transaction Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction)\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({ // [!code focus]\n *   chainId: 1, // [!code focus]\n *   calls: [{ // [!code focus]\n *     data: '0xdeadbeef', // [!code focus]\n *     to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   }], // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TxEnvelopeTempo.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   calls: [{ to: '0x0000000000000000000000000000000000000000', value: 1000000000000000000n }],\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   type: 'tempo',\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate a Tempo Transaction Envelope from a {@link ox#TxEnvelopeTempo.Serialized} value.\n *\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from('0x76f84a0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0808080')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   calls: [{\n * // @log:     data: '0xdeadbeef',\n * // @log:     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   }],\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   type: 'tempo',\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A Tempo Transaction Envelope.\n */\nfunction from(envelope, options = {}) {\n    const { feePayerSignature, signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? { signature: _SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_8__.from(signature) } : {}),\n        ...(feePayerSignature\n            ? { feePayerSignature: _core_Signature_js__WEBPACK_IMPORTED_MODULE_6__.from(feePayerSignature) }\n            : {}),\n        type: 'tempo',\n    };\n}\n/**\n * Serializes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * RLP-encodes the transaction with type prefix `0x76`. For fee sponsorship, use `format: 'feePayer'`\n * to serialize with the fee payer magic `0x78` and the sender address.\n *\n * [RLP Encoding](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#rlp-encoding)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n * })\n *\n * const serialized = TxEnvelopeTempo.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Value } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   maxFeePerGas: Value.fromGwei('10'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TxEnvelopeTempo.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nfunction serialize(envelope, options = {}) {\n    const { accessList, authorizationList, calls, chainId, feeToken, gas, keyAuthorization, nonce, nonceKey, maxFeePerGas, maxPriorityFeePerGas, validBefore, validAfter, } = envelope;\n    assert(envelope);\n    const accessTupleList = _core_AccessList_js__WEBPACK_IMPORTED_MODULE_4__.toTupleList(accessList);\n    const signature = options.signature || envelope.signature;\n    const authorizationTupleList = _AuthorizationTempo_js__WEBPACK_IMPORTED_MODULE_5__.toTupleList(authorizationList);\n    // Encode calls as RLP list of [to, value, data] tuples\n    const callsTupleList = calls.map((call) => [\n        call.to ?? '0x',\n        call.value ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(call.value) : '0x',\n        call.data ?? '0x',\n    ]);\n    const feePayerSignatureOrSender = (() => {\n        if (options.sender)\n            return options.sender;\n        const feePayerSignature = typeof options.feePayerSignature !== 'undefined'\n            ? options.feePayerSignature\n            : envelope.feePayerSignature;\n        if (feePayerSignature === null)\n            return '0x00';\n        if (!feePayerSignature)\n            return '0x';\n        return _core_Signature_js__WEBPACK_IMPORTED_MODULE_6__.toTuple(feePayerSignature);\n    })();\n    const serialized = [\n        _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        maxPriorityFeePerGas ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxPriorityFeePerGas) : '0x',\n        maxFeePerGas ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxFeePerGas) : '0x',\n        gas ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : '0x',\n        callsTupleList,\n        accessTupleList,\n        nonceKey ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonceKey) : '0x',\n        nonce ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : '0x',\n        typeof validBefore === 'number' ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(validBefore) : '0x',\n        typeof validAfter === 'number' ? _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(validAfter) : '0x',\n        typeof feeToken === 'bigint' || typeof feeToken === 'string'\n            ? _TokenId_js__WEBPACK_IMPORTED_MODULE_9__.toAddress(feeToken)\n            : '0x',\n        feePayerSignatureOrSender,\n        authorizationTupleList,\n        ...(keyAuthorization ? [_KeyAuthorization_js__WEBPACK_IMPORTED_MODULE_7__.toTuple(keyAuthorization)] : []),\n        ...(signature\n            ? [_SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_8__.serialize(_SignatureEnvelope_js__WEBPACK_IMPORTED_MODULE_8__.from(signature))]\n            : []),\n    ];\n    return _core_Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat(options.format === 'feePayer' ? feePayerMagic : serializedType, _core_Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized));\n}\n/**\n * Returns the payload to sign for a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * Computes the keccak256 hash of the unsigned serialized transaction. Sign this payload\n * with secp256k1, P256, or WebAuthn, then attach the signature via {@link ox#TxEnvelopeTempo.(from:function)}.\n *\n * [Tempo Transaction Specification](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction)\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const payload = TxEnvelopeTempo.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nfunction getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TxEnvelopeTempo.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TxEnvelopeTempo.from(envelope, { signature })\n *\n * const hash = TxEnvelopeTempo.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Tempo Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nfunction hash(envelope, options = {}) {\n    const serialized = serialize({\n        ...envelope,\n        ...(options.presign\n            ? {\n                signature: undefined,\n            }\n            : {}),\n    });\n    return _core_Hash_js__WEBPACK_IMPORTED_MODULE_10__.keccak256(serialized);\n}\n/**\n * Returns the fee payer payload to sign for a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}.\n *\n * Fee sponsorship uses a dual-signature scheme: the sender signs the transaction, then a fee payer\n * signs over the transaction with the sender's address to commit to paying fees. The fee payer's\n * signature includes the `feeToken` and `sender_address`, using magic byte `0x78` for domain separation.\n *\n * [Fee Payer Signature](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#fee-payer-signature)\n * [Fee Sponsorship Guide](https://docs.tempo.xyz/protocol/transactions#fee-sponsorship)\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const envelope = TxEnvelopeTempo.from({\n *   chainId: 1,\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   }],\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n * })\n *\n * const payload = TxEnvelopeTempo.getFeePayerSignPayload(envelope, {\n *   sender: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045'\n * }) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the fee payer sign payload for.\n * @param options - Options.\n * @returns The fee payer sign payload.\n */\nfunction getFeePayerSignPayload(envelope, options) {\n    const { sender } = options;\n    const serialized = serialize({ ...envelope, signature: undefined }, {\n        sender,\n        format: 'feePayer',\n    });\n    return _core_Hash_js__WEBPACK_IMPORTED_MODULE_10__.keccak256(serialized);\n}\n/**\n * Validates a {@link ox#TxEnvelopeTempo.TxEnvelopeTempo}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * const valid = TxEnvelopeTempo.validate({\n *   calls: [{\n *     data: '0xdeadbeef',\n *     to: '0x0000000000000000000000000000000000000000',\n *   }],\n *   chainId: 1,\n *   maxFeePerGas: 1000000000n,\n * })\n * // @log: true\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when a transaction's calls list is empty.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [],\n *   chainId: 1,\n * })\n * // @error: TxEnvelopeTempo.CallsEmptyError: Calls list cannot be empty.\n * ```\n */\nclass CallsEmptyError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_11__.BaseError {\n    constructor() {\n        super('Calls list cannot be empty.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TxEnvelopeTempo.CallsEmptyError'\n        });\n    }\n}\n/**\n * Thrown when validBefore is not greater than validAfter.\n *\n * @example\n * ```ts twoslash\n * import { TxEnvelopeTempo } from 'ox/tempo'\n *\n * TxEnvelopeTempo.assert({\n *   calls: [{ to: '0x0000000000000000000000000000000000000000' }],\n *   chainId: 1,\n *   validBefore: 100,\n *   validAfter: 200,\n * })\n * // @error: TxEnvelopeTempo.InvalidValidityWindowError: validBefore (100) must be greater than validAfter (200).\n * ```\n */\nclass InvalidValidityWindowError extends _core_Errors_js__WEBPACK_IMPORTED_MODULE_11__.BaseError {\n    constructor({ validBefore, validAfter, }) {\n        super(`validBefore (${validBefore}) must be greater than validAfter (${validAfter}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TxEnvelopeTempo.InvalidValidityWindowError'\n        });\n    }\n}\n//# sourceMappingURL=TxEnvelopeTempo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UeEVudmVsb3BlVGVtcG8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNOO0FBQ0Y7QUFDSjtBQUNGO0FBQ0E7QUFDWTtBQUNXO0FBQ0M7QUFDSjtBQUNFO0FBQ3BCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNQO0FBQ0EsY0FBYywwQ0FBMEM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBLGVBQWUsNkRBQTZEO0FBQzVFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksK0VBQStFO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQWMsWUFBWSxlQUFlO0FBQ3pEO0FBQ0E7QUFDQSxrQkFBa0Isb0VBQXVDLEdBQUcsU0FBUztBQUNyRTtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFzQztBQUN4RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0VBQXVDO0FBQ3pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQiwwQ0FBMEM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0VBQStFO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLCtDQUFTLENBQUMsK0NBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUVBQTBDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QWtCO0FBQzlCO0FBQ0E7QUFDQSxlQUFlLGtEQUFrRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ08seUNBQXlDLHVEQUFnQjtBQUNoRSxrQkFBa0IsMEJBQTBCO0FBQzVDLDhCQUE4QixZQUFZLHFDQUFxQyxXQUFXO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS90ZW1wby9UeEVudmVsb3BlVGVtcG8uanM/NzFjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBY2Nlc3NMaXN0IGZyb20gJy4uL2NvcmUvQWNjZXNzTGlzdC5qcyc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4uL2NvcmUvQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vY29yZS9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuLi9jb3JlL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL2NvcmUvSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuLi9jb3JlL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi4vY29yZS9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuLi9jb3JlL1R4RW52ZWxvcGUuanMnO1xuaW1wb3J0ICogYXMgQXV0aG9yaXphdGlvblRlbXBvIGZyb20gJy4vQXV0aG9yaXphdGlvblRlbXBvLmpzJztcbmltcG9ydCAqIGFzIEtleUF1dGhvcml6YXRpb24gZnJvbSAnLi9LZXlBdXRob3JpemF0aW9uLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZUVudmVsb3BlIGZyb20gJy4vU2lnbmF0dXJlRW52ZWxvcGUuanMnO1xuaW1wb3J0ICogYXMgVG9rZW5JZCBmcm9tICcuL1Rva2VuSWQuanMnO1xuZXhwb3J0IGNvbnN0IGZlZVBheWVyTWFnaWMgPSAnMHg3OCc7XG5leHBvcnQgY29uc3Qgc2VyaWFsaXplZFR5cGUgPSAnMHg3Nic7XG5leHBvcnQgY29uc3QgdHlwZSA9ICd0ZW1wbyc7XG4vKipcbiAqIEFzc2VydHMgYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30gaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBUeEVudmVsb3BlVGVtcG8uYXNzZXJ0KHtcbiAqICAgY2FsbHM6IFt7IHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgdmFsdWU6IDBuIH1dLFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZW52ZWxvcGUpIHtcbiAgICBjb25zdCB7IGNhbGxzLCBjaGFpbklkLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCB2YWxpZEJlZm9yZSwgdmFsaWRBZnRlciwgfSA9IGVudmVsb3BlO1xuICAgIC8vIENhbGxzIG11c3Qgbm90IGJlIGVtcHR5XG4gICAgaWYgKCFjYWxscyB8fCBjYWxscy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBDYWxsc0VtcHR5RXJyb3IoKTtcbiAgICAvLyB2YWxpZEJlZm9yZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB2YWxpZEFmdGVyIGlmIGJvdGggYXJlIHNldFxuICAgIGlmICh0eXBlb2YgdmFsaWRCZWZvcmUgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiB2YWxpZEFmdGVyID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWxpZEJlZm9yZSA8PSB2YWxpZEFmdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVmFsaWRpdHlXaW5kb3dFcnJvcih7XG4gICAgICAgICAgICB2YWxpZEJlZm9yZTogdmFsaWRCZWZvcmUsXG4gICAgICAgICAgICB2YWxpZEFmdGVyOiB2YWxpZEFmdGVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgZWFjaCBjYWxsXG4gICAgaWYgKGNhbGxzKVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgY2FsbHMpXG4gICAgICAgICAgICBpZiAoY2FsbC50bylcbiAgICAgICAgICAgICAgICBBZGRyZXNzLmFzc2VydChjYWxsLnRvLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgLy8gVmFsaWRhdGUgY2hhaW4gSURcbiAgICBpZiAoY2hhaW5JZCA8PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkQ2hhaW5JZEVycm9yKHsgY2hhaW5JZCB9KTtcbiAgICAvLyBWYWxpZGF0ZSBtYXggZmVlIHBlciBnYXNcbiAgICBpZiAobWF4RmVlUGVyR2FzICYmIEJpZ0ludChtYXhGZWVQZXJHYXMpID4gMm4gKiogMjU2biAtIDFuKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5GZWVDYXBUb29IaWdoRXJyb3Ioe1xuICAgICAgICAgICAgZmVlQ2FwOiBtYXhGZWVQZXJHYXMsXG4gICAgICAgIH0pO1xuICAgIGlmIChtYXhQcmlvcml0eUZlZVBlckdhcyAmJlxuICAgICAgICBtYXhGZWVQZXJHYXMgJiZcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPiBtYXhGZWVQZXJHYXMpXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLlRpcEFib3ZlRmVlQ2FwRXJyb3Ioe1xuICAgICAgICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIH0pO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30gZnJvbSBpdHMgc2VyaWFsaXplZCBmb3JtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHhFbnZlbG9wZVRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUeEVudmVsb3BlVGVtcG8uZGVzZXJpYWxpemUoJzB4NzZmODRhMDE4MjAzMTE4NDc3MzU5NDAwODQ3NzM1OTQwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDgwODA4MCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHR5cGU6ICd0ZW1wbycsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA3ODVuLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDIwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBnYXM6IDEwMDAwMDBuLFxuICogLy8gQGxvZzogICBjYWxsczogW3sgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLCB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4gfV0sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICogQHJldHVybnMgRGVzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uQXJyYXkgPSBSbHAudG9IZXgoSGV4LnNsaWNlKHNlcmlhbGl6ZWQsIDEpKTtcbiAgICBjb25zdCBbY2hhaW5JZCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgZ2FzLCBjYWxscywgYWNjZXNzTGlzdCwgbm9uY2VLZXksIG5vbmNlLCB2YWxpZEJlZm9yZSwgdmFsaWRBZnRlciwgZmVlVG9rZW4sIGZlZVBheWVyU2lnbmF0dXJlT3JTZW5kZXIsIGF1dGhvcml6YXRpb25MaXN0LCBrZXlBdXRob3JpemF0aW9uT3JTaWduYXR1cmUsIG1heWJlU2lnbmF0dXJlLF0gPSB0cmFuc2FjdGlvbkFycmF5O1xuICAgIGNvbnN0IGtleUF1dGhvcml6YXRpb24gPSBBcnJheS5pc0FycmF5KGtleUF1dGhvcml6YXRpb25PclNpZ25hdHVyZSlcbiAgICAgICAgPyBrZXlBdXRob3JpemF0aW9uT3JTaWduYXR1cmVcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0ga2V5QXV0aG9yaXphdGlvblxuICAgICAgICA/IG1heWJlU2lnbmF0dXJlXG4gICAgICAgIDoga2V5QXV0aG9yaXphdGlvbk9yU2lnbmF0dXJlO1xuICAgIGlmICghKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID09PSAxMyB8fFxuICAgICAgICB0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gMTQgfHxcbiAgICAgICAgdHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDE1KSlcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbkxpc3QsXG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIGNhbGxzLFxuICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3QsXG4gICAgICAgICAgICAgICAga2V5QXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgICAgICBub25jZUtleSxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICB2YWxpZEJlZm9yZSxcbiAgICAgICAgICAgICAgICB2YWxpZEFmdGVyLFxuICAgICAgICAgICAgICAgIGZlZVRva2VuLFxuICAgICAgICAgICAgICAgIGZlZVBheWVyU2lnbmF0dXJlT3JTZW5kZXIsXG4gICAgICAgICAgICAgICAgLi4uKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID4gMTJcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgIH0pO1xuICAgIGxldCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgY2hhaW5JZDogTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICB0eXBlLFxuICAgIH07XG4gICAgaWYgKEhleC52YWxpZGF0ZShnYXMpICYmIGdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2FzID0gQmlnSW50KGdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShub25jZSkpXG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gbm9uY2UgPT09ICcweCcgPyAwbiA6IEJpZ0ludChub25jZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhGZWVQZXJHYXMpICYmIG1heEZlZVBlckdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzID0gQmlnSW50KG1heEZlZVBlckdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhQcmlvcml0eUZlZVBlckdhcykgJiYgbWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnSW50KG1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKG5vbmNlS2V5KSlcbiAgICAgICAgdHJhbnNhY3Rpb24ubm9uY2VLZXkgPSBub25jZUtleSA9PT0gJzB4JyA/IDBuIDogQmlnSW50KG5vbmNlS2V5KTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbGlkQmVmb3JlKSAmJiB2YWxpZEJlZm9yZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsaWRCZWZvcmUgPSBOdW1iZXIodmFsaWRCZWZvcmUpO1xuICAgIGlmIChIZXgudmFsaWRhdGUodmFsaWRBZnRlcikgJiYgdmFsaWRBZnRlciAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsaWRBZnRlciA9IE51bWJlcih2YWxpZEFmdGVyKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGZlZVRva2VuKSAmJiBmZWVUb2tlbiAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZmVlVG9rZW4gPSBmZWVUb2tlbjtcbiAgICAvLyBQYXJzZSBjYWxscyBhcnJheVxuICAgIGlmIChjYWxscyAmJiBjYWxscyAhPT0gJzB4Jykge1xuICAgICAgICBjb25zdCBjYWxsc0FycmF5ID0gY2FsbHM7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxzID0gY2FsbHNBcnJheS5tYXAoKGNhbGxUdXBsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3RvLCB2YWx1ZSwgZGF0YV0gPSBjYWxsVHVwbGU7XG4gICAgICAgICAgICBjb25zdCBjYWxsID0ge307XG4gICAgICAgICAgICBpZiAodG8gJiYgdG8gIT09ICcweCcpXG4gICAgICAgICAgICAgICAgY2FsbC50byA9IHRvO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnMHgnKVxuICAgICAgICAgICAgICAgIGNhbGwudmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YSAhPT0gJzB4JylcbiAgICAgICAgICAgICAgICBjYWxsLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYWNjZXNzTGlzdD8ubGVuZ3RoICE9PSAwICYmIGFjY2Vzc0xpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgaWYgKGF1dGhvcml6YXRpb25MaXN0Py5sZW5ndGggIT09IDAgJiYgYXV0aG9yaXphdGlvbkxpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvblRlbXBvLmZyb21UdXBsZUxpc3QoYXV0aG9yaXphdGlvbkxpc3QpO1xuICAgIGlmIChmZWVQYXllclNpZ25hdHVyZU9yU2VuZGVyICE9PSAnMHgnICYmXG4gICAgICAgIGZlZVBheWVyU2lnbmF0dXJlT3JTZW5kZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZmVlUGF5ZXJTaWduYXR1cmVPclNlbmRlciA9PT0gJzB4MDAnIHx8XG4gICAgICAgICAgICBBZGRyZXNzLnZhbGlkYXRlKGZlZVBheWVyU2lnbmF0dXJlT3JTZW5kZXIpKVxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXJTaWduYXR1cmUgPSBudWxsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5mZWVQYXllclNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tVHVwbGUoZmVlUGF5ZXJTaWduYXR1cmVPclNlbmRlcik7XG4gICAgfVxuICAgIGlmIChrZXlBdXRob3JpemF0aW9uKVxuICAgICAgICB0cmFuc2FjdGlvbi5rZXlBdXRob3JpemF0aW9uID0gS2V5QXV0aG9yaXphdGlvbi5mcm9tVHVwbGUoa2V5QXV0aG9yaXphdGlvbik7XG4gICAgY29uc3Qgc2lnbmF0dXJlRW52ZWxvcGUgPSBzaWduYXR1cmVcbiAgICAgICAgPyBTaWduYXR1cmVFbnZlbG9wZS5kZXNlcmlhbGl6ZShzaWduYXR1cmUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmIChzaWduYXR1cmVFbnZlbG9wZSlcbiAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlRW52ZWxvcGUsXG4gICAgICAgIH07XG4gICAgYXNzZXJ0KHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbiBvYmplY3QgaW50byBhIFRlbXBvIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIFVzZSB0aGlzIHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiBlbnZlbG9wZXMgd2l0aCBUZW1wby1zcGVjaWZpYyBmZWF0dXJlcyBsaWtlIGJhdGNoZWQgY2FsbHMsXG4gKiBmZWUgdG9rZW5zLCBhY2Nlc3Mga2V5cywgYW5kIHNjaGVkdWxlZCBleGVjdXRpb24uIEF0dGFjaCBhIHNpZ25hdHVyZSB1c2luZyB0aGUgYHNpZ25hdHVyZWBcbiAqIG9wdGlvbiBhZnRlciBzaWduaW5nIHdpdGgge0BsaW5rIG94I1R4RW52ZWxvcGVUZW1wby4oZ2V0U2lnblBheWxvYWQ6ZnVuY3Rpb24pfS5cbiAqXG4gKiBbVGVtcG8gVHJhbnNhY3Rpb24gU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbilcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFR4RW52ZWxvcGVUZW1wby5mcm9tKHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBjaGFpbklkOiAxLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGNhbGxzOiBbeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgICAgZGF0YTogJzB4ZGVhZGJlZWYnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIH1dLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksIC8vIFshY29kZSBmb2N1c11cbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBWYWx1ZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgVHhFbnZlbG9wZVRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUeEVudmVsb3BlVGVtcG8uZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGNhbGxzOiBbe1xuICogICAgIGRhdGE6ICcweGRlYWRiZWVmJyxcbiAqICAgICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIH1dLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUeEVudmVsb3BlVGVtcG8uZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUeEVudmVsb3BlVGVtcG8uZnJvbShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBjYWxsczogW3sgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4gfV0sXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBtYXhQcmlvcml0eUZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICd0ZW1wbycsXG4gKiAvLyBAbG9nOiAgIHI6IDEyNS4uLm4sXG4gKiAvLyBAbG9nOiAgIHM6IDY0Mi4uLm4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEZyb20gU2VyaWFsaXplZFxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGluc3RhbnRpYXRlIGEgVGVtcG8gVHJhbnNhY3Rpb24gRW52ZWxvcGUgZnJvbSBhIHtAbGluayBveCNUeEVudmVsb3BlVGVtcG8uU2VyaWFsaXplZH0gdmFsdWUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVUZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHhFbnZlbG9wZVRlbXBvLmZyb20oJzB4NzZmODRhMDE4MjAzMTE4NDc3MzU5NDAwODQ3NzM1OTQwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDgwODA4MCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIGNhbGxzOiBbe1xuICogLy8gQGxvZzogICAgIGRhdGE6ICcweGRlYWRiZWVmJyxcbiAqIC8vIEBsb2c6ICAgICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAvLyBAbG9nOiAgIH1dLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ3RlbXBvJyxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEEgVGVtcG8gVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGZlZVBheWVyU2lnbmF0dXJlLCBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW52ZWxvcGVfID0gKHR5cGVvZiBlbnZlbG9wZSA9PT0gJ3N0cmluZycgPyBkZXNlcmlhbGl6ZShlbnZlbG9wZSkgOiBlbnZlbG9wZSk7XG4gICAgYXNzZXJ0KGVudmVsb3BlXyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZW52ZWxvcGVfLFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8geyBzaWduYXR1cmU6IFNpZ25hdHVyZUVudmVsb3BlLmZyb20oc2lnbmF0dXJlKSB9IDoge30pLFxuICAgICAgICAuLi4oZmVlUGF5ZXJTaWduYXR1cmVcbiAgICAgICAgICAgID8geyBmZWVQYXllclNpZ25hdHVyZTogU2lnbmF0dXJlLmZyb20oZmVlUGF5ZXJTaWduYXR1cmUpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICB0eXBlOiAndGVtcG8nLFxuICAgIH07XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30uXG4gKlxuICogUkxQLWVuY29kZXMgdGhlIHRyYW5zYWN0aW9uIHdpdGggdHlwZSBwcmVmaXggYDB4NzZgLiBGb3IgZmVlIHNwb25zb3JzaGlwLCB1c2UgYGZvcm1hdDogJ2ZlZVBheWVyJ2BcbiAqIHRvIHNlcmlhbGl6ZSB3aXRoIHRoZSBmZWUgcGF5ZXIgbWFnaWMgYDB4NzhgIGFuZCB0aGUgc2VuZGVyIGFkZHJlc3MuXG4gKlxuICogW1JMUCBFbmNvZGluZ10oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbiNybHAtZW5jb2RpbmcpXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFR4RW52ZWxvcGVUZW1wby5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgY2FsbHM6IFt7XG4gKiAgICAgZGF0YTogJzB4ZGVhZGJlZWYnLFxuICogICAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgfV0sXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUeEVudmVsb3BlVGVtcG8uc2VyaWFsaXplKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBWYWx1ZSB9IGZyb20gJ294J1xuICogaW1wb3J0IHsgVHhFbnZlbG9wZVRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUeEVudmVsb3BlVGVtcG8uZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGNhbGxzOiBbe1xuICogICAgIGRhdGE6ICcweGRlYWRiZWVmJyxcbiAqICAgICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIH1dLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFR4RW52ZWxvcGVUZW1wby5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUeEVudmVsb3BlVGVtcG8uc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gLi4uIHNlbmQgYHNlcmlhbGl6ZWRgIHRyYW5zYWN0aW9uIHRvIEpTT04tUlBDIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYFxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIHNlcmlhbGl6ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFjY2Vzc0xpc3QsIGF1dGhvcml6YXRpb25MaXN0LCBjYWxscywgY2hhaW5JZCwgZmVlVG9rZW4sIGdhcywga2V5QXV0aG9yaXphdGlvbiwgbm9uY2UsIG5vbmNlS2V5LCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCB2YWxpZEJlZm9yZSwgdmFsaWRBZnRlciwgfSA9IGVudmVsb3BlO1xuICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgY29uc3QgYWNjZXNzVHVwbGVMaXN0ID0gQWNjZXNzTGlzdC50b1R1cGxlTGlzdChhY2Nlc3NMaXN0KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBvcHRpb25zLnNpZ25hdHVyZSB8fCBlbnZlbG9wZS5zaWduYXR1cmU7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvblR1cGxlTGlzdCA9IEF1dGhvcml6YXRpb25UZW1wby50b1R1cGxlTGlzdChhdXRob3JpemF0aW9uTGlzdCk7XG4gICAgLy8gRW5jb2RlIGNhbGxzIGFzIFJMUCBsaXN0IG9mIFt0bywgdmFsdWUsIGRhdGFdIHR1cGxlc1xuICAgIGNvbnN0IGNhbGxzVHVwbGVMaXN0ID0gY2FsbHMubWFwKChjYWxsKSA9PiBbXG4gICAgICAgIGNhbGwudG8gPz8gJzB4JyxcbiAgICAgICAgY2FsbC52YWx1ZSA/IEhleC5mcm9tTnVtYmVyKGNhbGwudmFsdWUpIDogJzB4JyxcbiAgICAgICAgY2FsbC5kYXRhID8/ICcweCcsXG4gICAgXSk7XG4gICAgY29uc3QgZmVlUGF5ZXJTaWduYXR1cmVPclNlbmRlciA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnNlbmRlcilcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnNlbmRlcjtcbiAgICAgICAgY29uc3QgZmVlUGF5ZXJTaWduYXR1cmUgPSB0eXBlb2Ygb3B0aW9ucy5mZWVQYXllclNpZ25hdHVyZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gb3B0aW9ucy5mZWVQYXllclNpZ25hdHVyZVxuICAgICAgICAgICAgOiBlbnZlbG9wZS5mZWVQYXllclNpZ25hdHVyZTtcbiAgICAgICAgaWYgKGZlZVBheWVyU2lnbmF0dXJlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuICcweDAwJztcbiAgICAgICAgaWYgKCFmZWVQYXllclNpZ25hdHVyZSlcbiAgICAgICAgICAgIHJldHVybiAnMHgnO1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnRvVHVwbGUoZmVlUGF5ZXJTaWduYXR1cmUpO1xuICAgIH0pKCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgSGV4LmZyb21OdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID8gSGV4LmZyb21OdW1iZXIobWF4UHJpb3JpdHlGZWVQZXJHYXMpIDogJzB4JyxcbiAgICAgICAgbWF4RmVlUGVyR2FzID8gSGV4LmZyb21OdW1iZXIobWF4RmVlUGVyR2FzKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICBjYWxsc1R1cGxlTGlzdCxcbiAgICAgICAgYWNjZXNzVHVwbGVMaXN0LFxuICAgICAgICBub25jZUtleSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlS2V5KSA6ICcweCcsXG4gICAgICAgIG5vbmNlID8gSGV4LmZyb21OdW1iZXIobm9uY2UpIDogJzB4JyxcbiAgICAgICAgdHlwZW9mIHZhbGlkQmVmb3JlID09PSAnbnVtYmVyJyA/IEhleC5mcm9tTnVtYmVyKHZhbGlkQmVmb3JlKSA6ICcweCcsXG4gICAgICAgIHR5cGVvZiB2YWxpZEFmdGVyID09PSAnbnVtYmVyJyA/IEhleC5mcm9tTnVtYmVyKHZhbGlkQWZ0ZXIpIDogJzB4JyxcbiAgICAgICAgdHlwZW9mIGZlZVRva2VuID09PSAnYmlnaW50JyB8fCB0eXBlb2YgZmVlVG9rZW4gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IFRva2VuSWQudG9BZGRyZXNzKGZlZVRva2VuKVxuICAgICAgICAgICAgOiAnMHgnLFxuICAgICAgICBmZWVQYXllclNpZ25hdHVyZU9yU2VuZGVyLFxuICAgICAgICBhdXRob3JpemF0aW9uVHVwbGVMaXN0LFxuICAgICAgICAuLi4oa2V5QXV0aG9yaXphdGlvbiA/IFtLZXlBdXRob3JpemF0aW9uLnRvVHVwbGUoa2V5QXV0aG9yaXphdGlvbildIDogW10pLFxuICAgICAgICAuLi4oc2lnbmF0dXJlXG4gICAgICAgICAgICA/IFtTaWduYXR1cmVFbnZlbG9wZS5zZXJpYWxpemUoU2lnbmF0dXJlRW52ZWxvcGUuZnJvbShzaWduYXR1cmUpKV1cbiAgICAgICAgICAgIDogW10pLFxuICAgIF07XG4gICAgcmV0dXJuIEhleC5jb25jYXQob3B0aW9ucy5mb3JtYXQgPT09ICdmZWVQYXllcicgPyBmZWVQYXllck1hZ2ljIDogc2VyaWFsaXplZFR5cGUsIFJscC5mcm9tSGV4KHNlcmlhbGl6ZWQpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcGF5bG9hZCB0byBzaWduIGZvciBhIHtAbGluayBveCNUeEVudmVsb3BlVGVtcG8uVHhFbnZlbG9wZVRlbXBvfS5cbiAqXG4gKiBDb21wdXRlcyB0aGUga2VjY2FrMjU2IGhhc2ggb2YgdGhlIHVuc2lnbmVkIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uIFNpZ24gdGhpcyBwYXlsb2FkXG4gKiB3aXRoIHNlY3AyNTZrMSwgUDI1Niwgb3IgV2ViQXV0aG4sIHRoZW4gYXR0YWNoIHRoZSBzaWduYXR1cmUgdmlhIHtAbGluayBveCNUeEVudmVsb3BlVGVtcG8uKGZyb206ZnVuY3Rpb24pfS5cbiAqXG4gKiBbVGVtcG8gVHJhbnNhY3Rpb24gU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbilcbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxIH0gZnJvbSAnb3gnXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFR4RW52ZWxvcGVUZW1wby5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgY2FsbHM6IFt7XG4gKiAgICAgZGF0YTogJzB4ZGVhZGJlZWYnLFxuICogICAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgfV0sXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBUeEVudmVsb3BlVGVtcG8uZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBnZXQgdGhlIHNpZ24gcGF5bG9hZCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgc2lnbiBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIHtcbiAgICByZXR1cm4gaGFzaChlbnZlbG9wZSwgeyBwcmVzaWduOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBIYXNoZXMgYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30uIFRoaXMgaXMgdGhlIFwidHJhbnNhY3Rpb24gaGFzaFwiLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVUZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHhFbnZlbG9wZVRlbXBvLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBjYWxsczogW3tcbiAqICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB9XSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUeEVudmVsb3BlVGVtcG8uZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3NpZ25lZCA9IFR4RW52ZWxvcGVUZW1wby5mcm9tKGVudmVsb3BlLCB7IHNpZ25hdHVyZSB9KVxuICpcbiAqIGNvbnN0IGhhc2ggPSBUeEVudmVsb3BlVGVtcG8uaGFzaChlbnZlbG9wZV9zaWduZWQpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBUZW1wbyBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBoYXNoLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZSh7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICAuLi4ob3B0aW9ucy5wcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgIH0pO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihzZXJpYWxpemVkKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmVlIHBheWVyIHBheWxvYWQgdG8gc2lnbiBmb3IgYSB7QGxpbmsgb3gjVHhFbnZlbG9wZVRlbXBvLlR4RW52ZWxvcGVUZW1wb30uXG4gKlxuICogRmVlIHNwb25zb3JzaGlwIHVzZXMgYSBkdWFsLXNpZ25hdHVyZSBzY2hlbWU6IHRoZSBzZW5kZXIgc2lnbnMgdGhlIHRyYW5zYWN0aW9uLCB0aGVuIGEgZmVlIHBheWVyXG4gKiBzaWducyBvdmVyIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzZW5kZXIncyBhZGRyZXNzIHRvIGNvbW1pdCB0byBwYXlpbmcgZmVlcy4gVGhlIGZlZSBwYXllcidzXG4gKiBzaWduYXR1cmUgaW5jbHVkZXMgdGhlIGBmZWVUb2tlbmAgYW5kIGBzZW5kZXJfYWRkcmVzc2AsIHVzaW5nIG1hZ2ljIGJ5dGUgYDB4NzhgIGZvciBkb21haW4gc2VwYXJhdGlvbi5cbiAqXG4gKiBbRmVlIFBheWVyIFNpZ25hdHVyZV0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMvc3BlYy10ZW1wby10cmFuc2FjdGlvbiNmZWUtcGF5ZXItc2lnbmF0dXJlKVxuICogW0ZlZSBTcG9uc29yc2hpcCBHdWlkZV0oaHR0cHM6Ly9kb2NzLnRlbXBvLnh5ei9wcm90b2NvbC90cmFuc2FjdGlvbnMjZmVlLXNwb25zb3JzaGlwKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqIGltcG9ydCB7IFR4RW52ZWxvcGVUZW1wbyB9IGZyb20gJ294L3RlbXBvJ1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHhFbnZlbG9wZVRlbXBvLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBjYWxsczogW3tcbiAqICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB9XSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IFR4RW52ZWxvcGVUZW1wby5nZXRGZWVQYXllclNpZ25QYXlsb2FkKGVudmVsb3BlLCB7XG4gKiAgIHNlbmRlcjogJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NSdcbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBnZXQgdGhlIGZlZSBwYXllciBzaWduIHBheWxvYWQgZm9yLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGZlZSBwYXllciBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWVQYXllclNpZ25QYXlsb2FkKGVudmVsb3BlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBzZW5kZXIgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZSh7IC4uLmVudmVsb3BlLCBzaWduYXR1cmU6IHVuZGVmaW5lZCB9LCB7XG4gICAgICAgIHNlbmRlcixcbiAgICAgICAgZm9ybWF0OiAnZmVlUGF5ZXInLFxuICAgIH0pO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihzZXJpYWxpemVkKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEge0BsaW5rIG94I1R4RW52ZWxvcGVUZW1wby5UeEVudmVsb3BlVGVtcG99LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHhFbnZlbG9wZVRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogY29uc3QgdmFsaWQgPSBUeEVudmVsb3BlVGVtcG8udmFsaWRhdGUoe1xuICogICBjYWxsczogW3tcbiAqICAgICBkYXRhOiAnMHhkZWFkYmVlZicsXG4gKiAgICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB9XSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqIH0pXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gdmFsaWRhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShlbnZlbG9wZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgdHJhbnNhY3Rpb24ncyBjYWxscyBsaXN0IGlzIGVtcHR5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHhFbnZlbG9wZVRlbXBvIH0gZnJvbSAnb3gvdGVtcG8nXG4gKlxuICogVHhFbnZlbG9wZVRlbXBvLmFzc2VydCh7XG4gKiAgIGNhbGxzOiBbXSxcbiAqICAgY2hhaW5JZDogMSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IFR4RW52ZWxvcGVUZW1wby5DYWxsc0VtcHR5RXJyb3I6IENhbGxzIGxpc3QgY2Fubm90IGJlIGVtcHR5LlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsc0VtcHR5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0NhbGxzIGxpc3QgY2Fubm90IGJlIGVtcHR5LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHhFbnZlbG9wZVRlbXBvLkNhbGxzRW1wdHlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB2YWxpZEJlZm9yZSBpcyBub3QgZ3JlYXRlciB0aGFuIHZhbGlkQWZ0ZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUeEVudmVsb3BlVGVtcG8gfSBmcm9tICdveC90ZW1wbydcbiAqXG4gKiBUeEVudmVsb3BlVGVtcG8uYXNzZXJ0KHtcbiAqICAgY2FsbHM6IFt7IHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyB9XSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdmFsaWRCZWZvcmU6IDEwMCxcbiAqICAgdmFsaWRBZnRlcjogMjAwLFxuICogfSlcbiAqIC8vIEBlcnJvcjogVHhFbnZlbG9wZVRlbXBvLkludmFsaWRWYWxpZGl0eVdpbmRvd0Vycm9yOiB2YWxpZEJlZm9yZSAoMTAwKSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB2YWxpZEFmdGVyICgyMDApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVmFsaWRpdHlXaW5kb3dFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsaWRCZWZvcmUsIHZhbGlkQWZ0ZXIsIH0pIHtcbiAgICAgICAgc3VwZXIoYHZhbGlkQmVmb3JlICgke3ZhbGlkQmVmb3JlfSkgbXVzdCBiZSBncmVhdGVyIHRoYW4gdmFsaWRBZnRlciAoJHt2YWxpZEFmdGVyfSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUeEVudmVsb3BlVGVtcG8uSW52YWxpZFZhbGlkaXR5V2luZG93RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR4RW52ZWxvcGVUZW1wby5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/tempo/TxEnvelopeTempo.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n/** connects noble-curves to noble-hashes */\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBDO0FBQ3FCO0FBQ1A7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQUksWUFBWSxnRUFBVztBQUMzRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHFFQUFXLEdBQUcsK0JBQStCO0FBQzFFLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanM/YzBiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3Igc2hvcnQgd2VpZXJzdHJhc3MgY3VydmVzLCBjb21iaW5lZCB3aXRoIG5vYmxlLWhhc2hlcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG5pbXBvcnQgeyBjb25jYXRCeXRlcywgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzIH0gZnJvbSBcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIjtcbi8qKiBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaG1hYzogKGtleSwgLi4ubXNncykgPT4gaG1hYyhoYXNoLCBrZXksIGNvbmNhdEJ5dGVzKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xuICAgIGNvbnN0IGNyZWF0ZSA9IChoYXNoKSA9PiB3ZWllcnN0cmFzcyh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiB7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   precomputeMSMUnsafe: () => (/* binding */ precomputeMSMUnsafe),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nfunction wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n                }\n                else {\n                    // bits are 1: add to result point\n                    p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n                }\n            }\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                if (n === _0n)\n                    break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // Window bits are 0: skip processing.\n                    // Move to next window.\n                    continue;\n                }\n                else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nfunction pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nfunction precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRDtBQUNPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxxQ0FBcUM7QUFDckMsOEJBQThCO0FBQzlCLGlCQUFpQixrREFBTyxLQUFLO0FBQzdCLCtCQUErQjtBQUMvQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksdUNBQXVDO0FBQ25ELGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxnQ0FBZ0M7QUFDaEMsNkJBQTZCO0FBQzdCLHFDQUFxQztBQUNyQyxpQ0FBaUM7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JB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L3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcz8zZWVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWV0aG9kcyBmb3IgZWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gYnkgc2NhbGFycy5cbiAqIENvbnRhaW5zIHdOQUYsIHBpcHBlbmdlclxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBuTGVuZ3RoLCB2YWxpZGF0ZUZpZWxkIH0gZnJvbSBcIi4vbW9kdWxhci5qc1wiO1xuaW1wb3J0IHsgYml0TGVuLCBiaXRNYXNrLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5mdW5jdGlvbiBjb25zdFRpbWVOZWdhdGUoY29uZGl0aW9uLCBpdGVtKSB7XG4gICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVyhXLCBiaXRzKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3aW5kb3cgc2l6ZSwgZXhwZWN0ZWQgWzEuLicgKyBiaXRzICsgJ10sIGdvdCBXPScgKyBXKTtcbn1cbmZ1bmN0aW9uIGNhbGNXT3B0cyhXLCBzY2FsYXJCaXRzKSB7XG4gICAgdmFsaWRhdGVXKFcsIHNjYWxhckJpdHMpO1xuICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoc2NhbGFyQml0cyAvIFcpICsgMTsgLy8gVz04IDMzLiBOb3QgMzIsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gVz04IDEyOC4gTm90IDI1NiwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7IC8vIFc9OCAyNTZcbiAgICBjb25zdCBtYXNrID0gYml0TWFzayhXKTsgLy8gVz04IDI1NSA9PSBtYXNrIDBiMTExMTExMTFcbiAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpOyAvLyBXPTggOFxuICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9O1xufVxuZnVuY3Rpb24gY2FsY09mZnNldHMobiwgd2luZG93LCB3T3B0cykge1xuICAgIGNvbnN0IHsgd2luZG93U2l6ZSwgbWFzaywgbWF4TnVtYmVyLCBzaGlmdEJ5IH0gPSB3T3B0cztcbiAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spOyAvLyBleHRyYWN0IFcgYml0cy5cbiAgICBsZXQgbmV4dE4gPSBuID4+IHNoaWZ0Qnk7IC8vIHNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgLy8gV2hhdCBhY3R1YWxseSBoYXBwZW5zIGhlcmU6XG4gICAgLy8gY29uc3QgaGlnaGVzdEJpdCA9IE51bWJlcihtYXNrIF4gKG1hc2sgPj4gMW4pKTtcbiAgICAvLyBsZXQgd2JpdHMyID0gd2JpdHMgLSAxOyAvLyBza2lwIHplcm9cbiAgICAvLyBpZiAod2JpdHMyICYgaGlnaGVzdEJpdCkgeyB3Yml0czIgXj0gTnVtYmVyKG1hc2spOyAvLyAofik7XG4gICAgLy8gc3BsaXQgaWYgYml0cyA+IG1heDogKzIyNCA9PiAyNTYtMzJcbiAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgIC8vIHdlIHNraXAgemVybywgd2hpY2ggbWVhbnMgaW5zdGVhZCBvZiBgPj0gc2l6ZS0xYCwgd2UgZG8gYD4gc2l6ZWBcbiAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyOyAvLyAtMzIsIGNhbiBiZSBtYXhOdW1iZXIgLSB3Yml0cywgYnV0IHRoZW4gd2UgbmVlZCB0byBzZXQgaXNOZWcgaGVyZS5cbiAgICAgICAgbmV4dE4gKz0gXzFuOyAvLyArMjU2IChjYXJyeSlcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFN0YXJ0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBpc1plcm8gPSB3Yml0cyA9PT0gMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgYSAwP1xuICAgIGNvbnN0IGlzTmVnID0gd2JpdHMgPCAwOyAvLyBpcyBjdXJyZW50IHdpbmRvdyBzbGljZSBuZWdhdGl2ZT9cbiAgICBjb25zdCBpc05lZ0YgPSB3aW5kb3cgJSAyICE9PSAwOyAvLyBmYWtlIHJhbmRvbSBzdGF0ZW1lbnQgZm9yIG5vaXNlXG4gICAgY29uc3Qgb2Zmc2V0RiA9IG9mZnNldFN0YXJ0OyAvLyBmYWtlIG9mZnNldCBmb3Igbm9pc2VcbiAgICByZXR1cm4geyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG4gICAgcG9pbnRzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkJyk7XG4gICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgICAgIGlmICghZmllbGQuaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggJyArIGkpO1xuICAgIH0pO1xufVxuLy8gU2luY2UgcG9pbnRzIGluIGRpZmZlcmVudCBncm91cHMgY2Fubm90IGJlIGVxdWFsIChkaWZmZXJlbnQgb2JqZWN0IGNvbnN0cnVjdG9yKSxcbi8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlcy5cbi8vIEFsbG93cyB0byBtYWtlIHBvaW50cyBmcm96ZW4gLyBpbW11dGFibGUuXG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHBvaW50V2luZG93U2l6ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0VyhQKSB7XG4gICAgcmV0dXJuIHBvaW50V2luZG93U2l6ZXMuZ2V0KFApIHx8IDE7XG59XG4vKipcbiAqIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbiAqIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuICogQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4gKiAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbiAqIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3JcbiAqIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbiAqIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuICogLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuICogLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbiAqXG4gKiBAdG9kbyBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuXG4gKiBUaGlzIHdvdWxkIGFsbG93IHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgaGFzUHJlY29tcHV0ZXMoZWxtKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VyhlbG0pICE9PSAxO1xuICAgICAgICB9LFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbiwgcCA9IGMuWkVSTykge1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcGFyYW0gZWxtIFBvaW50IGluc3RhbmNlXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IGNhbGNXT3B0cyhXLCBiaXRzKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vIGk9MSwgYmMgd2Ugc2tpcCAwXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFNtYWxsZXIgdmVyc2lvbjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtc2VjcDI1NmsxL2Jsb2IvNDdjYjE2NjliNmU1MDZhZDY2YjM1ZmU3ZDc2MTMyYWU5NzQ2NWRhMi9pbmRleC50cyNMNTAyLUw1NDFcbiAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIHRoZSBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyP1xuICAgICAgICAgICAgLy8gd05BRiBiZWhhdmlvciBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlLiBCdXQgaGF2ZSB0byBjYXJlZnVsbHkgcmVtb3ZlXG4gICAgICAgICAgICAvLyBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZS5cbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdG9yc1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgY29uc3Qgd28gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3by53aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIC8vIChuID09PSBfMG4pIGlzIGhhbmRsZWQgYW5kIG5vdCBlYXJseS1leGl0ZWQuIGlzRXZlbiBhbmQgb2Zmc2V0RiBhcmUgdXNlZCBmb3Igbm9pc2VcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5leHROLCBvZmZzZXQsIGlzWmVybywgaXNOZWcsIGlzTmVnRiwgb2Zmc2V0RiB9ID0gY2FsY09mZnNldHMobiwgd2luZG93LCB3byk7XG4gICAgICAgICAgICAgICAgbiA9IG5leHROO1xuICAgICAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMDogYWRkIGdhcmJhZ2UgdG8gZmFrZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyBJbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXk6IGFkZCByYW5kb20gXCJub2lzZVwiIHBvaW50IHRvIGYuXG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoaXNOZWdGLCBwcmVjb21wdXRlc1tvZmZzZXRGXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMTogYWRkIHRvIHJlc3VsdCBwb2ludFxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGlzTmVnLCBwcmVjb21wdXRlc1tvZmZzZXRdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0dXJuIGJvdGggcmVhbCBhbmQgZmFrZSBwb2ludHM6IEpJVCB3b24ndCBlbGltaW5hdGUgZi5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIHVuc2FmZSAobm9uIGNvbnN0LXRpbWUpIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHBhcmFtIGFjYyBhY2N1bXVsYXRvciBwb2ludCB0byBhZGQgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICB3TkFGVW5zYWZlKFcsIHByZWNvbXB1dGVzLCBuLCBhY2MgPSBjLlpFUk8pIHtcbiAgICAgICAgICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gRWFybHktZXhpdCwgc2tpcCAwIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnIH0gPSBjYWxjT2Zmc2V0cyhuLCB3aW5kb3csIHdvKTtcbiAgICAgICAgICAgICAgICBuID0gbmV4dE47XG4gICAgICAgICAgICAgICAgaWYgKGlzWmVybykge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3cgYml0cyBhcmUgMDogc2tpcCBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwcmVjb21wdXRlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICBhY2MgPSBhY2MuYWRkKGlzTmVnID8gaXRlbS5uZWdhdGUoKSA6IGl0ZW0pOyAvLyBSZS11c2luZyBhY2MgYWxsb3dzIHRvIHNhdmUgYWRkcyBpbiBNU01cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LFxuICAgICAgICBnZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwb2ludFByZWNvbXB1dGVzLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcDtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IFcgPSBnZXRXKFApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSksIG4pO1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkVW5zYWZlKFAsIG4sIHRyYW5zZm9ybSwgcHJldikge1xuICAgICAgICAgICAgY29uc3QgVyA9IGdldFcoUCk7XG4gICAgICAgICAgICBpZiAoVyA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNhZmVMYWRkZXIoUCwgbiwgcHJldik7IC8vIEZvciBXPTEgbGFkZGVyIGlzIH54MiBmYXN0ZXJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUZVbnNhZmUoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pLCBuLCBwcmV2KTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gV2UgY2FsY3VsYXRlIHByZWNvbXB1dGVzIGZvciBlbGxpcHRpYyBjdXJ2ZSBwb2ludCBtdWx0aXBsaWNhdGlvblxuICAgICAgICAvLyB1c2luZyB3aW5kb3dlZCBtZXRob2QuIFRoaXMgc3BlY2lmaWVzIHdpbmRvdyBzaXplIGFuZFxuICAgICAgICAvLyBzdG9yZXMgcHJlY29tcHV0ZWQgdmFsdWVzLiBVc3VhbGx5IG9ubHkgYmFzZSBwb2ludCB3b3VsZCBiZSBwcmVjb21wdXRlZC5cbiAgICAgICAgc2V0V2luZG93U2l6ZShQLCBXKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVcoVywgYml0cyk7XG4gICAgICAgICAgICBwb2ludFdpbmRvd1NpemVzLnNldChQLCBXKTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKFApO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFBpcHBlbmdlciBhbGdvcml0aG0gZm9yIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogMzB4IGZhc3RlciB2cyBuYWl2ZSBhZGRpdGlvbiBvbiBMPTQwOTYsIDEweCBmYXN0ZXIgdGhhbiBwcmVjb21wdXRlcy5cbiAqIEZvciBOPTI1NGJpdCwgTD0xLCBpdCBkb2VzOiAxMDI0IEFERCArIDI1NCBEQkwuIEZvciBMPTU6IDE1MzYgQUREICsgMjU0IERCTC5cbiAqIEFsZ29yaXRobWljYWxseSBjb25zdGFudC10aW1lIChmb3Igc2FtZSBMKSwgZXZlbiB3aGVuIDEgcG9pbnQgKyBzY2FsYXIsIG9yIHdoZW4gc2NhbGFyID0gMC5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHBhcmFtIHNjYWxhcnMgYXJyYXkgb2YgTCBzY2FsYXJzIChha2EgcHJpdmF0ZSBrZXlzIC8gYmlnaW50cylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpcHBlbmdlcihjLCBmaWVsZE4sIHBvaW50cywgc2NhbGFycykge1xuICAgIC8vIElmIHdlIHNwbGl0IHNjYWxhcnMgYnkgc29tZSB3aW5kb3cgKGxldCdzIHNheSA4IGJpdHMpLCBldmVyeSBjaHVuayB3aWxsIG9ubHlcbiAgICAvLyB0YWtlIDI1NiBidWNrZXRzIGV2ZW4gaWYgdGhlcmUgYXJlIDQwOTYgc2NhbGFycywgYWxzbyByZS11c2VzIGRvdWJsZS5cbiAgICAvLyBUT0RPOlxuICAgIC8vIC0gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAyNC83NTAucGRmXG4gICAgLy8gLSBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvMTAyODdcbiAgICAvLyAwIGlzIGFjY2VwdGVkIGluIHNjYWxhcnNcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgIGNvbnN0IHBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IHNsZW5ndGggPSBzY2FsYXJzLmxlbmd0aDtcbiAgICBpZiAocGxlbmd0aCAhPT0gc2xlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheXMgb2YgcG9pbnRzIGFuZCBzY2FsYXJzIG11c3QgaGF2ZSBlcXVhbCBsZW5ndGgnKTtcbiAgICAvLyBpZiAocGxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBtdXN0IGJlIG9mIGxlbmd0aCA+PSAyJyk7XG4gICAgY29uc3QgemVybyA9IGMuWkVSTztcbiAgICBjb25zdCB3Yml0cyA9IGJpdExlbihCaWdJbnQocGxlbmd0aCkpO1xuICAgIGxldCB3aW5kb3dTaXplID0gMTsgLy8gYml0c1xuICAgIGlmICh3Yml0cyA+IDEyKVxuICAgICAgICB3aW5kb3dTaXplID0gd2JpdHMgLSAzO1xuICAgIGVsc2UgaWYgKHdiaXRzID4gNClcbiAgICAgICAgd2luZG93U2l6ZSA9IHdiaXRzIC0gMjtcbiAgICBlbHNlIGlmICh3Yml0cyA+IDApXG4gICAgICAgIHdpbmRvd1NpemUgPSAyO1xuICAgIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTnVtYmVyKE1BU0spICsgMSkuZmlsbCh6ZXJvKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcbiAgICBjb25zdCBsYXN0Qml0cyA9IE1hdGguZmxvb3IoKGZpZWxkTi5CSVRTIC0gMSkgLyB3aW5kb3dTaXplKSAqIHdpbmRvd1NpemU7XG4gICAgbGV0IHN1bSA9IHplcm87XG4gICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuICAgICAgICBidWNrZXRzLmZpbGwoemVybyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsYXIgPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgY29uc3Qgd2JpdHMgPSBOdW1iZXIoKHNjYWxhciA+PiBCaWdJbnQoaSkpICYgTUFTSyk7XG4gICAgICAgICAgICBidWNrZXRzW3diaXRzXSA9IGJ1Y2tldHNbd2JpdHNdLmFkZChwb2ludHNbal0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNJID0gemVybzsgLy8gbm90IHVzaW5nIHRoaXMgd2lsbCBkbyBzbWFsbCBzcGVlZC11cCwgYnV0IHdpbGwgbG9zZSBjdFxuICAgICAgICAvLyBTa2lwIGZpcnN0IGJ1Y2tldCwgYmVjYXVzZSBpdCBpcyB6ZXJvXG4gICAgICAgIGZvciAobGV0IGogPSBidWNrZXRzLmxlbmd0aCAtIDEsIHN1bUkgPSB6ZXJvOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICBzdW1JID0gc3VtSS5hZGQoYnVja2V0c1tqXSk7XG4gICAgICAgICAgICByZXNJID0gcmVzSS5hZGQoc3VtSSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gc3VtLmFkZChyZXNJKTtcbiAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0uZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIFByZWNvbXB1dGVkIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB3aGljaCBtdWx0aXBsaWVzIHBvaW50cyB3aXRoIHNjYWFyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlY29tcHV0ZU1TTVVuc2FmZShjLCBmaWVsZE4sIHBvaW50cywgd2luZG93U2l6ZSkge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1hbmNlIEFuYWx5c2lzIG9mIFdpbmRvdy1iYXNlZCBQcmVjb21wdXRhdGlvblxuICAgICAqXG4gICAgICogQmFzZSBDYXNlICgyNTYtYml0IHNjYWxhciwgOC1iaXQgd2luZG93KTpcbiAgICAgKiAtIFN0YW5kYXJkIHByZWNvbXB1dGF0aW9uIHJlcXVpcmVzOlxuICAgICAqICAgLSAzMSBhZGRpdGlvbnMgcGVyIHNjYWxhciDDlyAyNTYgc2NhbGFycyA9IDcsOTM2IG9wc1xuICAgICAqICAgLSBQbHVzIDI1NSBzdW1tYXJ5IGFkZGl0aW9ucyA9IDgsMTkxIHRvdGFsIG9wc1xuICAgICAqICAgTm90ZTogU3VtbWFyeSBhZGRpdGlvbnMgY2FuIGJlIG9wdGltaXplZCB2aWEgYWNjdW11bGF0b3JcbiAgICAgKlxuICAgICAqIENodW5rZWQgUHJlY29tcHV0YXRpb24gQW5hbHlzaXM6XG4gICAgICogLSBVc2luZyAzMiBjaHVua3MgcmVxdWlyZXM6XG4gICAgICogICAtIDI1NSBhZGRpdGlvbnMgcGVyIGNodW5rXG4gICAgICogICAtIDI1NiBkb3VibGluZ3NcbiAgICAgKiAgIC0gVG90YWw6ICgyNTUgw5cgMzIpICsgMjU2ID0gOCw0MTYgb3BzXG4gICAgICpcbiAgICAgKiBNZW1vcnkgVXNhZ2UgQ29tcGFyaXNvbjpcbiAgICAgKiBXaW5kb3cgU2l6ZSB8IFN0YW5kYXJkIFBvaW50cyB8IENodW5rZWQgUG9pbnRzXG4gICAgICogLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLVxuICAgICAqICAgICA0LWJpdCAgIHwgICAgIDUyMCAgICAgICAgIHwgICAgICAxNVxuICAgICAqICAgICA4LWJpdCAgIHwgICAgNCwyMjQgICAgICAgIHwgICAgIDI1NVxuICAgICAqICAgIDEwLWJpdCAgIHwgICAxMyw4MjQgICAgICAgIHwgICAxLDAyM1xuICAgICAqICAgIDE2LWJpdCAgIHwgIDU1NywwNTYgICAgICAgIHwgIDY1LDUzNVxuICAgICAqXG4gICAgICogS2V5IEFkdmFudGFnZXM6XG4gICAgICogMS4gRW5hYmxlcyBsYXJnZXIgd2luZG93IHNpemVzIGR1ZSB0byByZWR1Y2VkIG1lbW9yeSBvdmVyaGVhZFxuICAgICAqIDIuIE1vcmUgZWZmaWNpZW50IGZvciBzbWFsbGVyIHNjYWxhciBjb3VudHM6XG4gICAgICogICAgLSAxNiBjaHVua3M6ICgxNiDDlyAyNTUpICsgMjU2ID0gNCwzMzYgb3BzXG4gICAgICogICAgLSB+MnggZmFzdGVyIHRoYW4gc3RhbmRhcmQgOCwxOTEgb3BzXG4gICAgICpcbiAgICAgKiBMaW1pdGF0aW9uczpcbiAgICAgKiAtIE5vdCBzdWl0YWJsZSBmb3IgcGxhaW4gcHJlY29tcHV0ZXMgKHJlcXVpcmVzIDI1NiBjb25zdGFudCBkb3VibGluZ3MpXG4gICAgICogLSBQZXJmb3JtYW5jZSBkZWdyYWRlcyB3aXRoIGxhcmdlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgLSBPcHRpbWFsIGZvciB+MjU2IHNjYWxhcnNcbiAgICAgKiAgIC0gTGVzcyBlZmZpY2llbnQgZm9yIDQwOTYrIHNjYWxhcnMgKFBpcHBlbmdlciBwcmVmZXJyZWQpXG4gICAgICovXG4gICAgdmFsaWRhdGVXKHdpbmRvd1NpemUsIGZpZWxkTi5CSVRTKTtcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3QgdGFibGVTaXplID0gMiAqKiB3aW5kb3dTaXplIC0gMTsgLy8gdGFibGUgc2l6ZSAod2l0aG91dCB6ZXJvKVxuICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChmaWVsZE4uQklUUyAvIHdpbmRvd1NpemUpOyAvLyBjaHVua3Mgb2YgaXRlbVxuICAgIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IHRhYmxlcyA9IHBvaW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBhY2MgPSBwOyBpIDwgdGFibGVTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGFjYyk7XG4gICAgICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIChzY2FsYXJzKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgICAgICBpZiAoc2NhbGFycy5sZW5ndGggPiBwb2ludHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIG11c3QgYmUgc21hbGxlciB0aGFuIGFycmF5IG9mIHBvaW50cycpO1xuICAgICAgICBsZXQgcmVzID0gemVybztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBkb3VibGUgaWYgYWNjdW11bGF0b3IgaXMgc3RpbGwgemVyby5cbiAgICAgICAgICAgIGlmIChyZXMgIT09IHplcm8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5kb3VibGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoY2h1bmtzICogd2luZG93U2l6ZSAtIChpICsgMSkgKiB3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2NhbGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIoKG4gPj4gc2hpZnRCeSkgJiBNQVNLKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHplcm8gc2NhbGFycyBjaHVua3NcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuYWRkKHRhYmxlc1tqXVtjdXJyIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.FpInvertBatch)(field, [xd, yd], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nfunction createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO))\n            return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...defaults, DST: defaults.DST, ...options });\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...defaults, DST: defaults.encodeDST, ...options });\n            return clear(map(u[0]));\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('expected array of bigints');\n            return clear(map(scalars));\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrRDtBQUM2QztBQUMvRjtBQUNBLGNBQWMsc0RBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckMsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVixJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXLENBQUMsc0RBQVc7QUFDdkMsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCLGFBQWEsc0RBQVc7QUFDeEIsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQSxnQ0FBZ0Msc0RBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLGlEQUFNO0FBQ1YsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxTQUFTLHNEQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZFQUE2RTtBQUNqRztBQUNBO0FBQ087QUFDUCxJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxtQ0FBbUM7QUFDL0MsSUFBSSxpREFBTTtBQUNWO0FBQ0EsMkNBQTJDLHNEQUFXO0FBQ3REO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsaUNBQWlDLDBEQUFhO0FBQzlDLG1DQUFtQztBQUNuQyxpREFBaUQ7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDRDQUE0QztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtEQUFrRDtBQUNoRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzPzAxNzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRnBJbnZlcnRCYXRjaCwgbW9kIH0gZnJvbSBcIi4vbW9kdWxhci5qc1wiO1xuaW1wb3J0IHsgYWJ5dGVzLCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcywgdmFsaWRhdGVPYmplY3QgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBhbnVtKHZhbHVlKTtcbiAgICBhbnVtKGxlbmd0aCk7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEkyT1NQIGlucHV0OiAnICsgdmFsdWUpO1xuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYW51bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0cy5cbiAqIFtSRkMgOTM4MCA1LjMuMV0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG1kOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuICogMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4gKiAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuICogICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4gKiBbUkZDIDkzODAgNS4zLjJdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjIpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuICogW1JGQyA5MzgwIDUuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjIpLlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhfRFNUKSA6IF9EU1Q7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgY29lZmYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4biwgeGQsIHluLCB5ZF0gPSBjb2VmZi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIC8vIDYuNi4zXG4gICAgICAgIC8vIEV4Y2VwdGlvbmFsIGNhc2VzIG9mIGlzb19tYXAgYXJlIGlucHV0cyB0aGF0IGNhdXNlIHRoZSBkZW5vbWluYXRvciBvZlxuICAgICAgICAvLyBlaXRoZXIgcmF0aW9uYWwgZnVuY3Rpb24gdG8gZXZhbHVhdGUgdG8gemVybzsgc3VjaCBjYXNlcyBNVVNUIHJldHVyblxuICAgICAgICAvLyB0aGUgaWRlbnRpdHkgcG9pbnQgb24gRS5cbiAgICAgICAgY29uc3QgW3hkX2ludiwgeWRfaW52XSA9IEZwSW52ZXJ0QmF0Y2goZmllbGQsIFt4ZCwgeWRdLCB0cnVlKTtcbiAgICAgICAgeCA9IGZpZWxkLm11bCh4biwgeGRfaW52KTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5tdWwoeW4sIHlkX2ludikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmYXVsdHMpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIGZ1bmN0aW9uIG1hcChudW0pIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZShudW0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXIoaW5pdGlhbCkge1xuICAgICAgICBjb25zdCBQID0gaW5pdGlhbC5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgIGlmIChQLmVxdWFscyhQb2ludC5aRVJPKSlcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPOyAvLyB6ZXJvIHdpbGwgdGhyb3cgaW4gYXNzZXJ0XG4gICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIFA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRlZmF1bHRzLFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZmF1bHRzLCBEU1Q6IGRlZmF1bHRzLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gbWFwKHVbMF0pO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBtYXAodVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gY2xlYXIodTAuYWRkKHUxKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZmF1bHRzLCBEU1Q6IGRlZmF1bHRzLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcihtYXAodVswXSkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTYW1lIGFzIGVuY29kZVRvQ3VydmUsIGJ1dCB3aXRob3V0IGhhc2hcbiAgICAgICAgbWFwVG9DdXJ2ZShzY2FsYXJzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgb2Ygc2NhbGFycylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcihtYXAoc2NhbGFycykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nfunction pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    // Throw if root^2 != n\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n    return root;\n}\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Initialization (precomputation).\n    if (P < BigInt(3))\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n    // P ≡ 3 (mod 4) => √n = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P ≡ 9 (mod 16) not implemented, see above\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nfunction FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nfunction FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUN5RjtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMseUNBQXlDO0FBQ3pDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBZSxRQUFRLDBEQUFlO0FBQzdEO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWUsc0JBQXNCLDBEQUFlO0FBQ3RFO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcz84OWVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbHMgZm9yIG1vZHVsYXIgZGl2aXNpb24gYW5kIGZpbml0ZSBmaWVsZHMuXG4gKiBBIGZpbml0ZSBmaWVsZCBvdmVyIDExIGlzIGludGVnZXIgbnVtYmVyIG9wZXJhdGlvbnMgYG1vZCAxMWAuXG4gKiBUaGVyZSBpcyBubyBkaXZpc2lvbjogaXQgaXMgcmVwbGFjZWQgYnkgbW9kdWxhciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBhbnVtYmVyIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBiaXRNYXNrLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKSwgXzNuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg0KSwgXzVuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg1KSwgXzhuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg4KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBUT0RPOiByZW1vdmUuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICByZXR1cm4gRnBQb3coRmllbGQobW9kdWxvKSwgbnVtLCBwb3dlcik7XG59XG4vKiogRG9lcyBgeF4oMl5wb3dlcilgIG1vZCBwLiBgcG93MigzMCwgNClgID09IGAzMF4oMl40KWAgKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG8uXG4gKiBJbXBsZW1lbnRlZCB1c2luZyBbRXVjbGlkZWFuIEdDRF0oaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS8pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgbm9uLXplcm8gbnVtYmVyJyk7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBtb2R1bHVzLCBnb3QgJyArIG1vZHVsbyk7XG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vLyBOb3QgYWxsIHJvb3RzIGFyZSBwb3NzaWJsZSEgRXhhbXBsZSB3aGljaCB3aWxsIHRocm93OlxuLy8gY29uc3QgTlVNID1cbi8vIG4gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4vLyBGcCA9IEZpZWxkKEJpZ0ludCgnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWInKSk7XG5mdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICBjb25zdCBwMWRpdjQgPSAoRnAuT1JERVIgKyBfMW4pIC8gXzRuO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAvLyBUaHJvdyBpZiByb290XjIgIT0gblxuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgIGNvbnN0IHA1ZGl2OCA9IChGcC5PUkRFUiAtIF81bikgLyBfOG47XG4gICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICBjb25zdCB2ID0gRnAucG93KG4yLCBwNWRpdjgpO1xuICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuLy8gVE9ETzogQ29tbWVudGVkLW91dCBmb3Igbm93LiBQcm92aWRlIHRlc3QgdmVjdG9ycy5cbi8vIFRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGV4dGVuc2lvbiBmaWVsZHMgRnAyLlxuLy8gVGhhdCBtZWFucyB3ZSBjYW4ndCB1c2Ugc3FydCAoYzEsIGMyLi4uKSBldmVuIGZvciBpbml0aWFsaXphdGlvbiBjb25zdGFudHMuXG4vLyBpZiAoUCAlIF8xNm4gPT09IF85bikgcmV0dXJuIHNxcnQ5bW9kMTY7XG4vLyAvLyBwcmV0dGllci1pZ25vcmVcbi8vIGZ1bmN0aW9uIHNxcnQ5bW9kMTY8VD4oRnA6IElGaWVsZDxUPiwgbjogVCwgcDdkaXYxNj86IGJpZ2ludCkge1xuLy8gICBpZiAocDdkaXYxNiA9PT0gdW5kZWZpbmVkKSBwN2RpdjE2ID0gKEZwLk9SREVSICsgQmlnSW50KDcpKSAvIF8xNm47XG4vLyAgIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWcoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4vLyAgIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4vLyAgIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWcoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbi8vICAgY29uc3QgYzQgPSBwN2RpdjE2OyAgICAgICAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuLy8gICBsZXQgdHYxID0gRnAucG93KG4sIGM0KTsgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbi8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4vLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuLy8gICBjb25zdCBlMSA9IEZwLmVxbChGcC5zcXIodHYyKSwgbik7ICAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4vLyAgIGNvbnN0IGUyID0gRnAuZXFsKEZwLnNxcih0djMpLCBuKTsgIC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbi8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4vLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuLy8gICBjb25zdCBlMyA9IEZwLmVxbChGcC5zcXIodHYyKSwgbik7ICAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4vLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4vLyB9XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBJbml0aWFsaXphdGlvbiAocHJlY29tcHV0YXRpb24pLlxuICAgIGlmIChQIDwgQmlnSW50KDMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxcnQgaXMgbm90IGRlZmluZWQgZm9yIHNtYWxsIGZpZWxkJyk7XG4gICAgLy8gRmFjdG9yIFAgLSAxID0gUSAqIDJeUywgd2hlcmUgUSBpcyBvZGRcbiAgICBsZXQgUSA9IFAgLSBfMW47XG4gICAgbGV0IFMgPSAwO1xuICAgIHdoaWxlIChRICUgXzJuID09PSBfMG4pIHtcbiAgICAgICAgUSAvPSBfMm47XG4gICAgICAgIFMrKztcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgcXVhZHJhdGljIG5vbi1yZXNpZHVlIFogPj0gMlxuICAgIGxldCBaID0gXzJuO1xuICAgIGNvbnN0IF9GcCA9IEZpZWxkKFApO1xuICAgIHdoaWxlIChGcExlZ2VuZHJlKF9GcCwgWikgPT09IDEpIHtcbiAgICAgICAgLy8gQmFzaWMgcHJpbWFsaXR5IHRlc3QgZm9yIFAuIEFmdGVyIHggaXRlcmF0aW9ucywgY2hhbmNlIG9mXG4gICAgICAgIC8vIG5vdCBmaW5kaW5nIHF1YWRyYXRpYyBub24tcmVzaWR1ZSBpcyAyXngsIHNvIDJeMTAwMC5cbiAgICAgICAgaWYgKForKyA+IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290OiBwcm9iYWJseSBub24tcHJpbWUgUCcpO1xuICAgIH1cbiAgICAvLyBGYXN0LXBhdGg7IHVzdWFsbHkgZG9uZSBiZWZvcmUgWiwgYnV0IHdlIGRvIFwicHJpbWFsaXR5IHRlc3RcIi5cbiAgICBpZiAoUyA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHNxcnQzbW9kNDtcbiAgICAvLyBTbG93LXBhdGhcbiAgICAvLyBUT0RPOiB0ZXN0IG9uIEZwMiBhbmQgb3RoZXJzXG4gICAgbGV0IGNjID0gX0ZwLnBvdyhaLCBRKTsgLy8gYyA9IHpeUVxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgaWYgKEZwLmlzMChuKSlcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAvLyBDaGVjayBpZiBuIGlzIGEgcXVhZHJhdGljIHJlc2lkdWUgdXNpbmcgTGVnZW5kcmUgc3ltYm9sXG4gICAgICAgIGlmIChGcExlZ2VuZHJlKEZwLCBuKSAhPT0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMgZm9yIHRoZSBtYWluIGxvb3BcbiAgICAgICAgbGV0IE0gPSBTO1xuICAgICAgICBsZXQgYyA9IEZwLm11bChGcC5PTkUsIGNjKTsgLy8gYyA9IHpeUSwgbW92ZSBjYyBmcm9tIGZpZWxkIF9GcCBpbnRvIGZpZWxkIEZwXG4gICAgICAgIGxldCB0ID0gRnAucG93KG4sIFEpOyAvLyB0ID0gbl5RLCBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIGxldCBSID0gRnAucG93KG4sIFExZGl2Mik7IC8vIFIgPSBuXigoUSsxKS8yKSwgZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIC8vIE1haW4gbG9vcFxuICAgICAgICAvLyB3aGlsZSB0ICE9IDFcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwodCwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmlzMCh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaWYgdD0wIHJldHVybiBSPTBcbiAgICAgICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHNtYWxsZXN0IGkgPj0gMSBzdWNoIHRoYXQgdF4oMl5pKSDiiaEgMSAobW9kIFApXG4gICAgICAgICAgICBsZXQgdF90bXAgPSBGcC5zcXIodCk7IC8vIHReKDJeMSlcbiAgICAgICAgICAgIHdoaWxlICghRnAuZXFsKHRfdG1wLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHRfdG1wID0gRnAuc3FyKHRfdG1wKTsgLy8gdF4oMl4yKS4uLlxuICAgICAgICAgICAgICAgIGlmIChpID09PSBNKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGV4cG9uZW50IGZvciBiOiAyXihNIC0gaSAtIDEpXG4gICAgICAgICAgICBjb25zdCBleHBvbmVudCA9IF8xbiA8PCBCaWdJbnQoTSAtIGkgLSAxKTsgLy8gYmlnaW50IGlzIGltcG9ydGFudFxuICAgICAgICAgICAgY29uc3QgYiA9IEZwLnBvdyhjLCBleHBvbmVudCk7IC8vIGIgPSAyXihNIC0gaSAtIDEpXG4gICAgICAgICAgICAvLyBVcGRhdGUgdmFyaWFibGVzXG4gICAgICAgICAgICBNID0gaTtcbiAgICAgICAgICAgIGMgPSBGcC5zcXIoYik7IC8vIGMgPSBiXjJcbiAgICAgICAgICAgIHQgPSBGcC5tdWwodCwgYyk7IC8vIHQgPSAodCAqIGJeMilcbiAgICAgICAgICAgIFIgPSBGcC5tdWwoUiwgYik7IC8vIFIgPSBSKmJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUjtcbiAgICB9O1xufVxuLyoqXG4gKiBTcXVhcmUgcm9vdCBmb3IgYSBmaW5pdGUgZmllbGQuIFdpbGwgdHJ5IG9wdGltaXplZCB2ZXJzaW9ucyBmaXJzdDpcbiAqXG4gKiAxLiBQIOKJoSAzIChtb2QgNClcbiAqIDIuIFAg4omhIDUgKG1vZCA4KVxuICogMy4gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gKlxuICogRGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICogRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIFAg4omhIDMgKG1vZCA0KSA9PiDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKVxuICAgICAgICByZXR1cm4gc3FydDNtb2Q0O1xuICAgIC8vIFAg4omhIDUgKG1vZCA4KSA9PiBBdGtpbiBhbGdvcml0aG0sIHBhZ2UgMTAgb2YgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bilcbiAgICAgICAgcmV0dXJuIHNxcnQ1bW9kODtcbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpIG5vdCBpbXBsZW1lbnRlZCwgc2VlIGFib3ZlXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KEZwLCBudW0sIHBvd2VyKSB7XG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZXhwb25lbnQsIG5lZ2F0aXZlcyB1bnN1cHBvcnRlZCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gRnAuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gRnAuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gRnAubXVsKHAsIGQpO1xuICAgICAgICBkID0gRnAuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogRXhjZXB0aW9uLWZyZWUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGZvciAwIGVsZW1lbnRzLlxuICogQHBhcmFtIHBhc3NaZXJvIG1hcCAwIHRvIDAgKGluc3RlYWQgb2YgdW5kZWZpbmVkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChGcCwgbnVtcywgcGFzc1plcm8gPSBmYWxzZSkge1xuICAgIGNvbnN0IGludmVydGVkID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKS5maWxsKHBhc3NaZXJvID8gRnAuWkVSTyA6IHVuZGVmaW5lZCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IG11bHRpcGxpZWRBY2MgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKEZwLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgaW52ZXJ0ZWRbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBGcC5tdWwoYWNjLCBudW0pO1xuICAgIH0sIEZwLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkQWNjID0gRnAuaW52KG11bHRpcGxpZWRBY2MpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoRnAuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBpbnZlcnRlZFtpXSA9IEZwLm11bChhY2MsIGludmVydGVkW2ldKTtcbiAgICAgICAgcmV0dXJuIEZwLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWRBY2MpO1xuICAgIHJldHVybiBpbnZlcnRlZDtcbn1cbi8vIFRPRE86IHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KEZwLCBsaHMsIHJocykge1xuICAgIHJldHVybiBGcC5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIEZwLk9SREVSKSA6IEZwLmludihyaHMpKTtcbn1cbi8qKlxuICogTGVnZW5kcmUgc3ltYm9sLlxuICogTGVnZW5kcmUgY29uc3RhbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcClcbiAqIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gKlxuICogKiAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIHJlc2lkdWVcbiAqICogKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgbm9uIHJlc2lkdWVcbiAqICogKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwTGVnZW5kcmUoRnAsIG4pIHtcbiAgICAvLyBXZSBjYW4gdXNlIDNyZCBhcmd1bWVudCBhcyBvcHRpb25hbCBjYWNoZSBvZiB0aGlzIHZhbHVlXG4gICAgLy8gYnV0IHNlZW1zIHVubmVlZGVkIGZvciBub3cuIFRoZSBvcGVyYXRpb24gaXMgdmVyeSBmYXN0LlxuICAgIGNvbnN0IHAxbW9kMiA9IChGcC5PUkRFUiAtIF8xbikgLyBfMm47XG4gICAgY29uc3QgcG93ZXJlZCA9IEZwLnBvdyhuLCBwMW1vZDIpO1xuICAgIGNvbnN0IHllcyA9IEZwLmVxbChwb3dlcmVkLCBGcC5PTkUpO1xuICAgIGNvbnN0IHplcm8gPSBGcC5lcWwocG93ZXJlZCwgRnAuWkVSTyk7XG4gICAgY29uc3Qgbm8gPSBGcC5lcWwocG93ZXJlZCwgRnAubmVnKEZwLk9ORSkpO1xuICAgIGlmICgheWVzICYmICF6ZXJvICYmICFubylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIExlZ2VuZHJlIHN5bWJvbCByZXN1bHQnKTtcbiAgICByZXR1cm4geWVzID8gMSA6IHplcm8gPyAwIDogLTE7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKEZwLCBuKSB7XG4gICAgY29uc3QgbCA9IEZwTGVnZW5kcmUoRnAsIG4pO1xuICAgIHJldHVybiBsID09PSAxO1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgaWYgKG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZClcbiAgICAgICAgYW51bWJlcihuQml0TGVuZ3RoKTtcbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogRnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIFNlY3VyaXR5IG5vdGU6IG9wZXJhdGlvbnMgZG9uJ3QgY2hlY2sgJ2lzVmFsaWQnIGZvciBhbGwgZWxlbWVudHMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsXG4gKiBpdCBpcyBjYWxsZXIgcmVzcG9uc2liaWxpdHkgdG8gY2hlY2sgdGhpcy5cbiAqIFRoaXMgaXMgbG93LWxldmVsIGNvZGUsIHBsZWFzZSBtYWtlIHN1cmUgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZDogZXhwZWN0ZWQgT1JERVIgPiAwLCBnb3QgJyArIE9SREVSKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXMnKTtcbiAgICBsZXQgc3FydFA7IC8vIGNhY2hlZCBzcXJ0UFxuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIGlzTEUsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAnICsgdHlwZW9mIG51bSk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHxcbiAgICAgICAgICAgICgobikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc3FydFApXG4gICAgICAgICAgICAgICAgICAgIHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FydFAoZiwgbik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZC5mcm9tQnl0ZXM6IGV4cGVjdGVkICcgKyBCWVRFUyArICcgYnl0ZXMsIGdvdCAnICsgYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRPRE86IHdlIGRvbid0IG5lZWQgaXQgaGVyZSwgbW92ZSBvdXQgdG8gc2VwYXJhdGUgZm5cbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gV2UgY2FuJ3QgbW92ZSB0aGlzIG91dCBiZWNhdXNlIEZwNiwgRnAxMiBpbXBsZW1lbnQgaXRcbiAgICAgICAgLy8gYW5kIGl0J3MgdW5jbGVhciB3aGF0IHRvIHJldHVybiBpbiB0aGVyZS5cbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIGBtYXBLZXlUb0ZpZWxkYCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBoYXNoTGVuKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBsZW4pO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJCRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_1n << BigInt(n)) - _1n;\n// DRBG\nconst u8n = (len) => new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDTztBQUNQO0FBQ0EsMENBQTBDO0FBQzFDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDbkQsOERBQThEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxXQUFXLFlBQVksSUFBSTtBQUNwRCxrQ0FBa0Msb0JBQW9CLElBQUksYUFBYSxHQUFHO0FBQzFFO0FBQ0Esa0NBQWtDLFVBQVUsSUFBSSxTQUFTO0FBQ3pELGtDQUFrQyxvQkFBb0IsSUFBSSxTQUFTO0FBQ25FLGtDQUFrQywyQkFBMkI7QUFDN0Qsa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcz9iYjhlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGV4LCBieXRlcyBhbmQgbnVtYmVyIHV0aWxpdGllcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXMoaXRlbSkge1xuICAgIGlmICghaXNCeXRlcyhpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWJvb2wodGl0bGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIGJvb2xlYW4gZXhwZWN0ZWQsIGdvdCAnICsgdmFsdWUpO1xufVxuLy8gVXNlZCBpbiB3ZWllcnN0cmFzcywgZGVyXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/ICcwJyArIGhleCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICByZXR1cm4gaGV4ID09PSAnJyA/IF8wbiA6IEJpZ0ludCgnMHgnICsgaGV4KTsgLy8gQmlnIEVuZGlhblxufVxuLy8gQnVpbHQtaW4gaGV4IGNvbnZlcnNpb24gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc191aW50OGFycmF5X2Zyb21oZXhcbmNvbnN0IGhhc0hleEJ1aWx0aW4gPSBcbi8vIEB0cy1pZ25vcmVcbnR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvSGV4ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbic7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQ29udmVydCBieXRlIGFycmF5IHRvIGhleCBzdHJpbmcuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXkuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb21IZXgoaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjYXVzZTogJyArIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXMoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBvZiBsZW5ndGggJyArIGV4cGVjdGVkTGVuZ3RoICsgJyBleHBlY3RlZCwgZ290ICcgKyBsZW4pO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vLyBJcyBwb3NpdGl2ZSBiaWdpbnRcbmNvbnN0IGlzUG9zQmlnID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiBfMG4gPD0gbjtcbmV4cG9ydCBmdW5jdGlvbiBpblJhbmdlKG4sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGlzUG9zQmlnKG4pICYmIGlzUG9zQmlnKG1pbikgJiYgaXNQb3NCaWcobWF4KSAmJiBtaW4gPD0gbiAmJiBuIDwgbWF4O1xufVxuLyoqXG4gKiBBc3NlcnRzIG1pbiA8PSBuIDwgbWF4LiBOT1RFOiBJdCdzIDwgbWF4IGFuZCBub3QgPD0gbWF4LlxuICogQGV4YW1wbGVcbiAqIGFJblJhbmdlKCd4JywgeCwgMW4sIDI1Nm4pOyAvLyB3b3VsZCBhc3N1bWUgeCBpcyBpbiAoMW4uLjI1NW4pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhSW5SYW5nZSh0aXRsZSwgbiwgbWluLCBtYXgpIHtcbiAgICAvLyBXaHkgbWluIDw9IG4gPCBtYXggYW5kIG5vdCBhIChtaW4gPCBuIDwgbWF4KSBPUiBiIChtaW4gPD0gbiA8PSBtYXgpP1xuICAgIC8vIGNvbnNpZGVyIFA9MjU2biwgbWluPTBuLCBtYXg9UFxuICAgIC8vIC0gYSBmb3IgbWluPTAgd291bGQgcmVxdWlyZSAtMTogICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAtMW4sIFApYFxuICAgIC8vIC0gYiB3b3VsZCBjb21tb25seSByZXF1aXJlIHN1YnRyYWN0aW9uOiAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUCAtIDFuKWBcbiAgICAvLyAtIG91ciB3YXkgaXMgdGhlIGNsZWFuZXN0OiAgICAgICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgMG4sIFApXG4gICAgaWYgKCFpblJhbmdlKG4sIG1pbiwgbWF4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCAnICsgdGl0bGUgKyAnOiAnICsgbWluICsgJyA8PSBuIDwgJyArIG1heCArICcsIGdvdCAnICsgbik7XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKiBUT0RPOiBtZXJnZSB3aXRoIG5MZW5ndGggaW4gbW9kdWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8xbiA8PCBCaWdJbnQobikpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oMCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXModmFsKSxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsaWRhdG9yIGZ1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyYW0gJyArIFN0cmluZyhmaWVsZE5hbWUpICsgJyBpcyBpbnZhbGlkLiBFeHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgdmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8qKlxuICogdGhyb3dzIG5vdCBpbXBsZW1lbnRlZCBlcnJvclxuICovXG5leHBvcnQgY29uc3Qgbm90SW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG4vKipcbiAqIE1lbW9pemVzIChjYWNoZXMpIGNvbXB1dGF0aW9uIHJlc3VsdC5cbiAqIFVzZXMgV2Vha01hcDogdGhlIHZhbHVlIGlzIGdvaW5nIGF1dG8tY2xlYW5lZCBieSBHQyBhZnRlciBsYXN0IHJlZmVyZW5jZSBpcyByZW1vdmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZWQoZm4pIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiAoYXJnLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG1hcC5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBmbihhcmcsIC4uLmFyZ3MpO1xuICAgICAgICBtYXAuc2V0KGFyZywgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   DERErr: () => (/* binding */ DERErr),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite field of prime characteristic P; may be complex (Fp2). Arithmetics is done in field\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * Gx: Base point (x, y) aka generator point. Gx = x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\n\n// prettier-ignore\n\n// prettier-ignore\n\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowInfinityPoint: 'boolean',\n        allowedPrivateKeyLengths: 'array',\n        clearCofactor: 'function',\n        fromBytes: 'function',\n        isTorsionFree: 'function',\n        toBytes: 'function',\n        wrapPrivateKey: 'boolean',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endo: CURVE.a must be 0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nclass DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)((len.length / 2) | 128) : '';\n            const t = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\nfunction numToSizedHex(num, size) {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, size));\n}\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x² * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x³ + a * x + b\n    }\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y² = x³ + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant Δ part should be non-zero: 4a³ + 27b² != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(key))\n                key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(num, N); // disabled by default, enabled for BLS\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z) ∋ (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (X, Y, Z) ∋ (x=X/Z, y=Y/Z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py) || Fp.is0(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(Fp, points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            /** See docs for {@link EndomorphismOpts} */\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.toRawBytes(isCompressed));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    const { endo, nBitLength } = CURVE;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF)(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(tail);\n                if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('r', r, _1n, CURVE_ORDER); // r in [1..N]\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('s', s, _1n, CURVE_ORDER); // s in [1..N]\n            this.r = r;\n            this.s = s;\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        /**\n         * @todo remove\n         * @deprecated\n         */\n        assertValidity() { }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig(this);\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(this.toCompactHex());\n        }\n        toCompactHex() {\n            const l = nByteLength;\n            return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength)(CURVE.n);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        if (typeof item === 'bigint')\n            return false;\n        if (item instanceof Point)\n            return true;\n        const arr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('key', item);\n        const len = arr.length;\n        const fpl = Fp.BYTES;\n        const compLen = fpl + 1; // e.g. 33 for 32\n        const uncompLen = 2 * fpl + 1; // e.g. 65 for 32\n        if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {\n            return undefined;\n        }\n        else {\n            return len === compLen || len === uncompLen;\n        }\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicB) === false)\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)('num < 2^' + nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg)(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RDtBQUM1RDtBQUNrSDtBQUNsSDtBQUMyTjtBQUMzTjtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4REFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhEQUFtQjtBQUM5RCxzQkFBc0IsOERBQW1CO0FBQ3pDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0Esc0JBQXNCLDhEQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBZTtBQUNsQyxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLHFCQUFxQixzREFBVztBQUNoQyxnQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLHFEQUFVLENBQUMsMERBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSxLQUFLLFNBQVM7QUFDMUIsZUFBZSxrREFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQVc7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQyxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQXVFO0FBQ3ZGO0FBQ0EsZ0JBQWdCLGtEQUFPO0FBQ3ZCLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwREFBZSxDQUFDLHNEQUFXO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0RBQUcsVUFBVTtBQUMvQixRQUFRLG1EQUFRLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtREFBUTtBQUNqQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsbURBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNEQUFXO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0Msb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0MsMERBQTBEO0FBQzFELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0IseUJBQXlCO0FBQzdDLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakMsWUFBWSxtREFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3RELGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDLFlBQVksbURBQVE7QUFDcEIsNkJBQTZCO0FBQzdCLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DLHNCQUFzQixpQkFBaUI7QUFDdkMsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFLO0FBQ2pCLG1CQUFtQixxREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELFlBQVksbUJBQW1CO0FBQy9CLGlCQUFpQiwrQ0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSwrQkFBK0Isc0NBQXNDO0FBQ3JFO0FBQ087QUFDUDtBQUNBLFlBQVksOENBQThDO0FBQzFELHdDQUF3QztBQUN4Qyw4Q0FBOEM7QUFDOUM7QUFDQSxlQUFlLGdEQUFHO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlLG1EQUFNO0FBQ3JCO0FBQ0EsWUFBWSwyRkFBMkY7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0RBQVc7QUFDbkMsWUFBWSxnREFBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFlO0FBQ3pDLHFCQUFxQixrREFBTztBQUM1QjtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwREFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBUSw0QkFBNEI7QUFDaEQsWUFBWSxtREFBUSw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxZQUFZLHNEQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLG9DQUFvQyxzREFBVyx1QkFBdUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsc0NBQXNDO0FBQ3RDLHFDQUFxQztBQUNyQyxrRUFBa0U7QUFDbEU7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZEQUFnQjtBQUMzQyxtQkFBbUIsMkRBQWM7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQVc7QUFDL0I7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwREFBZSxTQUFTO0FBQ2hELHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsdUJBQXVCLGtEQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBUTtBQUNoQjtBQUNBLGVBQWUsMERBQWU7QUFDOUI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLGNBQWMsbUNBQW1DLFFBQVE7QUFDekQ7QUFDQSx5QkFBeUI7QUFDekIsa0JBQWtCLHNEQUFXO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUsMEJBQTBCLHNEQUFXLHNCQUFzQjtBQUMzRDtBQUNBLHFCQUFxQixzREFBVyxlQUFlO0FBQy9DLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSx3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLHlEQUF5RDtBQUN6RCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWMsbUNBQW1DO0FBQ2pFO0FBQ0EscUJBQXFCLHlEQUFjO0FBQ25DLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0Isb0JBQW9CLHNEQUFXO0FBQy9CLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtEQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QiwwQ0FBMEM7QUFDMUMsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQSxrQkFBa0I7QUFDbEIsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsNENBQTRDO0FBQzVDO0FBQ0Esc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsb0NBQW9DO0FBQ3BDLCtCQUErQjtBQUMvQix3Q0FBd0M7QUFDeEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEMsK0JBQStCO0FBQy9CLHNDQUFzQztBQUN0Qyx5Q0FBeUM7QUFDekMsNkNBQTZDO0FBQzdDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLHlDQUF5QztBQUN6QywwQ0FBMEM7QUFDMUM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHVDQUF1QztBQUN2QztBQUNBLGlDQUFpQztBQUNqQyxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxrQ0FBa0M7QUFDbEMsdUNBQXVDO0FBQ3ZDLCtDQUErQyxrQkFBa0I7QUFDakUseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQyxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLDBEQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG1DQUFtQztBQUNuQywyQkFBMkI7QUFDM0IsZ0NBQWdDO0FBQ2hDLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUVBQW1FO0FBQ25FLG1DQUFtQztBQUNuQywyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLG1DQUFtQztBQUNuQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxtQ0FBbUM7QUFDbkMsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5QixnQkFBZ0IsaUJBQWlCLHVCQUF1QjtBQUN4RCw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLHNDQUFzQztBQUN0Qyx3Q0FBd0M7QUFDeEMsZ0RBQWdEO0FBQ2hELHVDQUF1QztBQUN2Qyx3QkFBd0IsMERBQWE7QUFDckMsZ0NBQWdDO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanM/NWQxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlIG1ldGhvZHMuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGIuXG4gKlxuICogIyMjIFBhcmFtZXRlcnNcbiAqXG4gKiBUbyBpbml0aWFsaXplIGEgd2VpZXJzdHJhc3MgY3VydmUsIG9uZSBuZWVkcyB0byBwYXNzIGZvbGxvd2luZyBwYXJhbXM6XG4gKlxuICogKiBhOiBmb3JtdWxhIHBhcmFtXG4gKiAqIGI6IGZvcm11bGEgcGFyYW1cbiAqICogRnA6IGZpbml0ZSBmaWVsZCBvZiBwcmltZSBjaGFyYWN0ZXJpc3RpYyBQOyBtYXkgYmUgY29tcGxleCAoRnAyKS4gQXJpdGhtZXRpY3MgaXMgZG9uZSBpbiBmaWVsZFxuICogKiBuOiBvcmRlciBvZiBwcmltZSBzdWJncm91cCBhLmsuYSB0b3RhbCBhbW91bnQgb2YgdmFsaWQgY3VydmUgcG9pbnRzXG4gKiAqIEd4OiBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50LiBHeCA9IHggY29vcmRpbmF0ZVxuICogKiBHeTogLi4ueSBjb29yZGluYXRlXG4gKiAqIGg6IGNvZmFjdG9yLCB1c3VhbGx5IDEuIGgqbiA9IGN1cnZlIGdyb3VwIG9yZGVyIChuIGlzIG9ubHkgc3ViZ3JvdXAgb3JkZXIpXG4gKiAqIGxvd1M6IHdoZXRoZXIgdG8gZW5hYmxlIChkZWZhdWx0KSBvciBkaXNhYmxlIFwibG93LXNcIiBub24tbWFsbGVhYmxlIHNpZ25hdHVyZXNcbiAqXG4gKiAjIyMgRGVzaWduIHJhdGlvbmFsZSBmb3IgdHlwZXNcbiAqXG4gKiAqIEludGVyYWN0aW9uIGJldHdlZW4gY2xhc3NlcyBmcm9tIGRpZmZlcmVudCBjdXJ2ZXMgc2hvdWxkIGZhaWw6XG4gKiAgIGBrMjU2LlBvaW50LkJBU0UuYWRkKHAyNTYuUG9pbnQuQkFTRSlgXG4gKiAqIEZvciB0aGlzIHB1cnBvc2Ugd2Ugd2FudCB0byB1c2UgYGluc3RhbmNlb2ZgIG9wZXJhdG9yLCB3aGljaCBpcyBmYXN0IGFuZCB3b3JrcyBkdXJpbmcgcnVudGltZVxuICogKiBEaWZmZXJlbnQgY2FsbHMgb2YgYGN1cnZlKClgIHdvdWxkIHJldHVybiBkaWZmZXJlbnQgY2xhc3NlcyAtXG4gKiAgIGBjdXJ2ZShwYXJhbXMpICE9PSBjdXJ2ZShwYXJhbXMpYDogaWYgc29tZWJvZHkgZGVjaWRlZCB0byBtb25rZXktcGF0Y2ggdGhlaXIgY3VydmUsXG4gKiAgIGl0IHdvbid0IGFmZmVjdCBvdGhlcnNcbiAqXG4gKiBUeXBlU2NyaXB0IGNhbid0IGluZmVyIHR5cGVzIGZvciBjbGFzc2VzIGNyZWF0ZWQgaW5zaWRlIGEgZnVuY3Rpb24uIENsYXNzZXMgaXMgb25lIGluc3RhbmNlXG4gKiBvZiBub21pbmF0aXZlIHR5cGVzIGluIFR5cGVTY3JpcHQgYW5kIGludGVyZmFjZXMgb25seSBjaGVjayBmb3Igc2hhcGUsIHNvIGl0J3MgaGFyZCB0byBjcmVhdGVcbiAqIHVuaXF1ZSB0eXBlIGZvciBldmVyeSBmdW5jdGlvbiBjYWxsLlxuICpcbiAqIFdlIGNhbiB1c2UgZ2VuZXJpYyB0eXBlcyB2aWEgc29tZSBwYXJhbSwgbGlrZSBjdXJ2ZSBvcHRzLCBidXQgdGhhdCB3b3VsZDpcbiAqICAgICAxLiBFbmFibGUgaW50ZXJhY3Rpb24gYmV0d2VlbiBgY3VydmUocGFyYW1zKWAgYW5kIGBjdXJ2ZShwYXJhbXMpYCAoY3VydmVzIG9mIHNhbWUgcGFyYW1zKVxuICogICAgIHdoaWNoIGlzIGhhcmQgdG8gZGVidWcuXG4gKiAgICAgMi4gUGFyYW1zIGNhbiBiZSBnZW5lcmljIGFuZCB3ZSBjYW4ndCBlbmZvcmNlIHRoZW0gdG8gYmUgY29uc3RhbnQgdmFsdWU6XG4gKiAgICAgaWYgc29tZWJvZHkgY3JlYXRlcyBjdXJ2ZSBmcm9tIG5vbi1jb25zdGFudCBwYXJhbXMsXG4gKiAgICAgaXQgd291bGQgYmUgYWxsb3dlZCB0byBpbnRlcmFjdCB3aXRoIG90aGVyIGN1cnZlcyB3aXRoIG5vbi1jb25zdGFudCBwYXJhbXNcbiAqXG4gKiBAdG9kbyBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9yZWxlYXNlLW5vdGVzL3R5cGVzY3JpcHQtMi03Lmh0bWwjdW5pcXVlLXN5bWJvbFxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IHBpcHBlbmdlciwgdmFsaWRhdGVCYXNpYywgd05BRiB9IGZyb20gXCIuL2N1cnZlLmpzXCI7XG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IEZpZWxkLCBGcEludmVydEJhdGNoLCBnZXRNaW5IYXNoTGVuZ3RoLCBpbnZlcnQsIG1hcEhhc2hUb0ZpZWxkLCBtb2QsIHZhbGlkYXRlRmllbGQgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IGFJblJhbmdlLCBhYm9vbCwgYml0TWFzaywgYnl0ZXNUb0hleCwgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgY3JlYXRlSG1hY0RyYmcsIGVuc3VyZUJ5dGVzLCBoZXhUb0J5dGVzLCBpblJhbmdlLCBpc0J5dGVzLCBtZW1vaXplZCwgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0hleFVucGFkZGVkLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cykge1xuICAgIGlmIChvcHRzLmxvd1MgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYWJvb2woJ2xvd1MnLCBvcHRzLmxvd1MpO1xuICAgIGlmIChvcHRzLnByZWhhc2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgYWJvb2woJ3ByZWhhc2gnLCBvcHRzLnByZWhhc2gpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbmRvOiBDVVJWRS5hIG11c3QgYmUgMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG86IGV4cGVjdGVkIFwiYmV0YVwiOiBiaWdpbnQgYW5kIFwic3BsaXRTY2FsYXJcIjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG5leHBvcnQgY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICBzdXBlcihtKTtcbiAgICB9XG59XG4vKipcbiAqIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXMuIEFTTiBpcyB2ZXJ5IGNvbXBsZXggJiBmcmFnaWxlLiBGb3JtYXQ6XG4gKlxuICogICAgIFsweDMwIChTRVFVRU5DRSksIGJ5dGVsZW5ndGgsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFIsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFNdXG4gKlxuICogRG9jczogaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcvZG9jcy9hLXdhcm0td2VsY29tZS10by1hc24xLWFuZC1kZXIvLCBodHRwczovL2x1Y2EubnRvcC5vcmcvVGVhY2hpbmcvQXBwdW50aS9hc24xLmh0bWxcbiAqL1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IERFUkVycixcbiAgICAvLyBCYXNpYyBidWlsZGluZyBibG9jayBpcyBUTFYgKFRhZy1MZW5ndGgtVmFsdWUpXG4gICAgX3Rsdjoge1xuICAgICAgICBlbmNvZGU6ICh0YWcsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHdyb25nIHRhZycpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogdW5wYWRkZWQgZGF0YScpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQoZGF0YUxlbik7XG4gICAgICAgICAgICBpZiAoKGxlbi5sZW5ndGggLyAyKSAmIDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnJyk7XG4gICAgICAgICAgICAvLyBsZW5ndGggb2YgbGVuZ3RoIHdpdGggbG9uZyBmb3JtIGZsYWdcbiAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGRhdGFMZW4gPiAxMjcgPyBudW1iZXJUb0hleFVucGFkZGVkKChsZW4ubGVuZ3RoIC8gMikgfCAxMjgpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0ID0gbnVtYmVyVG9IZXhVbnBhZGRlZCh0YWcpO1xuICAgICAgICAgICAgcmV0dXJuIHQgKyBsZW5MZW4gKyBsZW4gKyBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcbiAgICAgICAgZGVjb2RlKHRhZywgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVtwb3MrK10gIT09IHRhZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdGx2Jyk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgaXNMb25nID0gISEoZmlyc3QgJiAxMjgpOyAvLyBGaXJzdCBiaXQgb2YgZmlyc3QgbGVuZ3RoIGJ5dGUgaXMgZmxhZyBmb3Igc2hvcnQvbG9uZyBmb3JtXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICghaXNMb25nKVxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGZpcnN0O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTG9uZyBmb3JtOiBbbG9uZ0ZsYWcoMWJpdCksIGxlbmd0aExlbmd0aCg3Yml0KSwgbGVuZ3RoIChCRSldXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuTGVuID0gZmlyc3QgJiAxMjc7XG4gICAgICAgICAgICAgICAgaWYgKCFsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbkxlbiA+IDQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBieXRlIGxlbmd0aCBpcyB0b28gYmlnJyk7IC8vIHRoaXMgd2lsbCBvdmVyZmxvdyB1MzIgaW4ganNcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5MZW4pO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhCeXRlcy5sZW5ndGggIT09IGxlbkxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXNbMF0gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiB6ZXJvIGxlZnRtb3N0IGJ5dGUnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgbGVuZ3RoQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggPDwgOCkgfCBiO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW5MZW47XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDEyOClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IG5vdCBtaW5pbWFsIGVuY29kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2ID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodi5sZW5ndGggIT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdmFsdWUgbGVuZ3RoJyk7XG4gICAgICAgICAgICByZXR1cm4geyB2LCBsOiBkYXRhLnN1YmFycmF5KHBvcyArIGxlbmd0aCkgfTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICBfaW50OiB7XG4gICAgICAgIGVuY29kZShudW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAobnVtIDwgXzBuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnRlZ2VyOiBuZWdhdGl2ZSBpbnRlZ2VycyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGxldCBoZXggPSBudW1iZXJUb0hleFVucGFkZGVkKG51bSk7XG4gICAgICAgICAgICAvLyBQYWQgd2l0aCB6ZXJvIGJ5dGUgaWYgbmVnYXRpdmUgZmxhZyBpcyBwcmVzZW50XG4gICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KGhleFswXSwgMTYpICYgMGIxMDAwKVxuICAgICAgICAgICAgICAgIGhleCA9ICcwMCcgKyBoZXg7XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3VuZXhwZWN0ZWQgREVSIHBhcnNpbmcgYXNzZXJ0aW9uOiB1bnBhZGRlZCBoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiBoZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSA9PT0gMHgwMCAmJiAhKGRhdGFbMV0gJiAxMjgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvTnVtYmVyQkUoZGF0YSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSwgX2ludDogaW50LCBfdGx2OiB0bHYgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBoZXgpO1xuICAgICAgICBjb25zdCB7IHY6IHNlcUJ5dGVzLCBsOiBzZXFMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgzMCwgZGF0YSk7XG4gICAgICAgIGlmIChzZXFMZWZ0Qnl0ZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgY29uc3QgeyB2OiByQnl0ZXMsIGw6IHJMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgc2VxQnl0ZXMpO1xuICAgICAgICBjb25zdCB7IHY6IHNCeXRlcywgbDogc0xlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDAyLCByTGVmdEJ5dGVzKTtcbiAgICAgICAgaWYgKHNMZWZ0Qnl0ZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgcjogaW50LmRlY29kZShyQnl0ZXMpLCBzOiBpbnQuZGVjb2RlKHNCeXRlcykgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIGNvbnN0IHsgX3RsdjogdGx2LCBfaW50OiBpbnQgfSA9IERFUjtcbiAgICAgICAgY29uc3QgcnMgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnIpKTtcbiAgICAgICAgY29uc3Qgc3MgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnMpKTtcbiAgICAgICAgY29uc3Qgc2VxID0gcnMgKyBzcztcbiAgICAgICAgcmV0dXJuIHRsdi5lbmNvZGUoMHgzMCwgc2VxKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIG51bVRvU2l6ZWRIZXgobnVtLCBzaXplKSB7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgobnVtYmVyVG9CeXRlc0JFKG51bSwgc2l6ZSkpO1xufVxuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCBGbiA9IEZpZWxkKENVUlZFLm4sIENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhLiBUYWtlcyB4LCByZXR1cm5zIHnCsi5cbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geMKyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHjCsyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkWFkoeCwgeSkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgcmV0dXJuIEZwLmVxbChsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFRlc3QgMTogZXF1YXRpb24gecKyID0geMKzICsgYXggKyBiIHNob3VsZCB3b3JrIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgaWYgKCFpc1ZhbGlkWFkoQ1VSVkUuR3gsIENVUlZFLkd5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY3VydmUgcGFyYW1zOiBnZW5lcmF0b3IgcG9pbnQnKTtcbiAgICAvLyBUZXN0IDI6IGRpc2NyaW1pbmFudCDOlCBwYXJ0IHNob3VsZCBiZSBub24temVybzogNGHCsyArIDI3YsKyICE9IDAuXG4gICAgLy8gR3VhcmFudGVlcyBjdXJ2ZSBpcyBnZW51cy0xLCBzbW9vdGggKG5vbi1zaW5ndWxhcikuXG4gICAgY29uc3QgXzRhMyA9IEZwLm11bChGcC5wb3coQ1VSVkUuYSwgXzNuKSwgXzRuKTtcbiAgICBjb25zdCBfMjdiMiA9IEZwLm11bChGcC5zcXIoQ1VSVkUuYiksIEJpZ0ludCgyNykpO1xuICAgIGlmIChGcC5pczAoRnAuYWRkKF80YTMsIF8yN2IyKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGN1cnZlIHBhcmFtczogYSBvciBiJyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIGluUmFuZ2UobnVtLCBfMW4sIENVUlZFLm4pO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoaXNCeXRlcyhrZXkpKVxuICAgICAgICAgICAgICAgIGtleSA9IGJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiBieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByaXZhdGUga2V5LCBleHBlY3RlZCBoZXggb3IgJyArIG5CeXRlTGVuZ3RoICsgJyBieXRlcywgZ290ICcgKyB0eXBlb2Yga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QobnVtLCBOKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFJblJhbmdlKCdwcml2YXRlIGtleScsIG51bSwgXzFuLCBOKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcmpwb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8vIE1lbW9pemVkIHRvQWZmaW5lIC8gdmFsaWRpdHkgY2hlY2suIFRoZXkgYXJlIGhlYXZ5LiBQb2ludHMgYXJlIGltbXV0YWJsZS5cbiAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgLy8gKFgsIFksIFopIOKIiyAoeD1YL1osIHk9WS9aKVxuICAgIGNvbnN0IHRvQWZmaW5lTWVtbyA9IG1lbW9pemVkKChwLCBpeikgPT4ge1xuICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHA7XG4gICAgICAgIC8vIEZhc3QtcGF0aCBmb3Igbm9ybWFsaXplZCBwb2ludHNcbiAgICAgICAgaWYgKEZwLmVxbCh6LCBGcC5PTkUpKVxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgfSk7XG4gICAgLy8gTk9URTogb24gZXhjZXB0aW9uIHRoaXMgd2lsbCBjcmFzaCAnY2FjaGVkJyBhbmQgbm8gdmFsdWUgd2lsbCBiZSBzZXQuXG4gICAgLy8gT3RoZXJ3aXNlIHRydWUgd2lsbCBiZSByZXR1cm5cbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocCkgPT4ge1xuICAgICAgICBpZiAocC5pczAoKSkge1xuICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgaW52YWxpZCByZXByZXNlbnRhdGlvbiBvZiBaRVJPLlxuICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHAucHkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAudG9BZmZpbmUoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkWFkoeCwgeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICBpZiAoIXAuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoWCwgWSwgWikg4oiLICh4PVgvWiwgeT1ZL1opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpIHx8IEZwLmlzMChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwSW52ZXJ0QmF0Y2goRnAsIHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXBwZW5nZXIoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhcHJqcG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGEgPSBDVVJWRS5hO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIG4sIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseVVuc2FmZShzYykge1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvLCBuOiBOIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGFJblJhbmdlKCdzY2FsYXInLCBzYywgXzBuLCBOKTtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKHNjID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSB8fCBzYyA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgLy8gQ2FzZSBhOiBubyBlbmRvbW9ycGhpc20uIENhc2UgYjogaGFzIHByZWNvbXB1dGVzLlxuICAgICAgICAgICAgaWYgKCFlbmRvIHx8IHduYWYuaGFzUHJlY29tcHV0ZXModGhpcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZFVuc2FmZSh0aGlzLCBzYywgUG9pbnQubm9ybWFsaXplWik7XG4gICAgICAgICAgICAvLyBDYXNlIGM6IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgLyoqIFNlZSBkb2NzIGZvciB7QGxpbmsgRW5kb21vcnBoaXNtT3B0c30gKi9cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBhSW5SYW5nZSgnc2NhbGFyJywgc2NhbGFyLCBfMW4sIE4pO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICAvKiogU2VlIGRvY3MgZm9yIHtAbGluayBFbmRvbW9ycGhpc21PcHRzfSAqL1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjYWxhcik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIHJldHVybiB0b0FmZmluZU1lbW8odGhpcywgaXopO1xuICAgICAgICB9XG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXNUb3JzaW9uRnJlZSgpIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBmb3IgdGhlIGVsbGlwdGljIGN1cnZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICBhYm9vbCgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJhc2UgLyBnZW5lcmF0b3IgcG9pbnRcbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICAvLyB6ZXJvIC8gaW5maW5pdHkgLyBpZGVudGl0eSBwb2ludFxuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTsgLy8gMCwgMSwgMFxuICAgIGNvbnN0IHsgZW5kbywgbkJpdExlbmd0aCB9ID0gQ1VSVkU7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIGVuZG8gPyBNYXRoLmNlaWwobkJpdExlbmd0aCAvIDIpIDogbkJpdExlbmd0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIHNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGFuZCBFQ0RTQSBzaWduYXR1cmUgbWV0aG9kcyBmb3IgaXQuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRmllbGQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuICogLy8gQmVmb3JlIHRoYXQsIGRlZmluZSBCaWdJbnQtczogYSwgYiwgcCwgbiwgR3gsIEd5XG4gKiBjb25zdCBjdXJ2ZSA9IHdlaWVyc3RyYXNzKHsgYSwgYiwgRnA6IEZpZWxkKHApLCBuLCBHeCwgR3ksIGg6IDFuIH0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiwgbkJ5dGVMZW5ndGgsIG5CaXRMZW5ndGggfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSBjb25jYXRCeXRlcztcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluUmFuZ2UoeCwgXzFuLCBGcC5PUkRFUikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbCA9IGNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgY29uc3QgdWwgPSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFBvaW50LCBleHBlY3RlZCBsZW5ndGggb2YgJyArIGNsICsgJywgb3IgdW5jb21wcmVzc2VkICcgKyB1bCArICcsIGdvdCAnICsgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiBieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIGFJblJhbmdlKCdyJywgciwgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHIgaW4gWzEuLk5dXG4gICAgICAgICAgICBhSW5SYW5nZSgncycsIHMsIF8xbiwgQ1VSVkVfT1JERVIpOyAvLyBzIGluIFsxLi5OXVxuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICBpZiAocmVjb3ZlcnkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBuQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdG9kbyByZW1vdmVcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkgeyB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9TaXplZEhleChyYWRqLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBuQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub1NpemVkSGV4KHRoaXMuciwgbCkgKyBudW1Ub1NpemVkSGV4KHRoaXMucywgbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBhcnIgPSBlbnN1cmVCeXRlcygna2V5JywgaXRlbSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGZwbCA9IEZwLkJZVEVTO1xuICAgICAgICBjb25zdCBjb21wTGVuID0gZnBsICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICAgICAgY29uc3QgdW5jb21wTGVuID0gMiAqIGZwbCArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgICAgIGlmIChDVVJWRS5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgfHwgbkJ5dGVMZW5ndGggPT09IGNvbXBMZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSBjb21wTGVuIHx8IGxlbiA9PT0gdW5jb21wTGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpID09PSB0cnVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoaXNQcm9iUHViKHB1YmxpY0IpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBPdXIgY3VzdG9tIGNoZWNrIFwianVzdCBpbiBjYXNlXCIsIGZvciBwcm90ZWN0aW9uIGFnYWluc3QgRG9TXG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gODE5MilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IGlzIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIG5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IGJpdE1hc2sobkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBhSW5SYW5nZSgnbnVtIDwgMl4nICsgbkJpdExlbmd0aCwgbnVtLCBfMG4sIE9SREVSX01BU0spO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobnVtLCBuQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlcixcbiAgICAvLyB0aGlzIHdpbGwgYmUgaW52YWxpZCBhdCBsZWFzdCBmb3IgUDUyMS4gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgICAgICBsZXQgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHk6IGVudCB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsICYmIGVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goZW5zdXJlQnl0ZXMoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IGNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2gsIGZvcm1hdCB9ID0gb3B0cztcbiAgICAgICAgLy8gVmVyaWZ5IG9wdHMsIGRlZHVjZSBzaWduYXR1cmUgZm9ybWF0XG4gICAgICAgIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIGZvcm1hdCAhPT0gJ2NvbXBhY3QnICYmIGZvcm1hdCAhPT0gJ2RlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBtdXN0IGJlIGNvbXBhY3Qgb3IgZGVyJyk7XG4gICAgICAgIGNvbnN0IGlzSGV4ID0gdHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHNnKTtcbiAgICAgICAgY29uc3QgaXNPYmogPSAhaXNIZXggJiZcbiAgICAgICAgICAgICFmb3JtYXQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNnICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZy5zID09PSAnYmlnaW50JztcbiAgICAgICAgaWYgKCFpc0hleCAmJiAhaXNPYmopXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmF0dXJlLCBleHBlY3RlZCBVaW50OEFycmF5LCBoZXggc3RyaW5nIG9yIFNpZ25hdHVyZSBpbnN0YW5jZScpO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNPYmopXG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUoc2cuciwgc2cucyk7XG4gICAgICAgICAgICBpZiAoaXNIZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ICE9PSAnY29tcGFjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIV9zaWcgJiYgZm9ybWF0ICE9PSAnZGVyJylcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3NpZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGxvd1MgJiYgX3NpZy5oYXNIaWdoUygpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBDVVJWRS5oYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGlzID0gaW52TihzKTsgLy8gc14tMVxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICBjb25zdCB1MiA9IG1vZE4ociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpPy50b0FmZmluZSgpOyAvLyBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBTaGFsbHVlIGFuZCB2YW4gZGUgV29lc3Rpam5lIG1ldGhvZCBmb3IgYW55IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxuICogYiA9IFRydWUgYW5kIHkgPSBzcXJ0KHUgLyB2KSBpZiAodSAvIHYpIGlzIHNxdWFyZSBpbiBGLCBhbmRcbiAqIGIgPSBGYWxzZSBhbmQgeSA9IHNxcnQoWiAqICh1IC8gdikpIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBGcFxuICogQHBhcmFtIFpcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTV1VGcFNxcnRSYXRpbyhGcCwgWikge1xuICAgIC8vIEdlbmVyaWMgaW1wbGVtZW50YXRpb25cbiAgICBjb25zdCBxID0gRnAuT1JERVI7XG4gICAgbGV0IGwgPSBfMG47XG4gICAgZm9yIChsZXQgbyA9IHEgLSBfMW47IG8gJSBfMm4gPT09IF8wbjsgbyAvPSBfMm4pXG4gICAgICAgIGwgKz0gXzFuO1xuICAgIGNvbnN0IGMxID0gbDsgLy8gMS4gYzEsIHRoZSBsYXJnZXN0IGludGVnZXIgc3VjaCB0aGF0IDJeYzEgZGl2aWRlcyBxIC0gMS5cbiAgICAvLyBXZSBuZWVkIDJuICoqIGMxIGFuZCAybiAqKiAoYzEtMSkuIFdlIGNhbid0IHVzZSAqKjsgYnV0IHdlIGNhbiB1c2UgPDwuXG4gICAgLy8gMm4gKiogYzEgPT0gMm4gPDwgKGMxLTEpXG4gICAgY29uc3QgXzJuX3Bvd19jMV8xID0gXzJuIDw8IChjMSAtIF8xbiAtIF8xbik7XG4gICAgY29uc3QgXzJuX3Bvd19jMSA9IF8ybl9wb3dfYzFfMSAqIF8ybjtcbiAgICBjb25zdCBjMiA9IChxIC0gXzFuKSAvIF8ybl9wb3dfYzE7IC8vIDIuIGMyID0gKHEgLSAxKSAvICgyXmMxKSAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjMyA9IChjMiAtIF8xbikgLyBfMm47IC8vIDMuIGMzID0gKGMyIC0gMSkgLyAyICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNCA9IF8ybl9wb3dfYzEgLSBfMW47IC8vIDQuIGM0ID0gMl5jMSAtIDEgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNSA9IF8ybl9wb3dfYzFfMTsgLy8gNS4gYzUgPSAyXihjMSAtIDEpICAgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNiA9IEZwLnBvdyhaLCBjMik7IC8vIDYuIGM2ID0gWl5jMlxuICAgIGNvbnN0IGM3ID0gRnAucG93KFosIChjMiArIF8xbikgLyBfMm4pOyAvLyA3LiBjNyA9IFpeKChjMiArIDEpIC8gMilcbiAgICBsZXQgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgbGV0IHR2MSA9IGM2OyAvLyAxLiB0djEgPSBjNlxuICAgICAgICBsZXQgdHYyID0gRnAucG93KHYsIGM0KTsgLy8gMi4gdHYyID0gdl5jNFxuICAgICAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7IC8vIDMuIHR2MyA9IHR2Ml4yXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIHYpOyAvLyA0LiB0djMgPSB0djMgKiB2XG4gICAgICAgIGxldCB0djUgPSBGcC5tdWwodSwgdHYzKTsgLy8gNS4gdHY1ID0gdSAqIHR2M1xuICAgICAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7IC8vIDYuIHR2NSA9IHR2NV5jM1xuICAgICAgICB0djUgPSBGcC5tdWwodHY1LCB0djIpOyAvLyA3LiB0djUgPSB0djUgKiB0djJcbiAgICAgICAgdHYyID0gRnAubXVsKHR2NSwgdik7IC8vIDguIHR2MiA9IHR2NSAqIHZcbiAgICAgICAgdHYzID0gRnAubXVsKHR2NSwgdSk7IC8vIDkuIHR2MyA9IHR2NSAqIHVcbiAgICAgICAgbGV0IHR2NCA9IEZwLm11bCh0djMsIHR2Mik7IC8vIDEwLiB0djQgPSB0djMgKiB0djJcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NCwgYzUpOyAvLyAxMS4gdHY1ID0gdHY0XmM1XG4gICAgICAgIGxldCBpc1FSID0gRnAuZXFsKHR2NSwgRnAuT05FKTsgLy8gMTIuIGlzUVIgPSB0djUgPT0gMVxuICAgICAgICB0djIgPSBGcC5tdWwodHYzLCBjNyk7IC8vIDEzLiB0djIgPSB0djMgKiBjN1xuICAgICAgICB0djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAxNC4gdHY1ID0gdHY0ICogdHYxXG4gICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpOyAvLyAxNS4gdHYzID0gQ01PVih0djIsIHR2MywgaXNRUilcbiAgICAgICAgdHY0ID0gRnAuY21vdih0djUsIHR2NCwgaXNRUik7IC8vIDE2LiB0djQgPSBDTU9WKHR2NSwgdHY0LCBpc1FSKVxuICAgICAgICAvLyAxNy4gZm9yIGkgaW4gKGMxLCBjMSAtIDEsIC4uLiwgMik6XG4gICAgICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IF8xbjsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgdHY1ID0gaSAtIF8ybjsgLy8gMTguICAgIHR2NSA9IGkgLSAyXG4gICAgICAgICAgICB0djUgPSBfMm4gPDwgKHR2NSAtIF8xbik7IC8vIDE5LiAgICB0djUgPSAyXnR2NVxuICAgICAgICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUpOyAvLyAyMC4gICAgdHY1ID0gdHY0XnR2NVxuICAgICAgICAgICAgY29uc3QgZTEgPSBGcC5lcWwodHZ2NSwgRnAuT05FKTsgLy8gMjEuICAgIGUxID0gdHY1ID09IDFcbiAgICAgICAgICAgIHR2MiA9IEZwLm11bCh0djMsIHR2MSk7IC8vIDIyLiAgICB0djIgPSB0djMgKiB0djFcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7IC8vIDIzLiAgICB0djEgPSB0djEgKiB0djFcbiAgICAgICAgICAgIHR2djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAyNC4gICAgdHY1ID0gdHY0ICogdHYxXG4gICAgICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBlMSk7IC8vIDI1LiAgICB0djMgPSBDTU9WKHR2MiwgdHYzLCBlMSlcbiAgICAgICAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7IC8vIDI2LiAgICB0djQgPSBDTU9WKHR2NSwgdHY0LCBlMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogdHYzIH07XG4gICAgfTtcbiAgICBpZiAoRnAuT1JERVIgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBzcXJ0X3JhdGlvXzNtb2Q0KHUsIHYpXG4gICAgICAgIGNvbnN0IGMxID0gKEZwLk9SREVSIC0gXzNuKSAvIF80bjsgLy8gMS4gYzEgPSAocSAtIDMpIC8gNCAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgY29uc3QgYzIgPSBGcC5zcXJ0KEZwLm5lZyhaKSk7IC8vIDIuIGMyID0gc3FydCgtWilcbiAgICAgICAgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgICAgIGxldCB0djEgPSBGcC5zcXIodik7IC8vIDEuIHR2MSA9IHZeMlxuICAgICAgICAgICAgY29uc3QgdHYyID0gRnAubXVsKHUsIHYpOyAvLyAyLiB0djIgPSB1ICogdlxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYyKTsgLy8gMy4gdHYxID0gdHYxICogdHYyXG4gICAgICAgICAgICBsZXQgeTEgPSBGcC5wb3codHYxLCBjMSk7IC8vIDQuIHkxID0gdHYxXmMxXG4gICAgICAgICAgICB5MSA9IEZwLm11bCh5MSwgdHYyKTsgLy8gNS4geTEgPSB5MSAqIHR2MlxuICAgICAgICAgICAgY29uc3QgeTIgPSBGcC5tdWwoeTEsIGMyKTsgLy8gNi4geTIgPSB5MSAqIGMyXG4gICAgICAgICAgICBjb25zdCB0djMgPSBGcC5tdWwoRnAuc3FyKHkxKSwgdik7IC8vIDcuIHR2MyA9IHkxXjI7IDguIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgICAgIGNvbnN0IGlzUVIgPSBGcC5lcWwodHYzLCB1KTsgLy8gOS4gaXNRUiA9IHR2MyA9PSB1XG4gICAgICAgICAgICBsZXQgeSA9IEZwLmNtb3YoeTIsIHkxLCBpc1FSKTsgLy8gMTAuIHkgPSBDTU9WKHkyLCB5MSwgaXNRUilcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB5IH07IC8vIDExLiByZXR1cm4gKGlzUVIsIHkpIGlzUVIgPyB5IDogeSpjMlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBObyBjdXJ2ZXMgdXNlcyB0aGF0XG4gICAgLy8gaWYgKEZwLk9SREVSICUgXzhuID09PSBfNW4pIC8vIHNxcnRfcmF0aW9fNW1vZDhcbiAgICByZXR1cm4gc3FydFJhdGlvO1xufVxuLyoqXG4gKiBTaW1wbGlmaWVkIFNoYWxsdWUtdmFuIGRlIFdvZXN0aWpuZS1VbGFzIE1ldGhvZFxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi02LjYuMlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuICAgIHZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIGNvbnN0IHR2NF9pbnYgPSBGcEludmVydEJhdGNoKEZwLCBbdHY0XSwgdHJ1ZSlbMF07XG4gICAgICAgIHggPSBGcC5tdWwoeCwgdHY0X2ludik7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/nist.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/nist.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   p256: () => (/* binding */ p256),\n/* harmony export */   p256_hasher: () => (/* binding */ p256_hasher),\n/* harmony export */   p384: () => (/* binding */ p384),\n/* harmony export */   p384_hasher: () => (/* binding */ p384_hasher),\n/* harmony export */   p521: () => (/* binding */ p521),\n/* harmony export */   p521_hasher: () => (/* binding */ p521_hasher),\n/* harmony export */   secp256r1: () => (/* binding */ secp256r1),\n/* harmony export */   secp384r1: () => (/* binding */ secp384r1),\n/* harmony export */   secp521r1: () => (/* binding */ secp521r1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\nconst Fp256 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst p256_a = Fp256.create(BigInt('-3'));\nconst p256_b = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n/**\n * secp256r1 curve, ECDSA and ECDH methods.\n * Field: `2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n`\n */\n// prettier-ignore\nconst p256 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: p256_a,\n    b: p256_b,\n    Fp: Fp256,\n    n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n    Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n    Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n    h: BigInt(1),\n    lowS: false\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256);\n/** Alias to p256. */\nconst secp256r1 = p256;\nconst p256_mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp256, {\n    A: p256_a,\n    B: p256_b,\n    Z: Fp256.create(BigInt('-10')),\n}))();\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nconst p256_hasher = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(secp256r1.ProjectivePoint, (scalars) => p256_mapSWU(scalars[0]), {\n    DST: 'P256_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n    p: Fp256.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\n// Field over which we'll do calculations.\nconst Fp384 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'));\nconst p384_a = Fp384.create(BigInt('-3'));\n// prettier-ignore\nconst p384_b = BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef');\n/**\n * secp384r1 curve, ECDSA and ECDH methods.\n * Field: `2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n`.\n * */\n// prettier-ignore\nconst p384 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: p384_a,\n    b: p384_b,\n    Fp: Fp384,\n    n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),\n    Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),\n    Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),\n    h: BigInt(1),\n    lowS: false\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha384);\n/** Alias to p384. */\nconst secp384r1 = p384;\nconst p384_mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp384, {\n    A: p384_a,\n    B: p384_b,\n    Z: Fp384.create(BigInt('-12')),\n}))();\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nconst p384_hasher = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(secp384r1.ProjectivePoint, (scalars) => p384_mapSWU(scalars[0]), {\n    DST: 'P384_XMD:SHA-384_SSWU_RO_',\n    encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n    p: Fp384.ORDER,\n    m: 1,\n    k: 192,\n    expand: 'xmd',\n    hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha384,\n}))();\n// Field over which we'll do calculations.\nconst Fp521 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(BigInt('0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'));\nconst p521_a = Fp521.create(BigInt('-3'));\nconst p521_b = BigInt('0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00');\n/**\n * NIST secp521r1 aka p521 curve, ECDSA and ECDH methods.\n * Field: `2n**521n - 1n`.\n */\n// prettier-ignore\nconst p521 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: p521_a,\n    b: p521_b,\n    Fp: Fp521,\n    n: BigInt('0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'),\n    Gx: BigInt('0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'),\n    Gy: BigInt('0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'),\n    h: BigInt(1),\n    lowS: false,\n    allowedPrivateKeyLengths: [130, 131, 132] // P521 keys are variable-length. Normalize to 132b\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha512);\n/** Alias to p521. */\nconst secp521r1 = p521;\nconst p521_mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp521, {\n    A: p521_a,\n    B: p521_b,\n    Z: Fp521.create(BigInt('-4')),\n}))();\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nconst p521_hasher = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(secp521r1.ProjectivePoint, (scalars) => p521_mapSWU(scalars[0]), {\n    DST: 'P521_XMD:SHA-512_SSWU_RO_',\n    encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n    p: Fp521.ORDER,\n    m: 1,\n    k: 256,\n    expand: 'xmd',\n    hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha512,\n}))();\n//# sourceMappingURL=nist.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL25pc3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEQ7QUFDWDtBQUNVO0FBQ2I7QUFDa0I7QUFDaEUsY0FBYywyREFBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGFBQWEsNkRBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxzREFBTTtBQUNUO0FBQ087QUFDUCwyQ0FBMkMsNkVBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPLDJDQUEyQyx3RUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNEQUFNO0FBQ2hCLENBQUM7QUFDRDtBQUNBLGNBQWMsMkRBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGFBQWEsNkRBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxzREFBTTtBQUNUO0FBQ087QUFDUCwyQ0FBMkMsNkVBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPLDJDQUEyQyx3RUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNEQUFNO0FBQ2hCLENBQUM7QUFDRDtBQUNBLGNBQWMsMkRBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxhQUFhLDZEQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxzREFBTTtBQUNUO0FBQ087QUFDUCwyQ0FBMkMsNkVBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPLDJDQUEyQyx3RUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNEQUFNO0FBQ2hCLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9uaXN0LmpzP2JjM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBtb2R1bGUgZm9yIE5JU1QgUDI1NiwgUDM4NCwgUDUyMSBjdXJ2ZXMuXG4gKiBEbyBub3QgdXNlIGZvciBub3cuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1Niwgc2hhMzg0LCBzaGE1MTIgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tIFwiLi9fc2hvcnR3X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBGaWVsZCB9IGZyb20gXCIuL2Fic3RyYWN0L21vZHVsYXIuanNcIjtcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuY29uc3QgRnAyNTYgPSBGaWVsZChCaWdJbnQoJzB4ZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpKTtcbmNvbnN0IHAyNTZfYSA9IEZwMjU2LmNyZWF0ZShCaWdJbnQoJy0zJykpO1xuY29uc3QgcDI1Nl9iID0gQmlnSW50KCcweDVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGInKTtcbi8qKlxuICogc2VjcDI1NnIxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICogRmllbGQ6IGAybioqMjI0biAqICgybioqMzJuLTFuKSArIDJuKioxOTJuICsgMm4qKjk2bi0xbmBcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgcDI1NiA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBwMjU2X2EsXG4gICAgYjogcDI1Nl9iLFxuICAgIEZwOiBGcDI1NixcbiAgICBuOiBCaWdJbnQoJzB4ZmZmZmZmZmYwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZiY2U2ZmFhZGE3MTc5ZTg0ZjNiOWNhYzJmYzYzMjU1MScpLFxuICAgIEd4OiBCaWdJbnQoJzB4NmIxN2QxZjJlMTJjNDI0N2Y4YmNlNmU1NjNhNDQwZjI3NzAzN2Q4MTJkZWIzM2EwZjRhMTM5NDVkODk4YzI5NicpLFxuICAgIEd5OiBCaWdJbnQoJzB4NGZlMzQyZTJmZTFhN2Y5YjhlZTdlYjRhN2MwZjllMTYyYmNlMzM1NzZiMzE1ZWNlY2JiNjQwNjgzN2JmNTFmNScpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiBmYWxzZVxufSwgc2hhMjU2KTtcbi8qKiBBbGlhcyB0byBwMjU2LiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZyMSA9IHAyNTY7XG5jb25zdCBwMjU2X21hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcDI1Niwge1xuICAgIEE6IHAyNTZfYSxcbiAgICBCOiBwMjU2X2IsXG4gICAgWjogRnAyNTYuY3JlYXRlKEJpZ0ludCgnLTEwJykpLFxufSkpKCk7XG4vKiogSGFzaGluZyAvIGVuY29kaW5nIHRvIHAyNTYgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcDI1Nl9oYXNoZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2cjEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4gcDI1Nl9tYXBTV1Uoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdQMjU2X1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdQMjU2X1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcDI1Ni5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuLy8gRmllbGQgb3ZlciB3aGljaCB3ZSdsbCBkbyBjYWxjdWxhdGlvbnMuXG5jb25zdCBGcDM4NCA9IEZpZWxkKEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZmZmYwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmYnKSk7XG5jb25zdCBwMzg0X2EgPSBGcDM4NC5jcmVhdGUoQmlnSW50KCctMycpKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgcDM4NF9iID0gQmlnSW50KCcweGIzMzEyZmE3ZTIzZWU3ZTQ5ODhlMDU2YmUzZjgyZDE5MTgxZDljNmVmZTgxNDExMjAzMTQwODhmNTAxMzg3NWFjNjU2Mzk4ZDhhMmVkMTlkMmE4NWM4ZWRkM2VjMmFlZicpO1xuLyoqXG4gKiBzZWNwMzg0cjEgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuXG4gKiBGaWVsZDogYDJuKiozODRuIC0gMm4qKjEyOG4gLSAybioqOTZuICsgMm4qKjMybiAtIDFuYC5cbiAqICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCBwMzg0ID0gY3JlYXRlQ3VydmUoe1xuICAgIGE6IHAzODRfYSxcbiAgICBiOiBwMzg0X2IsXG4gICAgRnA6IEZwMzg0LFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjNzYzNGQ4MWY0MzcyZGRmNTgxYTBkYjI0OGIwYTc3YWVjZWMxOTZhY2NjNTI5NzMnKSxcbiAgICBHeDogQmlnSW50KCcweGFhODdjYTIyYmU4YjA1Mzc4ZWIxYzcxZWYzMjBhZDc0NmUxZDNiNjI4YmE3OWI5ODU5Zjc0MWUwODI1NDJhMzg1NTAyZjI1ZGJmNTUyOTZjM2E1NDVlMzg3Mjc2MGFiNycpLFxuICAgIEd5OiBCaWdJbnQoJzB4MzYxN2RlNGE5NjI2MmM2ZjVkOWU5OGJmOTI5MmRjMjlmOGY0MWRiZDI4OWExNDdjZTlkYTMxMTNiNWYwYjhjMDBhNjBiMWNlMWQ3ZTgxOWQ3YTQzMWQ3YzkwZWEwZTVmJyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IGZhbHNlXG59LCBzaGEzODQpO1xuLyoqIEFsaWFzIHRvIHAzODQuICovXG5leHBvcnQgY29uc3Qgc2VjcDM4NHIxID0gcDM4NDtcbmNvbnN0IHAzODRfbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwMzg0LCB7XG4gICAgQTogcDM4NF9hLFxuICAgIEI6IHAzODRfYixcbiAgICBaOiBGcDM4NC5jcmVhdGUoQmlnSW50KCctMTInKSksXG59KSkoKTtcbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gcDM4NCBwb2ludHMgLyBmaWVsZC4gUkZDIDkzODAgbWV0aG9kcy4gKi9cbmV4cG9ydCBjb25zdCBwMzg0X2hhc2hlciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AzODRyMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiBwMzg0X21hcFNXVShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ1AzODRfWE1EOlNIQS0zODRfU1NXVV9ST18nLFxuICAgIGVuY29kZURTVDogJ1AzODRfWE1EOlNIQS0zODRfU1NXVV9OVV8nLFxuICAgIHA6IEZwMzg0Lk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTkyLFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMzg0LFxufSkpKCk7XG4vLyBGaWVsZCBvdmVyIHdoaWNoIHdlJ2xsIGRvIGNhbGN1bGF0aW9ucy5cbmNvbnN0IEZwNTIxID0gRmllbGQoQmlnSW50KCcweDFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJykpO1xuY29uc3QgcDUyMV9hID0gRnA1MjEuY3JlYXRlKEJpZ0ludCgnLTMnKSk7XG5jb25zdCBwNTIxX2IgPSBCaWdJbnQoJzB4MDA1MTk1M2ViOTYxOGUxYzlhMWY5MjlhMjFhMGI2ODU0MGVlYTJkYTcyNWI5OWIzMTVmM2I4YjQ4OTkxOGVmMTA5ZTE1NjE5Mzk1MWVjN2U5MzdiMTY1MmMwYmQzYmIxYmYwNzM1NzNkZjg4M2QyYzM0ZjFlZjQ1MWZkNDZiNTAzZjAwJyk7XG4vKipcbiAqIE5JU1Qgc2VjcDUyMXIxIGFrYSBwNTIxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICogRmllbGQ6IGAybioqNTIxbiAtIDFuYC5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgcDUyMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBwNTIxX2EsXG4gICAgYjogcDUyMV9iLFxuICAgIEZwOiBGcDUyMSxcbiAgICBuOiBCaWdJbnQoJzB4MDFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmE1MTg2ODc4M2JmMmY5NjZiN2ZjYzAxNDhmNzA5YTVkMDNiYjVjOWI4ODk5YzQ3YWViYjZmYjcxZTkxMzg2NDA5JyksXG4gICAgR3g6IEJpZ0ludCgnMHgwMGM2ODU4ZTA2YjcwNDA0ZTljZDllM2VjYjY2MjM5NWI0NDI5YzY0ODEzOTA1M2ZiNTIxZjgyOGFmNjA2YjRkM2RiYWExNGI1ZTc3ZWZlNzU5MjhmZTFkYzEyN2EyZmZhOGRlMzM0OGIzYzE4NTZhNDI5YmY5N2U3ZTMxYzJlNWJkNjYnKSxcbiAgICBHeTogQmlnSW50KCcweDAxMTgzOTI5NmE3ODlhM2JjMDA0NWM4YTVmYjQyYzdkMWJkOTk4ZjU0NDQ5NTc5YjQ0NjgxN2FmYmQxNzI3M2U2NjJjOTdlZTcyOTk1ZWY0MjY0MGM1NTBiOTAxM2ZhZDA3NjEzNTNjNzA4NmEyNzJjMjQwODhiZTk0NzY5ZmQxNjY1MCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiBmYWxzZSxcbiAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IFsxMzAsIDEzMSwgMTMyXSAvLyBQNTIxIGtleXMgYXJlIHZhcmlhYmxlLWxlbmd0aC4gTm9ybWFsaXplIHRvIDEzMmJcbn0sIHNoYTUxMik7XG4vKiogQWxpYXMgdG8gcDUyMS4gKi9cbmV4cG9ydCBjb25zdCBzZWNwNTIxcjEgPSBwNTIxO1xuY29uc3QgcDUyMV9tYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnA1MjEsIHtcbiAgICBBOiBwNTIxX2EsXG4gICAgQjogcDUyMV9iLFxuICAgIFo6IEZwNTIxLmNyZWF0ZShCaWdJbnQoJy00JykpLFxufSkpKCk7XG4vKiogSGFzaGluZyAvIGVuY29kaW5nIHRvIHA1MjEgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcDUyMV9oYXNoZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwNTIxcjEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4gcDUyMV9tYXBTV1Uoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdQNTIxX1hNRDpTSEEtNTEyX1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdQNTIxX1hNRDpTSEEtNTEyX1NTV1VfTlVfJyxcbiAgICBwOiBGcDUyMS5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDI1NixcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTUxMixcbn0pKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmlzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/nist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/p256.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/p256.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   p256: () => (/* binding */ p256),\n/* harmony export */   secp256r1: () => (/* binding */ secp256r1)\n/* harmony export */ });\n/* harmony import */ var _nist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nist.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/nist.js\");\n/**\n * NIST secp256r1 aka p256.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst p256 = _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256;\nconst secp256r1 = _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256;\nconst hashToCurve = /* @__PURE__ */ (() => _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256_hasher.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256_hasher.encodeToCurve)();\n//# sourceMappingURL=p256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3AyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZDO0FBQ1U7QUFDaEQsYUFBYSwwQ0FBSztBQUNsQixrQkFBa0IsMENBQUs7QUFDdkIsMkNBQTJDLGlEQUFXO0FBQ3RELDZDQUE2QyxpREFBVztBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9wMjU2LmpzPzAwMzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBOSVNUIHNlY3AyNTZyMSBha2EgcDI1Ni5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHt9IGZyb20gXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanNcIjtcbmltcG9ydCB7IHAyNTZfaGFzaGVyLCBwMjU2IGFzIHAyNTZuIH0gZnJvbSBcIi4vbmlzdC5qc1wiO1xuZXhwb3J0IGNvbnN0IHAyNTYgPSBwMjU2bjtcbmV4cG9ydCBjb25zdCBzZWNwMjU2cjEgPSBwMjU2bjtcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcDI1Nl9oYXNoZXIuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcDI1Nl9oYXNoZXIuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXAyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/p256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1),\n/* harmony export */   secp256k1_hasher: () => (/* binding */ secp256k1_hasher)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n * ```\n */\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: _0n,\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = /* @__PURE__ */ (() => secp256k1.ProjectivePoint)();\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.aInRange)('x', x, _1n, secp256k1P); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n * ```\n */\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nconst secp256k1_hasher = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => secp256k1_hasher.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => secp256k1_hasher.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNNO0FBQ0Q7QUFDc0I7QUFDZDtBQUM0RDtBQUNyRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxrQ0FBa0M7QUFDbEMsZ0JBQWdCLDBEQUFJO0FBQ3BCLGdCQUFnQiwwREFBSTtBQUNwQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGdCQUFnQiwwREFBSTtBQUNwQixpQkFBaUIsMERBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJEQUFLLHFDQUFxQyxlQUFlO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsMENBQTBDLEtBQUssY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDTyxrQkFBa0IsNkRBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFHO0FBQ3hCLHFCQUFxQix5REFBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDLEVBQUUsc0RBQU07QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwREFBTTtBQUMzQixlQUFlLCtEQUFXO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDBEQUFNLENBQUMsK0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFlO0FBQ3ZDLG9CQUFvQix5REFBRztBQUN2QixvQkFBb0IseURBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Qsc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBUSwyQkFBMkI7QUFDdkM7QUFDQSx3Q0FBd0M7QUFDeEMsd0JBQXdCO0FBQ3hCO0FBQ0Esc0JBQXNCO0FBQ3RCLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0VBQVc7QUFDL0QsY0FBYywrREFBVztBQUN6QixZQUFZLHVCQUF1QixtQ0FBbUM7QUFDdEUsY0FBYywrREFBVywwQkFBMEI7QUFDbkQsK0RBQStEO0FBQy9ELHdEQUF3RDtBQUN4RCxnQ0FBZ0M7QUFDaEM7QUFDQSxtREFBbUQ7QUFDbkQsWUFBWSx1QkFBdUIsMkJBQTJCO0FBQzlELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFXO0FBQzNCLGNBQWMsK0RBQVc7QUFDekIsZ0JBQWdCLCtEQUFXO0FBQzNCO0FBQ0Esb0NBQW9DLHdCQUF3QjtBQUM1RCw0Q0FBNEMsMkJBQTJCO0FBQ3ZFLGFBQWEsMkRBQU87QUFDcEI7QUFDQSw2Q0FBNkMsNEJBQTRCO0FBQ3pFLGFBQWEsMkRBQU87QUFDcEI7QUFDQSw4REFBOEQ7QUFDOUQsMkNBQTJDO0FBQzNDO0FBQ0EsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0EsV0FBVztBQUNYLEtBQUs7QUFDTCxDQUFDO0FBQ0Qsc0NBQXNDLHNFQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTyxnREFBZ0Qsd0VBQVk7QUFDbkUsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQU07QUFDaEIsQ0FBQztBQUNNO0FBQ0E7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM/ODgwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE5JU1Qgc2VjcDI1NmsxLiBTZWUgW3BkZl0oaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMi12Mi5wZGYpLlxuICpcbiAqIFNlZW1zIHRvIGJlIHJpZ2lkIChub3QgYmFja2Rvb3JlZClcbiAqIFthcyBwZXIgZGlzY3Vzc2lvbl0oaHR0cHM6Ly9iaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzUpLlxuICpcbiAqIHNlY3AyNTZrMSBiZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHkgY29tcHV0YWJsZSBlbmRvbW9ycGhpc20uXG4gKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAqIFtTZWUgZXhwbGFuYXRpb25dKGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NikuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tIFwiLi9fc2hvcnR3X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tIFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSBcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiO1xuaW1wb3J0IHsgYUluUmFuZ2UsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpblJhbmdlLCBudW1iZXJUb0J5dGVzQkUsIH0gZnJvbSBcIi4vYWJzdHJhY3QvdXRpbHMuanNcIjtcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwazEgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuLyoqXG4gKiBzZWNwMjU2azEgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuXG4gKlxuICogRmllbGQ6IGAybioqMjU2biAtIDJuKiozMm4gLSAybioqOW4gLSAybioqOG4gLSAybioqN24gLSAybioqNm4gLSAybioqNG4gLSAxbmBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogY29uc3QgcHViID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShwcml2KTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDEpOyAvLyBtZXNzYWdlIGhhc2ggKG5vdCBtZXNzYWdlKSBpbiBlY2RzYVxuICogY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnLCBwcml2KTsgLy8gYHtwcmVoYXNoOiB0cnVlfWAgb3B0aW9uIGlzIGF2YWlsYWJsZVxuICogY29uc3QgaXNWYWxpZCA9IHNlY3AyNTZrMS52ZXJpZnkoc2lnLCBtc2csIHB1YikgPT09IHRydWU7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBfMG4sXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwOiBGcGsxLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG4gICAgZW5kbzoge1xuICAgICAgICAvLyBFbmRvbW9ycGhpc20sIHNlZSBhYm92ZVxuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiBudW1iZXJUb0J5dGVzQkUobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50KSgpO1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgYUluUmFuZ2UoJ3gnLCB4LCBfMW4sIHNlY3AyNTZrMVApOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFO1xuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4obnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gbnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKG51bShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChudW0ocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gbnVtKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghaW5SYW5nZShyLCBfMW4sIHNlY3AyNTZrMVApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gbnVtKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFpblJhbmdlKHMsIF8xbiwgc2VjcDI1NmsxTikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqIGNvbnN0IHB1YiA9IHNjaG5vcnIuZ2V0UHVibGljS2V5KHByaXYpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgcHJpdik7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2Nobm9yci52ZXJpZnkoc2lnLCBtc2csIHB1Yik7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwazEsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnBrMSwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnBrMS5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gc2VjcDI1NmsxIHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMV9oYXNoZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcGsxLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHNlY3AyNTZrMV9oYXNoZXIuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gc2VjcDI1NmsxX2hhc2hlci5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_md.js":
/*!***************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/_md.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj),\n/* harmony export */   SHA224_IV: () => (/* binding */ SHA224_IV),\n/* harmony export */   SHA256_IV: () => (/* binding */ SHA256_IV),\n/* harmony export */   SHA384_IV: () => (/* binding */ SHA384_IV),\n/* harmony export */   SHA512_IV: () => (/* binding */ SHA512_IV),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nconst SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nconst SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nconst SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nconst SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN3RjtBQUN4RjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwyQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2YsZUFBZSxrREFBTztBQUN0QixRQUFRLGlEQUFNO0FBQ2QsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanM/MzYzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVybmFsIE1lcmtsZS1EYW1nYXJkIGhhc2ggdXRpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IEhhc2gsIGFieXRlcywgYWV4aXN0cywgYW91dHB1dCwgY2xlYW4sIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqIFBvbHlmaWxsIGZvciBTYWZhcmkgMTQuIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfZGF0YXZpZXdfc2V0YmlndWludDY0ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8qKiBDaG9pY2U6IGEgPyBiIDogYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIENoaShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAofmEgJiBjKTtcbn1cbi8qKiBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHV0cyBpcyB0cnVlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1haihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbn1cbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5leHBvcnQgY2xhc3MgSGFzaE1EIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgYW91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykpO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsIFNIQS0yIHN0YXRlOiBmcmFjdGlvbmFsIHBhcnRzIG9mIHNxdWFyZSByb290cyBvZiBmaXJzdCAxNiBwcmltZXMgMi4uNTMuXG4gKiBDaGVjayBvdXQgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AgZm9yIHJlY29tcHV0YXRpb24gZ3VpZGUuXG4gKi9cbi8qKiBJbml0aWFsIFNIQTI1NiBzdGF0ZS4gQml0cyAwLi4zMiBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydCBjb25zdCBTSEEyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOSxcbl0pO1xuLyoqIEluaXRpYWwgU0hBMjI0IHN0YXRlLiBCaXRzIDMyLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnQgY29uc3QgU0hBMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTM4NCBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnQgY29uc3QgU0hBMzg0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG4gICAgMHg2NzMzMjY2NywgMHhmZmMwMGIzMSwgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSwgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNywgMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCxcbl0pO1xuLyoqIEluaXRpYWwgU0hBNTEyIHN0YXRlLiBCaXRzIDAuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0IGNvbnN0IFNIQTUxMl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LCAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLCAweDNjNmVmMzcyLCAweGZlOTRmODJiLCAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuICAgIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzksXG5dKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9tZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_u64.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/_u64.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dMO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEdBQUcsRUFBQztBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzP2E2OWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXJzIGZvciB1NjQuIEJpZ1VpbnQ2NEFycmF5IGlzIHRvbyBzbG93IGFzIHBlciAyMDI1LCBzbyB3ZSBpbXBsZW1lbnQgaXQgdXNpbmcgVWludDMyQXJyYXkuXG4gKiBAdG9kbyByZS1jaGVjayBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzQyMjEyNTg4XG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBsc3QubGVuZ3RoO1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBhZGQsIGFkZDNILCBhZGQzTCwgYWRkNEgsIGFkZDRMLCBhZGQ1SCwgYWRkNUwsIGZyb21CaWcsIHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgcm90cjMySCwgcm90cjMyTCwgcm90ckJILCByb3RyQkwsIHJvdHJTSCwgcm90clNMLCBzaHJTSCwgc2hyU0wsIHNwbGl0LCB0b0JpZyB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2)))\n    ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto\n    : /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"randomBytes\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2)))\n        ? /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2)))\n        : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b05vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUMzQixlQUFlLDJNQUFFLFdBQVcsMk1BQUUsaUJBQWlCLDBOQUFpQjtBQUN2RSxNQUFNLGtEQUFZO0FBQ2xCLE1BQU0sMk1BQUUsV0FBVywyTUFBRSxpQkFBaUIsNE5BQW1CO0FBQ3pELFVBQVUsMk1BQUU7QUFDWjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0b05vZGUuanM/YTM2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVybmFsIHdlYmNyeXB0byBhbGlhcy5cbiAqIFdlIHByZWZlciBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gbm9kZS5qcyAxNisuXG4gKiBGYWxscyBiYWNrIHRvIE5vZGUuanMgYnVpbHQtaW4gY3J5cHRvIGZvciBOb2RlLmpzIDw9djE0LlxuICogU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuICogQG1vZHVsZVxuICovXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgKiBhcyBuYyBmcm9tICdub2RlOmNyeXB0byc7XG5leHBvcnQgY29uc3QgY3J5cHRvID0gbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAnd2ViY3J5cHRvJyBpbiBuY1xuICAgID8gbmMud2ViY3J5cHRvXG4gICAgOiBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICdyYW5kb21CeXRlcycgaW4gbmNcbiAgICAgICAgPyBuY1xuICAgICAgICA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0b05vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/hmac.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/hmac.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\n\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(pad);\n    }\n    update(buf) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDMEU7QUFDbkUsbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcz81NTMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYWhhc2gsIGNsZWFuLCBIYXNoLCB0b0J5dGVzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFoYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIGNsZWFuKHBhZCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbiAqIGltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG4gKiBjb25zdCBtYWMxID0gaG1hYyhzaGEyNTYsICdrZXknLCAnbWVzc2FnZScpO1xuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/legacy.js":
/*!******************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/legacy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MD5: () => (/* binding */ MD5),\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   SHA1: () => (/* binding */ SHA1),\n/* harmony export */   md5: () => (/* binding */ md5),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha1: () => (/* binding */ sha1)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\n\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nclass SHA1 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nconst sha1 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nclass MD5 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nconst md5 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nconst ripemd160 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2xlZ2FjeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUNXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLDBDQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDLHdCQUF3QiwrQ0FBSTtBQUM1QjtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsdURBQVk7QUFDaEQ7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQkFBa0IsMENBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0Isd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQiwyQ0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQ0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDRCQUE0Qix1REFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLDBDQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSwwREFBMEQ7QUFDMUQsc0RBQXNEO0FBQ3RELGtFQUFrRTtBQUNsRSw0QkFBNEIsUUFBUTtBQUNwQyw0QkFBNEIsK0NBQUk7QUFDaEMsdUNBQXVDLCtDQUFJLGdDQUFnQztBQUMzRTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEMsNEJBQTRCLCtDQUFJO0FBQ2hDLHVDQUF1QywrQ0FBSSxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLHVEQUFZO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2xlZ2FjeS5qcz81OWZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuXG5TSEExIChSRkMgMzE3NCksIE1ENSAoUkZDIDEzMjEpIGFuZCBSSVBFTUQxNjAgKFJGQyAyMjg2KSBsZWdhY3ksIHdlYWsgaGFzaCBmdW5jdGlvbnMuXG5Eb24ndCB1c2UgdGhlbSBpbiBhIG5ldyBwcm90b2NvbC4gV2hhdCBcIndlYWtcIiBtZWFuczpcblxuLSBDb2xsaXNpb25zIGNhbiBiZSBtYWRlIHdpdGggMl4xOCBlZmZvcnQgaW4gTUQ1LCAyXjYwIGluIFNIQTEsIDJeODAgaW4gUklQRU1EMTYwLlxuLSBObyBwcmFjdGljYWwgcHJlLWltYWdlIGF0dGFja3MgKG9ubHkgdGhlb3JldGljYWwsIDJeMTIzLjQpXG4tIEhNQUMgc2VlbXMga2luZGEgb2s6IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjE1MVxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBDaGksIEhhc2hNRCwgTWFqIH0gZnJvbSBcIi4vX21kLmpzXCI7XG5pbXBvcnQgeyBjbGVhbiwgY3JlYXRlSGFzaGVyLCByb3RsIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKiBJbml0aWFsIFNIQTEgc3RhdGUgKi9cbmNvbnN0IFNIQTFfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCxcbl0pO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgU0hBMV9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG4vKiogU0hBMSBsZWdhY3kgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBTSEExIGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuQSA9IFNIQTFfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEExX0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMV9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTFfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEExX0lWWzRdIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRV07XG4gICAgfVxuICAgIHNldChBLCBCLCBDLCBELCBFKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTFfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKVxuICAgICAgICAgICAgU0hBMV9XW2ldID0gcm90bChTSEExX1dbaSAtIDNdIF4gU0hBMV9XW2kgLSA4XSBeIFNIQTFfV1tpIC0gMTRdIF4gU0hBMV9XW2kgLSAxNl0sIDEpO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBGLCBLO1xuICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuICAgICAgICAgICAgICAgIEYgPSBDaGkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgSyA9IDB4NWE4Mjc5OTk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgNDApIHtcbiAgICAgICAgICAgICAgICBGID0gQiBeIEMgXiBEO1xuICAgICAgICAgICAgICAgIEsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDYwKSB7XG4gICAgICAgICAgICAgICAgRiA9IE1haihCLCBDLCBEKTtcbiAgICAgICAgICAgICAgICBLID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEYgPSBCIF4gQyBeIEQ7XG4gICAgICAgICAgICAgICAgSyA9IDB4Y2E2MmMxZDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBUID0gKHJvdGwoQSwgNSkgKyBGICsgRSArIEsgKyBTSEExX1dbaV0pIHwgMDtcbiAgICAgICAgICAgIEUgPSBEO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gcm90bChCLCAzMCk7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSBUO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIGNsZWFuKFNIQTFfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuLyoqIFNIQTEgKFJGQyAzMTc0KSBsZWdhY3kgaGFzaCBmdW5jdGlvbi4gSXQgd2FzIGNyeXB0b2dyYXBoaWNhbGx5IGJyb2tlbi4gKi9cbmV4cG9ydCBjb25zdCBzaGExID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMSgpKTtcbi8qKiBQZXItcm91bmQgY29uc3RhbnRzICovXG5jb25zdCBwMzIgPSAvKiBAX19QVVJFX18gKi8gTWF0aC5wb3coMiwgMzIpO1xuY29uc3QgSyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiA2NCB9LCAoXywgaSkgPT4gTWF0aC5mbG9vcihwMzIgKiBNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpKSk7XG4vKiogbWQ1IGluaXRpYWwgc3RhdGU6IHNhbWUgYXMgc2hhMSwgYnV0IDQgdTMyIGluc3RlYWQgb2YgNS4gKi9cbmNvbnN0IE1ENV9JViA9IC8qIEBfX1BVUkVfXyAqLyBTSEExX0lWLnNsaWNlKDAsIDQpO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgTUQ1X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbi8qKiBNRDUgbGVnYWN5IGhhc2ggY2xhc3MuICovXG5leHBvcnQgY2xhc3MgTUQ1IGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDE2LCA4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5BID0gTUQ1X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gTUQ1X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gTUQ1X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gTUQ1X0lWWzNdIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRF07XG4gICAgfVxuICAgIHNldChBLCBCLCBDLCBEKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgTUQ1X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBEIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBGLCBnLCBzO1xuICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICAgICAgICAgIEYgPSBDaGkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgZyA9IGk7XG4gICAgICAgICAgICAgICAgcyA9IFs3LCAxMiwgMTcsIDIyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgICAgICAgICAgIEYgPSBDaGkoRCwgQiwgQyk7XG4gICAgICAgICAgICAgICAgZyA9ICg1ICogaSArIDEpICUgMTY7XG4gICAgICAgICAgICAgICAgcyA9IFs1LCA5LCAxNCwgMjBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICAgICAgICAgICAgRiA9IEIgXiBDIF4gRDtcbiAgICAgICAgICAgICAgICBnID0gKDMgKiBpICsgNSkgJSAxNjtcbiAgICAgICAgICAgICAgICBzID0gWzQsIDExLCAxNiwgMjNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRiA9IEMgXiAoQiB8IH5EKTtcbiAgICAgICAgICAgICAgICBnID0gKDcgKiBpKSAlIDE2O1xuICAgICAgICAgICAgICAgIHMgPSBbNiwgMTAsIDE1LCAyMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBGID0gRiArIEEgKyBLW2ldICsgTUQ1X1dbZ107XG4gICAgICAgICAgICBBID0gRDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQiArIHJvdGwoRiwgc1tpICUgNF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBEKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgY2xlYW4oTUQ1X1cpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwKTtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbi8qKlxuICogTUQ1IChSRkMgMTMyMSkgbGVnYWN5IGhhc2ggZnVuY3Rpb24uIEl0IHdhcyBjcnlwdG9ncmFwaGljYWxseSBicm9rZW4uXG4gKiBNRDUgYXJjaGl0ZWN0dXJlIGlzIHNpbWlsYXIgdG8gU0hBMSwgd2l0aCBzb21lIGRpZmZlcmVuY2VzOlxuICogLSBSZWR1Y2VkIG91dHB1dCBsZW5ndGg6IDE2IGJ5dGVzICgxMjggYml0KSBpbnN0ZWFkIG9mIDIwXG4gKiAtIDY0IHJvdW5kcywgaW5zdGVhZCBvZiA4MFxuICogLSBMaXR0bGUtZW5kaWFuOiBjb3VsZCBiZSBmYXN0ZXIsIGJ1dCB3aWxsIHJlcXVpcmUgbW9yZSBjb2RlXG4gKiAtIE5vbi1saW5lYXIgaW5kZXggc2VsZWN0aW9uOiBodWdlIHNwZWVkLXVwIGZvciB1bnJvbGxcbiAqIC0gUGVyIHJvdW5kIGNvbnN0YW50czogbW9yZSBtZW1vcnkgYWNjZXNzZXMsIGFkZGl0aW9uYWwgc3BlZWQtdXAgZm9yIHVucm9sbFxuICovXG5leHBvcnQgY29uc3QgbWQ1ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgTUQ1KCkpO1xuLy8gUklQRU1ELTE2MFxuY29uc3QgUmhvMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbl0pO1xuY29uc3QgSWQxNjAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IFVpbnQ4QXJyYXkuZnJvbShuZXcgQXJyYXkoMTYpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBpKSkpKCk7XG5jb25zdCBQaTE2MCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSWQxNjAubWFwKChpKSA9PiAoOSAqIGkgKyA1KSAlIDE2KSkoKTtcbmNvbnN0IGlkeExSID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgY29uc3QgTCA9IFtJZDE2MF07XG4gICAgY29uc3QgUiA9IFtQaTE2MF07XG4gICAgY29uc3QgcmVzID0gW0wsIFJdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBmb3IgKGxldCBqIG9mIHJlcylcbiAgICAgICAgICAgIGoucHVzaChqW2ldLm1hcCgoaykgPT4gUmhvMTYwW2tdKSk7XG4gICAgcmV0dXJuIHJlcztcbn0pKCk7XG5jb25zdCBpZHhMID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpZHhMUlswXSkoKTtcbmNvbnN0IGlkeFIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlkeExSWzFdKSgpO1xuLy8gY29uc3QgW2lkeEwsIGlkeFJdID0gaWR4TFI7XG5jb25zdCBzaGlmdHMxNjAgPSAvKiBAX19QVVJFX18gKi8gW1xuICAgIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICAgIFsxMiwgMTMsIDExLCAxNSwgNiwgOSwgOSwgNywgMTIsIDE1LCAxMSwgMTMsIDcsIDgsIDcsIDddLFxuICAgIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxuICAgIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICAgIFsxNSwgMTIsIDEzLCAxMywgOSwgNSwgOCwgNiwgMTQsIDExLCAxMiwgMTEsIDgsIDYsIDUsIDVdLFxuXS5tYXAoKGkpID0+IFVpbnQ4QXJyYXkuZnJvbShpKSk7XG5jb25zdCBzaGlmdHNMMTYwID0gLyogQF9fUFVSRV9fICovIGlkeEwubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0czE2MFtpXVtqXSkpO1xuY29uc3Qgc2hpZnRzUjE2MCA9IC8qIEBfX1BVUkVfXyAqLyBpZHhSLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHMxNjBbaV1bal0pKTtcbmNvbnN0IEtsMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4MDAwMDAwMDAsIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4YTk1M2ZkNGUsXG5dKTtcbmNvbnN0IEtyMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDAsXG5dKTtcbi8vIEl0J3MgY2FsbGVkIGYoKSBpbiBzcGVjLlxuZnVuY3Rpb24gcmlwZW1kX2YoZ3JvdXAsIHgsIHksIHopIHtcbiAgICBpZiAoZ3JvdXAgPT09IDApXG4gICAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gICAgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGlmIChncm91cCA9PT0gMilcbiAgICAgICAgcmV0dXJuICh4IHwgfnkpIF4gejtcbiAgICBpZiAoZ3JvdXAgPT09IDMpXG4gICAgICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiB+eik7XG4gICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJcbmNvbnN0IEJVRl8xNjAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmV4cG9ydCBjbGFzcyBSSVBFTUQxNjAgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMjAsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLmgwID0gMHg2NzQ1MjMwMSB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSAweGVmY2RhYjg5IHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IDB4OThiYWRjZmUgfCAwO1xuICAgICAgICB0aGlzLmgzID0gMHgxMDMyNTQ3NiB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSAweGMzZDJlMWYwIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IGgwLCBoMSwgaDIsIGgzLCBoNCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtoMCwgaDEsIGgyLCBoMywgaDRdO1xuICAgIH1cbiAgICBzZXQoaDAsIGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgIHRoaXMuaDAgPSBoMCB8IDA7XG4gICAgICAgIHRoaXMuaDEgPSBoMSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSBoMiB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSBoMyB8IDA7XG4gICAgICAgIHRoaXMuaDQgPSBoNCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBCVUZfMTYwW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBhbCA9IHRoaXMuaDAgfCAwLCBhciA9IGFsLCBibCA9IHRoaXMuaDEgfCAwLCBiciA9IGJsLCBjbCA9IHRoaXMuaDIgfCAwLCBjciA9IGNsLCBkbCA9IHRoaXMuaDMgfCAwLCBkciA9IGRsLCBlbCA9IHRoaXMuaDQgfCAwLCBlciA9IGVsO1xuICAgICAgICAvLyBJbnN0ZWFkIG9mIGl0ZXJhdGluZyAwIHRvIDgwLCB3ZSBzcGxpdCBpdCBpbnRvIDUgZ3JvdXBzXG4gICAgICAgIC8vIEFuZCB1c2UgdGhlIGdyb3VwcyBpbiBjb25zdGFudHMsIGZ1bmN0aW9ucywgZXRjLiBNdWNoIHNpbXBsZXJcbiAgICAgICAgZm9yIChsZXQgZ3JvdXAgPSAwOyBncm91cCA8IDU7IGdyb3VwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJHcm91cCA9IDQgLSBncm91cDtcbiAgICAgICAgICAgIGNvbnN0IGhibCA9IEtsMTYwW2dyb3VwXSwgaGJyID0gS3IxNjBbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHJsID0gaWR4TFtncm91cF0sIHJyID0gaWR4Ultncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgc2wgPSBzaGlmdHNMMTYwW2dyb3VwXSwgc3IgPSBzaGlmdHNSMTYwW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bCA9IChyb3RsKGFsICsgcmlwZW1kX2YoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGXzE2MFtybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBlbCwgZWwgPSBkbCwgZGwgPSByb3RsKGNsLCAxMCkgfCAwLCBjbCA9IGJsLCBibCA9IHRsOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKHJvdGwoYXIgKyByaXBlbWRfZihyR3JvdXAsIGJyLCBjciwgZHIpICsgQlVGXzE2MFtycltpXV0gKyBoYnIsIHNyW2ldKSArIGVyKSB8IDA7XG4gICAgICAgICAgICAgICAgYXIgPSBlciwgZXIgPSBkciwgZHIgPSByb3RsKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihCVUZfMTYwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbi8qKlxuICogUklQRU1ELTE2MCAtIGEgbGVnYWN5IGhhc2ggZnVuY3Rpb24gZnJvbSAxOTkwcy5cbiAqICogaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAuaHRtbFxuICogKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuICovXG5leHBvcnQgY29uc3QgcmlwZW1kMTYwID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgUklQRU1EMTYwKCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVnYWN5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/legacy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legacy.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/legacy.js\");\n/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\n\n/** @deprecated Use import from `noble/hashes/legacy` module */\nconst RIPEMD160 = _legacy_js__WEBPACK_IMPORTED_MODULE_0__.RIPEMD160;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nconst ripemd160 = _legacy_js__WEBPACK_IMPORTED_MODULE_0__.ripemd160;\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3JpcGVtZDE2MC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrRTtBQUMvRTtBQUNPLGtCQUFrQixpREFBVTtBQUNuQztBQUNPLGtCQUFrQixpREFBVTtBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanM/OWYzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJJUEVNRC0xNjAgbGVnYWN5IGhhc2ggZnVuY3Rpb24uXG4gKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4gKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuaW1wb3J0IHsgUklQRU1EMTYwIGFzIFJJUEVNRDE2MG4sIHJpcGVtZDE2MCBhcyByaXBlbWQxNjBuIH0gZnJvbSBcIi4vbGVnYWN5LmpzXCI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvbGVnYWN5YCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBSSVBFTUQxNjAgPSBSSVBFTUQxNjBuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL2xlZ2FjeWAgbW9kdWxlICovXG5leHBvcnQgY29uc3QgcmlwZW1kMTYwID0gcmlwZW1kMTYwbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJpcGVtZDE2MC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   SHA384: () => (/* binding */ SHA384),\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   SHA512_224: () => (/* binding */ SHA512_224),\n/* harmony export */   SHA512_256: () => (/* binding */ SHA512_256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\n\n\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\nclass SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_2__.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0Y7QUFDdkQ7QUFDc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwwQ0FBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBUztBQUMxQixpQkFBaUIsNkNBQVM7QUFDMUIsaUJBQWlCLDZDQUFTO0FBQzFCLGlCQUFpQiw2Q0FBUztBQUMxQixpQkFBaUIsNkNBQVM7QUFDMUIsaUJBQWlCLDZDQUFTO0FBQzFCLGlCQUFpQiw2Q0FBUztBQUMxQixpQkFBaUIsNkNBQVM7QUFDMUI7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRCxxQ0FBcUMsMkNBQUc7QUFDeEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRCxpQ0FBaUMsMkNBQUc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q2xEO0FBQ08sK0JBQStCLHVEQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DLHVEQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DLHVEQUFZO0FBQ3REIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTIuanM/ZTQ2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNIQTIgaGFzaCBmdW5jdGlvbi4gQS5rLmEuIHNoYTI1Niwgc2hhMzg0LCBzaGE1MTIsIHNoYTUxMl8yMjQsIHNoYTUxMl8yNTYuXG4gKiBTSEEyNTYgaXMgdGhlIGZhc3Rlc3QgaGFzaCBpbXBsZW1lbnRhYmxlIGluIEpTLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIENoZWNrIG91dCBbUkZDIDQ2MzRdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDYzNCkgYW5kXG4gKiBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IENoaSwgSGFzaE1ELCBNYWosIFNIQTIyNF9JViwgU0hBMjU2X0lWLCBTSEEzODRfSVYsIFNIQTUxMl9JViB9IGZyb20gXCIuL19tZC5qc1wiO1xuaW1wb3J0ICogYXMgdTY0IGZyb20gXCIuL191NjQuanNcIjtcbmltcG9ydCB7IGNsZWFuLCBjcmVhdGVIYXNoZXIsIHJvdHIgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqXG4gKiBSb3VuZCBjb25zdGFudHM6XG4gKiBGaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8qKiBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyLiBcIldcIiBjb21lcyBzdHJhaWdodCBmcm9tIHNwZWMuICovXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuZXhwb3J0IGNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gMzIpIHtcbiAgICAgICAgc3VwZXIoNjQsIG91dHB1dExlbiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihTSEEyNTZfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BID0gU0hBMjI0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjI0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjI0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjI0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjI0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjI0X0lWWzddIHwgMDtcbiAgICB9XG59XG4vLyBTSEEyLTUxMiBpcyBzbG93ZXIgdGhhbiBzaGEyNTYgaW4ganMgYmVjYXVzZSB1NjQgb3BlcmF0aW9ucyBhcmUgc2xvdy5cbi8vIFJvdW5kIGNvbnRhbnRzXG4vLyBGaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEs1MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG5jb25zdCBTSEE1MTJfS2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMF0pKCk7XG5jb25zdCBTSEE1MTJfS2wgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMV0pKCk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gNjQpIHtcbiAgICAgICAgc3VwZXIoMTI4LCBvdXRwdXRMZW4sIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gU0hBNTEyX0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFNIQTUxMl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBTSEE1MTJfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gU0hBNTEyX0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFNIQTUxMl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBTSEE1MTJfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gU0hBNTEyX0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFNIQTUxMl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBTSEE1MTJfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gU0hBNTEyX0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFNIQTUxMl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gU0hBNTEyX0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBTSEE1MTJfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFNIQTUxMl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gU0hBNTEyX0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBTSEE1MTJfSVZbMTVdIHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIGNsZWFuKFNIQTUxMl9XX0gsIFNIQTUxMl9XX0wpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig0OCk7XG4gICAgICAgIHRoaXMuQWggPSBTSEEzODRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gU0hBMzg0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFNIQTM4NF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBTSEEzODRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gU0hBMzg0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFNIQTM4NF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBTSEEzODRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gU0hBMzg0X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFNIQTM4NF9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBTSEEzODRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gU0hBMzg0X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBTSEEzODRfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFNIQTM4NF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gU0hBMzg0X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBTSEEzODRfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFNIQTM4NF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbi8qKlxuICogVHJ1bmNhdGVkIFNIQTUxMi8yNTYgYW5kIFNIQTUxMi8yMjQuXG4gKiBTSEE1MTJfSVYgaXMgWE9SZWQgd2l0aCAweGE1YTVhNWE1YTVhNWE1YTUsIHRoZW4gdXNlZCBhcyBcImludGVybWVkaWFyeVwiIElWIG9mIFNIQTUxMi90LlxuICogVGhlbiB0IGhhc2hlcyBzdHJpbmcgdG8gcHJvZHVjZSByZXN1bHQgSVYuXG4gKiBTZWUgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AuXG4gKi9cbi8qKiBTSEE1MTIvMjI0IElWICovXG5jb25zdCBUMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4OGMzZDM3YzgsIDB4MTk1NDRkYTIsIDB4NzNlMTk5NjYsIDB4ODlkY2Q0ZDYsIDB4MWRmYWI3YWUsIDB4MzJmZjljODIsIDB4Njc5ZGQ1MTQsIDB4NTgyZjlmY2YsXG4gICAgMHgwZjZkMmI2OSwgMHg3YmQ0NGRhOCwgMHg3N2UzNmY3MywgMHgwNGM0ODk0MiwgMHgzZjlkODVhOCwgMHg2YTFkMzZjOCwgMHgxMTEyZTZhZCwgMHg5MWQ2OTJhMSxcbl0pO1xuLyoqIFNIQTUxMi8yNTYgSVYgKi9cbmNvbnN0IFQyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHgyMjMxMjE5NCwgMHhmYzJiZjcyYywgMHg5ZjU1NWZhMywgMHhjODRjNjRjMiwgMHgyMzkzYjg2YiwgMHg2ZjUzYjE1MSwgMHg5NjM4NzcxOSwgMHg1OTQwZWFiZCxcbiAgICAweDk2MjgzZWUyLCAweGE4OGVmZmUzLCAweGJlNWUxZTI1LCAweDUzODYzOTkyLCAweDJiMDE5OWZjLCAweDJjODViOGFhLCAweDBlYjcyZGRjLCAweDgxYzUyY2EyLFxuXSk7XG5leHBvcnQgY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BaCA9IFQyMjRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gVDIyNF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBUMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFQyMjRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gVDIyNF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBUMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFQyMjRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gVDIyNF9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBUMjI0X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFQyMjRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gVDIyNF9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gVDIyNF9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gVDIyNF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gVDIyNF9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gVDIyNF9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gVDIyNF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMzIpO1xuICAgICAgICB0aGlzLkFoID0gVDI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBUMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFQyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gVDI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBUMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFQyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gVDI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBUMjU2X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFQyNTZfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gVDI1Nl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBUMjU2X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBUMjU2X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBUMjU2X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBUMjU2X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBUMjU2X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBUMjU2X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuXG4gKlxuICogSXQgaXMgdGhlIGZhc3Rlc3QgSlMgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTI1NigpKTtcbi8qKiBTSEEyLTIyNCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQgKi9cbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vKiogU0hBMi01MTIgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTUxMigpKTtcbi8qKiBTSEEyLTM4NCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yNTYgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yMjQgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha256.js":
/*!******************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/sha256.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sha2.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\n\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst SHA256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst sha256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst SHA224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst sha224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha224;\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dHO0FBQ3hHO0FBQ08sZUFBZSw0Q0FBTztBQUM3QjtBQUNPLGVBQWUsNENBQU87QUFDN0I7QUFDTyxlQUFlLDRDQUFPO0FBQzdCO0FBQ08sZUFBZSw0Q0FBTztBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/ZDBhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNIQTItMjU2IGEuay5hLiBzaGEyNTYuIEluIEpTLCBpdCBpcyB0aGUgZmFzdGVzdCBoYXNoLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqXG4gKiBDaGVjayBvdXQgW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuaW1wb3J0IHsgU0hBMjI0IGFzIFNIQTIyNG4sIHNoYTIyNCBhcyBzaGEyMjRuLCBTSEEyNTYgYXMgU0hBMjU2biwgc2hhMjU2IGFzIHNoYTI1Nm4sIH0gZnJvbSBcIi4vc2hhMi5qc1wiO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1NiA9IFNIQTI1Nm47XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gc2hhMjU2bjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBTSEEyMjQgPSBTSEEyMjRuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IHNoYTIyNG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha3.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/sha3.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\n\n// prettier-ignore\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(B);\n}\n/** Keccak sponge function. */\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200))\n            throw new Error('only keccak-f1600 function is supported');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        keccakP(this.state32, this.rounds);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this, false);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nconst sha3_224 = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nconst sha3_256 = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nconst sha3_384 = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nconst sha3_512 = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */\nconst keccak_224 = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nconst keccak_256 = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nconst keccak_384 = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nconst keccak_512 = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nconst shake128 = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nconst shake256 = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tFO0FBQ2xFO0FBQ2lJO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0NBQU0sWUFBWSwrQ0FBTTtBQUM3RCxxQ0FBcUMsK0NBQU0sWUFBWSwrQ0FBTTtBQUM3RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFLO0FBQ1Q7QUFDQTtBQUNPLHFCQUFxQiwyQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQVU7QUFDbEI7QUFDQSxRQUFRLHFEQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLGVBQWUsa0RBQU87QUFDdEIsUUFBUSxpREFBTTtBQUNkLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLFFBQVEsaURBQU07QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1REFBWTtBQUN6RDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQLGtEQUFrRCxzREFBVyxXQUFXO0FBQ3hFO0FBQ087QUFDUDtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcz8yYzRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU0hBMyAoa2VjY2FrKSBoYXNoIGZ1bmN0aW9uLCBiYXNlZCBvbiBhIG5ldyBcIlNwb25nZSBmdW5jdGlvblwiIGRlc2lnbi5cbiAqIERpZmZlcmVudCBmcm9tIG9sZGVyIGhhc2hlcywgdGhlIGludGVybmFsIHN0YXRlIGlzIGJpZ2dlciB0aGFuIG91dHB1dCBzaXplLlxuICpcbiAqIENoZWNrIG91dCBbRklQUy0yMDJdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4yMDIucGRmKSxcbiAqIFtXZWJzaXRlXShodHRwczovL2tlY2Nhay50ZWFtL2tlY2Nhay5odG1sKSxcbiAqIFt0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBTSEEtMyBhbmQgS2VjY2FrXShodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTU3Mjcvd2hhdC1hcmUtdGhlLWtleS1kaWZmZXJlbmNlcy1iZXR3ZWVuLXRoZS1kcmFmdC1zaGEtMy1zdGFuZGFyZC1hbmQtdGhlLWtlY2Nhay1zdWIpLlxuICpcbiAqIENoZWNrIG91dCBgc2hhMy1hZGRvbnNgIG1vZHVsZSBmb3IgY1NIQUtFLCBrMTIsIGFuZCBvdGhlcnMuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IHJvdGxCSCwgcm90bEJMLCByb3RsU0gsIHJvdGxTTCwgc3BsaXQgfSBmcm9tIFwiLi9fdTY0LmpzXCI7XG4vLyBwcmV0dGllci1pZ25vcmVcbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYW51bWJlciwgYW91dHB1dCwgY2xlYW4sIGNyZWF0ZUhhc2hlciwgY3JlYXRlWE9GZXIsIEhhc2gsIHN3YXAzMklmQkUsIHRvQnl0ZXMsIHUzMiB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBObyBfX1BVUkVfXyBhbm5vdGF0aW9ucyBpbiBzaGEzIGhlYWRlcjpcbi8vIEVWRVJZVEhJTkcgaXMgaW4gZmFjdCB1c2VkIG9uIGV2ZXJ5IGV4cG9ydC5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSBCaWdJbnQoMHg3MSk7XG5jb25zdCBTSEEzX1BJID0gW107XG5jb25zdCBTSEEzX1JPVEwgPSBbXTtcbmNvbnN0IF9TSEEzX0lPVEEgPSBbXTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgSU9UQVMgPSBzcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcbmNvbnN0IFNIQTNfSU9UQV9IID0gSU9UQVNbMF07XG5jb25zdCBTSEEzX0lPVEFfTCA9IElPVEFTWzFdO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gcm90bEJIKGgsIGwsIHMpIDogcm90bFNIKGgsIGwsIHMpKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkwoaCwgbCwgcykgOiByb3RsU0woaCwgbCwgcykpO1xuLyoqIGBrZWNjYWtmMTYwMGAgaW50ZXJuYWwgZnVuY3Rpb24sIGFkZGl0aW9uYWxseSBhbGxvd3MgdG8gYWRqdXN0IHJvdW5kIGNvdW50LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIGNsZWFuKEIpO1xufVxuLyoqIEtlY2NhayBzcG9uZ2UgZnVuY3Rpb24uICovXG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBhbnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgLy8gMCA8IGJsb2NrTGVuIDwgMjAwXG4gICAgICAgIGlmICghKDAgPCBibG9ja0xlbiAmJiBibG9ja0xlbiA8IDIwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIHN3YXAzMklmQkUodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcbiAgICAgICAgc3dhcDMySWZCRSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYWJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBhbnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIGNsZWFuKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuLyoqIFNIQTMtMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpKSgpO1xuLyoqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIGtlY2Nhay0yNTYuICovXG5leHBvcnQgY29uc3Qgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCAxMzYsIDI1NiAvIDgpKSgpO1xuLyoqIFNIQTMtMzg0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCAxMDQsIDM4NCAvIDgpKSgpO1xuLyoqIFNIQTMtNTEyIGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDA2LCA3MiwgNTEyIC8gOCkpKCk7XG4vKioga2VjY2FrLTIyNCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCAxNDQsIDIyNCAvIDgpKSgpO1xuLyoqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCkpKCk7XG4vKioga2VjY2FrLTM4NCBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18zODQgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCAxMDQsIDM4NCAvIDgpKSgpO1xuLyoqIGtlY2Nhay01MTIgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpKSgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiBjcmVhdGVYT0Zlcigob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcbi8qKiBTSEFLRTEyOCBYT0Ygd2l0aCAxMjgtYml0IHNlY3VyaXR5LiAqL1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpKSgpO1xuLyoqIFNIQUtFMjU2IFhPRiB3aXRoIDI1Ni1iaXQgc2VjdXJpdHkuICovXG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCkpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/hashes/esm/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   createOptHasher: () => (/* binding */ createOptHasher),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   createXOFer: () => (/* binding */ createXOFer),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   kdfInputToBytes: () => (/* binding */ kdfInputToBytes),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   swap32IfBE: () => (/* binding */ swap32IfBE),\n/* harmony export */   swap8IfBE: () => (/* binding */ swap8IfBE),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nconst isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nconst swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nconst byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nconst swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nconst wrapConstructor = createHasher;\nconst wrapConstructorWithOpts = createOptHasher;\nconst wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes === 'function') {\n        return Uint8Array.from(_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQiwrQkFBK0Isd0RBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9veC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/MzM5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5leHBvcnQgZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgJyArIG4pO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5leHBvcnQgZnVuY3Rpb24gYWJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIGhhc2ggKi9cbmV4cG9ydCBmdW5jdGlvbiBhaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLmNyZWF0ZUhhc2hlcicpO1xuICAgIGFudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIGFudW1iZXIoaC5ibG9ja0xlbik7XG59XG4vKiogQXNzZXJ0cyBhIGhhc2ggaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGRlc3Ryb3llZCAvIGZpbmlzaGVkICovXG5leHBvcnQgZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuLyoqIEFzc2VydHMgb3V0cHV0IGlzIHByb3Blcmx5LXNpemVkIGJ5dGUgYXJyYXkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBhYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAnICsgbWluKTtcbiAgICB9XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8qKiBaZXJvaXplIGEgYnl0ZSBhcnJheS4gV2FybmluZzogSlMgcHJvdmlkZXMgbm8gZ3VhcmFudGVlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdHIod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG4vKiogVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGwod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydCBjb25zdCBpc0xFID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLyoqIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICgoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gMjQpICYgMHhmZikpO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0IGNvbnN0IHN3YXA4SWZCRSA9IGlzTEVcbiAgICA/IChuKSA9PiBuXG4gICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBieXRlU3dhcElmQkUgPSBzd2FwOElmQkU7XG4vKiogSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBjb25zdCBzd2FwMzJJZkJFID0gaXNMRVxuICAgID8gKHUpID0+IHVcbiAgICA6IGJ5dGVTd2FwMzI7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogSGVscGVyIGZvciBLREZzOiBjb25zdW1lcyB1aW50OGFycmF5IG9yIHN0cmluZy5cbiAqIFdoZW4gc3RyaW5nIGlzIHBhc3NlZCwgZG9lcyB1dGY4IGRlY29kaW5nLCB1c2luZyBUZXh0RGVjb2Rlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtkZklucHV0VG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHt9LnRvU3RyaW5nLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlICovXG5leHBvcnQgY2xhc3MgSGFzaCB7XG59XG4vKiogV3JhcHMgaGFzaCBmdW5jdGlvbiwgY3JlYXRpbmcgYW4gaW50ZXJmYWNlIG9uIHRvcCBvZiBpdCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3B0SGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVhPRmVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGNvbnN0IHdyYXBDb25zdHJ1Y3RvciA9IGNyZWF0ZUhhc2hlcjtcbmV4cG9ydCBjb25zdCB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZU9wdEhhc2hlcjtcbmV4cG9ydCBjb25zdCB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZVhPRmVyO1xuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;
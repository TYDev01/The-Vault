"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/c32check";
exports.ids = ["vendor-chunks/c32check"];
exports.modules = {

/***/ "(ssr)/./node_modules/c32check/lib/address.js":
/*!**********************************************!*\
  !*** ./node_modules/c32check/lib/address.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\nconst checksum_1 = __webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/c32check/lib/checksum.js\");\nconst base58check = __webpack_require__(/*! ./base58check */ \"(ssr)/./node_modules/c32check/lib/base58check.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nexports.versions = {\n    mainnet: {\n        p2pkh: 22,\n        p2sh: 20, // 'M'\n    },\n    testnet: {\n        p2pkh: 26,\n        p2sh: 21, // 'N'\n    },\n};\n// address conversion : bitcoin to stacks\nconst ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;\n// address conversion : stacks to bitcoin\nconst ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */\nfunction c32address(version, hash160hex) {\n    if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n        throw new Error('Invalid argument: not a hash160 hex string');\n    }\n    const c32string = (0, checksum_1.c32checkEncode)(version, hash160hex);\n    return `S${c32string}`;\n}\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */\nfunction c32addressDecode(c32addr) {\n    if (c32addr.length <= 5) {\n        throw new Error('Invalid c32 address: invalid length');\n    }\n    if (c32addr[0] != 'S') {\n        throw new Error('Invalid c32 address: must start with \"S\"');\n    }\n    return (0, checksum_1.c32checkDecode)(c32addr.slice(1));\n}\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */\nfunction b58ToC32(b58check, version = -1) {\n    const addrInfo = base58check.decode(b58check);\n    const hash160String = (0, utils_1.bytesToHex)(addrInfo.data);\n    const addrVersion = parseInt((0, utils_1.bytesToHex)(addrInfo.prefix), 16);\n    let stacksVersion;\n    if (version < 0) {\n        stacksVersion = addrVersion;\n        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n            stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n        }\n    }\n    else {\n        stacksVersion = version;\n    }\n    return c32address(stacksVersion, hash160String);\n}\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */\nfunction c32ToB58(c32string, version = -1) {\n    const addrInfo = c32addressDecode(c32string);\n    const stacksVersion = addrInfo[0];\n    const hash160String = addrInfo[1];\n    let bitcoinVersion;\n    if (version < 0) {\n        bitcoinVersion = stacksVersion;\n        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n            bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n        }\n    }\n    else {\n        bitcoinVersion = version;\n    }\n    let prefix = bitcoinVersion.toString(16);\n    if (prefix.length === 1) {\n        prefix = `0${prefix}`;\n    }\n    return base58check.encode(hash160String, prefix);\n}\nexports.c32ToB58 = c32ToB58;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsd0JBQXdCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ3RHLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFlO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFxQjtBQUM3QyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2FkZHJlc3MuanM/NDk3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYzMyVG9CNTggPSBleHBvcnRzLmI1OFRvQzMyID0gZXhwb3J0cy5jMzJhZGRyZXNzRGVjb2RlID0gZXhwb3J0cy5jMzJhZGRyZXNzID0gZXhwb3J0cy52ZXJzaW9ucyA9IHZvaWQgMDtcbmNvbnN0IGNoZWNrc3VtXzEgPSByZXF1aXJlKFwiLi9jaGVja3N1bVwiKTtcbmNvbnN0IGJhc2U1OGNoZWNrID0gcmVxdWlyZShcIi4vYmFzZTU4Y2hlY2tcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5leHBvcnRzLnZlcnNpb25zID0ge1xuICAgIG1haW5uZXQ6IHtcbiAgICAgICAgcDJwa2g6IDIyLFxuICAgICAgICBwMnNoOiAyMCwgLy8gJ00nXG4gICAgfSxcbiAgICB0ZXN0bmV0OiB7XG4gICAgICAgIHAycGtoOiAyNixcbiAgICAgICAgcDJzaDogMjEsIC8vICdOJ1xuICAgIH0sXG59O1xuLy8gYWRkcmVzcyBjb252ZXJzaW9uIDogYml0Y29pbiB0byBzdGFja3NcbmNvbnN0IEFERFJfQklUQ09JTl9UT19TVEFDS1MgPSB7fTtcbkFERFJfQklUQ09JTl9UT19TVEFDS1NbMF0gPSBleHBvcnRzLnZlcnNpb25zLm1haW5uZXQucDJwa2g7XG5BRERSX0JJVENPSU5fVE9fU1RBQ0tTWzVdID0gZXhwb3J0cy52ZXJzaW9ucy5tYWlubmV0LnAyc2g7XG5BRERSX0JJVENPSU5fVE9fU1RBQ0tTWzExMV0gPSBleHBvcnRzLnZlcnNpb25zLnRlc3RuZXQucDJwa2g7XG5BRERSX0JJVENPSU5fVE9fU1RBQ0tTWzE5Nl0gPSBleHBvcnRzLnZlcnNpb25zLnRlc3RuZXQucDJzaDtcbi8vIGFkZHJlc3MgY29udmVyc2lvbiA6IHN0YWNrcyB0byBiaXRjb2luXG5jb25zdCBBRERSX1NUQUNLU19UT19CSVRDT0lOID0ge307XG5BRERSX1NUQUNLU19UT19CSVRDT0lOW2V4cG9ydHMudmVyc2lvbnMubWFpbm5ldC5wMnBraF0gPSAwO1xuQUREUl9TVEFDS1NfVE9fQklUQ09JTltleHBvcnRzLnZlcnNpb25zLm1haW5uZXQucDJzaF0gPSA1O1xuQUREUl9TVEFDS1NfVE9fQklUQ09JTltleHBvcnRzLnZlcnNpb25zLnRlc3RuZXQucDJwa2hdID0gMTExO1xuQUREUl9TVEFDS1NfVE9fQklUQ09JTltleHBvcnRzLnZlcnNpb25zLnRlc3RuZXQucDJzaF0gPSAxOTY7XG4vKipcbiAqIE1ha2UgYSBjMzJjaGVjayBhZGRyZXNzIHdpdGggdGhlIGdpdmVuIHZlcnNpb24gYW5kIGhhc2gxNjBcbiAqIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiBhIGMzMmNoZWNrIHN0cmluZyBhbmQgYzMyIGFkZHJlc3NcbiAqIGlzIHRoYXQgdGhlIGxldHRlciAnUycgaXMgcHJlLXBlbmRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uIC0gdGhlIGFkZHJlc3MgdmVyc2lvbiBudW1iZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoMTYwaGV4IC0gdGhlIGhhc2gxNjAgdG8gZW5jb2RlIChtdXN0IGJlIGEgaGFzaDE2MClcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBhZGRyZXNzXG4gKi9cbmZ1bmN0aW9uIGMzMmFkZHJlc3ModmVyc2lvbiwgaGFzaDE2MGhleCkge1xuICAgIGlmICghaGFzaDE2MGhleC5tYXRjaCgvXlswLTlhLWZBLUZdezQwfSQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQ6IG5vdCBhIGhhc2gxNjAgaGV4IHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBjMzJzdHJpbmcgPSAoMCwgY2hlY2tzdW1fMS5jMzJjaGVja0VuY29kZSkodmVyc2lvbiwgaGFzaDE2MGhleCk7XG4gICAgcmV0dXJuIGBTJHtjMzJzdHJpbmd9YDtcbn1cbmV4cG9ydHMuYzMyYWRkcmVzcyA9IGMzMmFkZHJlc3M7XG4vKipcbiAqIERlY29kZSBhIGMzMiBhZGRyZXNzIGludG8gaXRzIHZlcnNpb24gYW5kIGhhc2gxNjBcbiAqIEBwYXJhbSB7c3RyaW5nfSBjMzJhZGRyIC0gdGhlIGMzMmNoZWNrLWVuY29kZWQgYWRkcmVzc1xuICogQHJldHVybnMge1tudW1iZXIsIHN0cmluZ119IGEgdHVwbGUgd2l0aCB0aGUgdmVyc2lvbiBhbmQgaGFzaDE2MFxuICovXG5mdW5jdGlvbiBjMzJhZGRyZXNzRGVjb2RlKGMzMmFkZHIpIHtcbiAgICBpZiAoYzMyYWRkci5sZW5ndGggPD0gNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYzMyIGFkZHJlc3M6IGludmFsaWQgbGVuZ3RoJyk7XG4gICAgfVxuICAgIGlmIChjMzJhZGRyWzBdICE9ICdTJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYzMyIGFkZHJlc3M6IG11c3Qgc3RhcnQgd2l0aCBcIlNcIicpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGNoZWNrc3VtXzEuYzMyY2hlY2tEZWNvZGUpKGMzMmFkZHIuc2xpY2UoMSkpO1xufVxuZXhwb3J0cy5jMzJhZGRyZXNzRGVjb2RlID0gYzMyYWRkcmVzc0RlY29kZTtcbi8qXG4gKiBDb252ZXJ0IGEgYmFzZTU4Y2hlY2sgYWRkcmVzcyB0byBhIGMzMmNoZWNrIGFkZHJlc3MuXG4gKiBUcnkgdG8gY29udmVydCB0aGUgdmVyc2lvbiBudW1iZXIgaWYgb25lIGlzIG5vdCBnaXZlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiNThjaGVjayAtIHRoZSBiYXNlNThjaGVjayBlbmNvZGVkIGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uIC0gdGhlIHZlcnNpb24gbnVtYmVyLCBpZiBub3QgaW5mZXJyZWQgZnJvbSB0aGUgYWRkcmVzc1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGMzMiBhZGRyZXNzIHdpdGggdGhlIGdpdmVuIHZlcnNpb24gbnVtYmVyIChvciB0aGVcbiAqICAgc2VtYW50aWNhbGx5LWVxdWl2YWxlbnQgYzMyIHZlcnNpb24gbnVtYmVyLCBpZiBub3QgZ2l2ZW4pXG4gKi9cbmZ1bmN0aW9uIGI1OFRvQzMyKGI1OGNoZWNrLCB2ZXJzaW9uID0gLTEpIHtcbiAgICBjb25zdCBhZGRySW5mbyA9IGJhc2U1OGNoZWNrLmRlY29kZShiNThjaGVjayk7XG4gICAgY29uc3QgaGFzaDE2MFN0cmluZyA9ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGFkZHJJbmZvLmRhdGEpO1xuICAgIGNvbnN0IGFkZHJWZXJzaW9uID0gcGFyc2VJbnQoKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoYWRkckluZm8ucHJlZml4KSwgMTYpO1xuICAgIGxldCBzdGFja3NWZXJzaW9uO1xuICAgIGlmICh2ZXJzaW9uIDwgMCkge1xuICAgICAgICBzdGFja3NWZXJzaW9uID0gYWRkclZlcnNpb247XG4gICAgICAgIGlmIChBRERSX0JJVENPSU5fVE9fU1RBQ0tTW2FkZHJWZXJzaW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFja3NWZXJzaW9uID0gQUREUl9CSVRDT0lOX1RPX1NUQUNLU1thZGRyVmVyc2lvbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YWNrc1ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gYzMyYWRkcmVzcyhzdGFja3NWZXJzaW9uLCBoYXNoMTYwU3RyaW5nKTtcbn1cbmV4cG9ydHMuYjU4VG9DMzIgPSBiNThUb0MzMjtcbi8qXG4gKiBDb252ZXJ0IGEgYzMyY2hlY2sgYWRkcmVzcyB0byBhIGJhc2U1OGNoZWNrIGFkZHJlc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gYzMyc3RyaW5nIC0gdGhlIGMzMmNoZWNrIGFkZHJlc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uIC0gdGhlIHZlcnNpb24gbnVtYmVyLCBpZiBub3QgaW5mZXJyZWQgZnJvbSB0aGUgYWRkcmVzc1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGJhc2U1OCBhZGRyZXNzIHdpdGggdGhlIGdpdmVuIHZlcnNpb24gbnVtYmVyIChvciB0aGVcbiAqICAgIHNlbWFudGljYWxseS1lcXVpdmFsZW50IGJpdGNvaW4gdmVyc2lvbiBudW1iZXIsIGlmIG5vdCBnaXZlbilcbiAqL1xuZnVuY3Rpb24gYzMyVG9CNTgoYzMyc3RyaW5nLCB2ZXJzaW9uID0gLTEpIHtcbiAgICBjb25zdCBhZGRySW5mbyA9IGMzMmFkZHJlc3NEZWNvZGUoYzMyc3RyaW5nKTtcbiAgICBjb25zdCBzdGFja3NWZXJzaW9uID0gYWRkckluZm9bMF07XG4gICAgY29uc3QgaGFzaDE2MFN0cmluZyA9IGFkZHJJbmZvWzFdO1xuICAgIGxldCBiaXRjb2luVmVyc2lvbjtcbiAgICBpZiAodmVyc2lvbiA8IDApIHtcbiAgICAgICAgYml0Y29pblZlcnNpb24gPSBzdGFja3NWZXJzaW9uO1xuICAgICAgICBpZiAoQUREUl9TVEFDS1NfVE9fQklUQ09JTltzdGFja3NWZXJzaW9uXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBiaXRjb2luVmVyc2lvbiA9IEFERFJfU1RBQ0tTX1RPX0JJVENPSU5bc3RhY2tzVmVyc2lvbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJpdGNvaW5WZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG4gICAgbGV0IHByZWZpeCA9IGJpdGNvaW5WZXJzaW9uLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwcmVmaXggPSBgMCR7cHJlZml4fWA7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNThjaGVjay5lbmNvZGUoaGFzaDE2MFN0cmluZywgcHJlZml4KTtcbn1cbmV4cG9ydHMuYzMyVG9CNTggPSBjMzJUb0I1ODtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/base58check.js":
/*!**************************************************!*\
  !*** ./node_modules/c32check/lib/base58check.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * From https://github.com/wzbg/base58check\n * @Author: zyc\n * @Date:   2016-09-11 23:36:05\n */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js\");\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nfunction encode(data, prefix = '00') {\n    const dataBytes = typeof data === 'string' ? (0, utils_1.hexToBytes)(data) : data;\n    const prefixBytes = typeof prefix === 'string' ? (0, utils_1.hexToBytes)(prefix) : data;\n    if (!(dataBytes instanceof Uint8Array) || !(prefixBytes instanceof Uint8Array)) {\n        throw new TypeError('Argument must be of type Uint8Array or string');\n    }\n    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));\n    return basex(ALPHABET).encode([...prefixBytes, ...dataBytes, ...checksum.slice(0, 4)]);\n}\nexports.encode = encode;\nfunction decode(string) {\n    const bytes = basex(ALPHABET).decode(string);\n    const prefixBytes = bytes.slice(0, 1);\n    const dataBytes = bytes.slice(1, -4);\n    // todo: for better performance replace spread with `concatBytes` method\n    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));\n    bytes.slice(-4).forEach((check, index) => {\n        if (check !== checksum[index]) {\n            throw new Error('Invalid checksum');\n        }\n    });\n    return { prefix: prefixBytes, data: dataBytes };\n}\nexports.decode = decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2Jhc2U1OGNoZWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDLGNBQWMsbUJBQU8sQ0FBQyw4RUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2F2aW5ndmF1bHQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2Jhc2U1OGNoZWNrLmpzPzRhZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL3d6YmcvYmFzZTU4Y2hlY2tcbiAqIEBBdXRob3I6IHp5Y1xuICogQERhdGU6ICAgMjAxNi0wOS0xMSAyMzozNjowNVxuICovXG4ndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBiYXNleCA9IHJlcXVpcmUoXCJiYXNlLXhcIik7XG5jb25zdCBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6JztcbmZ1bmN0aW9uIGVuY29kZShkYXRhLCBwcmVmaXggPSAnMDAnKSB7XG4gICAgY29uc3QgZGF0YUJ5dGVzID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoZGF0YSkgOiBkYXRhO1xuICAgIGNvbnN0IHByZWZpeEJ5dGVzID0gdHlwZW9mIHByZWZpeCA9PT0gJ3N0cmluZycgPyAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShwcmVmaXgpIDogZGF0YTtcbiAgICBpZiAoIShkYXRhQnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCAhKHByZWZpeEJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIFVpbnQ4QXJyYXkgb3Igc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrc3VtID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoKDAsIHNoYTI1Nl8xLnNoYTI1NikobmV3IFVpbnQ4QXJyYXkoWy4uLnByZWZpeEJ5dGVzLCAuLi5kYXRhQnl0ZXNdKSkpO1xuICAgIHJldHVybiBiYXNleChBTFBIQUJFVCkuZW5jb2RlKFsuLi5wcmVmaXhCeXRlcywgLi4uZGF0YUJ5dGVzLCAuLi5jaGVja3N1bS5zbGljZSgwLCA0KV0pO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5mdW5jdGlvbiBkZWNvZGUoc3RyaW5nKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBiYXNleChBTFBIQUJFVCkuZGVjb2RlKHN0cmluZyk7XG4gICAgY29uc3QgcHJlZml4Qnl0ZXMgPSBieXRlcy5zbGljZSgwLCAxKTtcbiAgICBjb25zdCBkYXRhQnl0ZXMgPSBieXRlcy5zbGljZSgxLCAtNCk7XG4gICAgLy8gdG9kbzogZm9yIGJldHRlciBwZXJmb3JtYW5jZSByZXBsYWNlIHNwcmVhZCB3aXRoIGBjb25jYXRCeXRlc2AgbWV0aG9kXG4gICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgc2hhMjU2XzEuc2hhMjU2KSgoMCwgc2hhMjU2XzEuc2hhMjU2KShuZXcgVWludDhBcnJheShbLi4ucHJlZml4Qnl0ZXMsIC4uLmRhdGFCeXRlc10pKSk7XG4gICAgYnl0ZXMuc2xpY2UoLTQpLmZvckVhY2goKGNoZWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoY2hlY2sgIT09IGNoZWNrc3VtW2luZGV4XSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4geyBwcmVmaXg6IHByZWZpeEJ5dGVzLCBkYXRhOiBkYXRhQnl0ZXMgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/base58check.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/checksum.js":
/*!***********************************************!*\
  !*** ./node_modules/c32check/lib/checksum.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/c32check/lib/encoding.js\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */\nfunction c32checksum(dataHex) {\n    const dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));\n    const checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));\n    return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */\nfunction c32checkEncode(version, data) {\n    if (version < 0 || version >= 32) {\n        throw new Error('Invalid version (must be between 0 and 31)');\n    }\n    if (!data.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Invalid data (not a hex string)');\n    }\n    data = data.toLowerCase();\n    if (data.length % 2 !== 0) {\n        data = `0${data}`;\n    }\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    const checksumHex = c32checksum(`${versionHex}${data}`);\n    const c32str = (0, encoding_1.c32encode)(`${data}${checksumHex}`);\n    return `${encoding_1.c32[version]}${c32str}`;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */\nfunction c32checkDecode(c32data) {\n    c32data = (0, encoding_1.c32normalize)(c32data);\n    const dataHex = (0, encoding_1.c32decode)(c32data.slice(1));\n    const versionChar = c32data[0];\n    const version = encoding_1.c32.indexOf(versionChar);\n    const checksum = dataHex.slice(-8);\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    if (c32checksum(`${versionHex}${dataHex.substring(0, dataHex.length - 8)}`) !== checksum) {\n        throw new Error('Invalid c32check string: checksum mismatch');\n    }\n    return [version, dataHex.substring(0, dataHex.length - 8)];\n}\nexports.c32checkDecode = c32checkDecode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2NoZWNrc3VtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLHNCQUFzQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBLHVDQUF1QyxXQUFXLEVBQUUsS0FBSztBQUN6RCxnREFBZ0QsS0FBSyxFQUFFLFlBQVk7QUFDbkUsY0FBYyx3QkFBd0IsRUFBRSxPQUFPO0FBQy9DO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQSx1QkFBdUIsV0FBVyxFQUFFLHlDQUF5QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2MzMmNoZWNrL2xpYi9jaGVja3N1bS5qcz8xYWRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jMzJjaGVja0RlY29kZSA9IGV4cG9ydHMuYzMyY2hlY2tFbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbi8qKlxuICogR2V0IHRoZSBjMzJjaGVjayBjaGVja3N1bSBvZiBhIGhleC1lbmNvZGVkIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFIZXggLSB0aGUgaGV4IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGMzMiBjaGVja3N1bSwgYXMgYSBiaW4tZW5jb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYzMyY2hlY2tzdW0oZGF0YUhleCkge1xuICAgIGNvbnN0IGRhdGFIYXNoID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoKDAsIHNoYTI1Nl8xLnNoYTI1NikoKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoZGF0YUhleCkpKTtcbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGRhdGFIYXNoLnNsaWNlKDAsIDQpKTtcbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG4vKipcbiAqIEVuY29kZSBhIGhleCBzdHJpbmcgYXMgYSBjMzJjaGVjayBzdHJpbmcuICBUaGlzIGlzIGEgbG90IGxpa2UgaG93XG4gKiBiYXNlNThjaGVjayB3b3JrcyBpbiBCaXRjb2luLWxhbmQsIGJ1dCB0aGlzIGFsZ29yaXRobSB1c2VzIHRoZVxuICogei1iYXNlLTMyIGFscGhhYmV0IGluc3RlYWQgb2YgdGhlIGJhc2U1OCBhbHBoYWJldC4gIFRoZSBhbGdvcml0aG1cbiAqIGlzIGFzIGZvbGxvd3M6XG4gKiAqIGNhbGN1bGF0ZSB0aGUgYzMyY2hlY2tzdW0gb2YgdmVyc2lvbiArIGRhdGFcbiAqICogYzMyZW5jb2RlIHZlcnNpb24gKyBkYXRhICsgYzMyY2hlY2tzdW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uIC0gdGhlIHZlcnNpb24gc3RyaW5nIChiZXR3ZWVuIDAgYW5kIDMxKVxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSB0aGUgZGF0YSB0byBlbmNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjMzJjaGVjayByZXByZXNlbnRhdGlvblxuICovXG5mdW5jdGlvbiBjMzJjaGVja0VuY29kZSh2ZXJzaW9uLCBkYXRhKSB7XG4gICAgaWYgKHZlcnNpb24gPCAwIHx8IHZlcnNpb24gPj0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnNpb24gKG11c3QgYmUgYmV0d2VlbiAwIGFuZCAzMSknKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhLm1hdGNoKC9eWzAtOWEtZkEtRl0qJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIChub3QgYSBoZXggc3RyaW5nKScpO1xuICAgIH1cbiAgICBkYXRhID0gZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgZGF0YSA9IGAwJHtkYXRhfWA7XG4gICAgfVxuICAgIGxldCB2ZXJzaW9uSGV4ID0gdmVyc2lvbi50b1N0cmluZygxNik7XG4gICAgaWYgKHZlcnNpb25IZXgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZlcnNpb25IZXggPSBgMCR7dmVyc2lvbkhleH1gO1xuICAgIH1cbiAgICBjb25zdCBjaGVja3N1bUhleCA9IGMzMmNoZWNrc3VtKGAke3ZlcnNpb25IZXh9JHtkYXRhfWApO1xuICAgIGNvbnN0IGMzMnN0ciA9ICgwLCBlbmNvZGluZ18xLmMzMmVuY29kZSkoYCR7ZGF0YX0ke2NoZWNrc3VtSGV4fWApO1xuICAgIHJldHVybiBgJHtlbmNvZGluZ18xLmMzMlt2ZXJzaW9uXX0ke2MzMnN0cn1gO1xufVxuZXhwb3J0cy5jMzJjaGVja0VuY29kZSA9IGMzMmNoZWNrRW5jb2RlO1xuLypcbiAqIERlY29kZSBhIGMzMmNoZWNrIHN0cmluZyBiYWNrIGludG8gaXRzIHZlcnNpb24gYW5kIGRhdGEgcGF5bG9hZC4gIFRoaXMgaXNcbiAqIGEgbG90IGxpa2UgaG93IGJhc2U1OGNoZWNrIHdvcmtzIGluIEJpdGNvaW4tbGFuZCwgYnV0IHRoaXMgYWxnb3JpdGhtIHVzZXNcbiAqIHRoZSB6LWJhc2UtMzIgYWxwaGFiZXQgaW5zdGVhZCBvZiB0aGUgYmFzZTU4IGFscGhhYmV0LiAgVGhlIGFsZ29yaXRobVxuICogaXMgYXMgZm9sbG93czpcbiAqICogZXh0cmFjdCB0aGUgdmVyc2lvbiwgZGF0YSwgYW5kIGNoZWNrc3VtXG4gKiAqIHZlcmlmeSB0aGUgY2hlY2tzdW0gbWF0Y2hlcyBjMzJjaGVja3N1bSh2ZXJzaW9uICsgZGF0YSlcbiAqICogcmV0dXJuIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBjMzJkYXRhIC0gdGhlIGMzMmNoZWNrLWVuY29kZWQgc3RyaW5nXG4gKiBAcmV0dXJucyB7YXJyYXl9IFt2ZXJzaW9uIChudW1iZXIpLCBkYXRhIChzdHJpbmcpXS4gIFRoZSByZXR1cm5lZCBkYXRhXG4gKiB3aWxsIGJlIGEgaGV4IHN0cmluZy4gIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIGNoZWNrc3VtIGRvZXMgbm90IG1hdGNoLlxuICovXG5mdW5jdGlvbiBjMzJjaGVja0RlY29kZShjMzJkYXRhKSB7XG4gICAgYzMyZGF0YSA9ICgwLCBlbmNvZGluZ18xLmMzMm5vcm1hbGl6ZSkoYzMyZGF0YSk7XG4gICAgY29uc3QgZGF0YUhleCA9ICgwLCBlbmNvZGluZ18xLmMzMmRlY29kZSkoYzMyZGF0YS5zbGljZSgxKSk7XG4gICAgY29uc3QgdmVyc2lvbkNoYXIgPSBjMzJkYXRhWzBdO1xuICAgIGNvbnN0IHZlcnNpb24gPSBlbmNvZGluZ18xLmMzMi5pbmRleE9mKHZlcnNpb25DaGFyKTtcbiAgICBjb25zdCBjaGVja3N1bSA9IGRhdGFIZXguc2xpY2UoLTgpO1xuICAgIGxldCB2ZXJzaW9uSGV4ID0gdmVyc2lvbi50b1N0cmluZygxNik7XG4gICAgaWYgKHZlcnNpb25IZXgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZlcnNpb25IZXggPSBgMCR7dmVyc2lvbkhleH1gO1xuICAgIH1cbiAgICBpZiAoYzMyY2hlY2tzdW0oYCR7dmVyc2lvbkhleH0ke2RhdGFIZXguc3Vic3RyaW5nKDAsIGRhdGFIZXgubGVuZ3RoIC0gOCl9YCkgIT09IGNoZWNrc3VtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjMzJjaGVjayBzdHJpbmc6IGNoZWNrc3VtIG1pc21hdGNoJyk7XG4gICAgfVxuICAgIHJldHVybiBbdmVyc2lvbiwgZGF0YUhleC5zdWJzdHJpbmcoMCwgZGF0YUhleC5sZW5ndGggLSA4KV07XG59XG5leHBvcnRzLmMzMmNoZWNrRGVjb2RlID0gYzMyY2hlY2tEZWNvZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/checksum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/encoding.js":
/*!***********************************************!*\
  !*** ./node_modules/c32check/lib/encoding.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nexports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';\nconst hex = '0123456789abcdef';\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */\nfunction c32encode(inputHex, minLength) {\n    // must be hex\n    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error('Not a hex-encoded string');\n    }\n    if (inputHex.length % 2 !== 0) {\n        inputHex = `0${inputHex}`;\n    }\n    inputHex = inputHex.toLowerCase();\n    let res = [];\n    let carry = 0;\n    for (let i = inputHex.length - 1; i >= 0; i--) {\n        if (carry < 4) {\n            const currentCode = hex.indexOf(inputHex[i]) >> carry;\n            let nextCode = 0;\n            if (i !== 0) {\n                nextCode = hex.indexOf(inputHex[i - 1]);\n            }\n            // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n            const nextBits = 1 + carry;\n            const nextLowBits = nextCode % (1 << nextBits) << (5 - nextBits);\n            const curC32Digit = exports.c32[currentCode + nextLowBits];\n            carry = nextBits;\n            res.unshift(curC32Digit);\n        }\n        else {\n            carry = 0;\n        }\n    }\n    let C32leadingZeros = 0;\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            C32leadingZeros++;\n        }\n    }\n    res = res.slice(C32leadingZeros);\n    const zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\\u0000*/);\n    const numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n    for (let i = 0; i < numLeadingZeroBytesInHex; i++) {\n        res.unshift(exports.c32[0]);\n    }\n    if (minLength) {\n        const count = minLength - res.length;\n        for (let i = 0; i < count; i++) {\n            res.unshift(exports.c32[0]);\n        }\n    }\n    return res.join('');\n}\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */\nfunction c32normalize(c32input) {\n    // must be upper-case\n    // replace all O's with 0's\n    // replace all I's and L's with 1's\n    return c32input.toUpperCase().replace(/O/g, '0').replace(/L|I/g, '1');\n}\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */\nfunction c32decode(c32input, minLength) {\n    c32input = c32normalize(c32input);\n    // must result in a c32 string\n    if (!c32input.match(`^[${exports.c32}]*$`)) {\n        throw new Error('Not a c32-encoded string');\n    }\n    const zeroPrefix = c32input.match(`^${exports.c32[0]}*`);\n    const numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n    let res = [];\n    let carry = 0;\n    let carryBits = 0;\n    for (let i = c32input.length - 1; i >= 0; i--) {\n        if (carryBits === 4) {\n            res.unshift(hex[carry]);\n            carryBits = 0;\n            carry = 0;\n        }\n        const currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n        const currentValue = currentCode + carry;\n        const currentHexDigit = hex[currentValue % 16];\n        carryBits += 1;\n        carry = currentValue >> 4;\n        if (carry > 1 << carryBits) {\n            throw new Error('Panic error in decoding.');\n        }\n        res.unshift(currentHexDigit);\n    }\n    // one last carry\n    res.unshift(hex[carry]);\n    if (res.length % 2 === 1) {\n        res.unshift('0');\n    }\n    let hexLeadingZeros = 0;\n    for (let i = 0; i < res.length; i++) {\n        if (res[i] !== '0') {\n            break;\n        }\n        else {\n            hexLeadingZeros++;\n        }\n    }\n    res = res.slice(hexLeadingZeros - (hexLeadingZeros % 2));\n    let hexStr = res.join('');\n    for (let i = 0; i < numLeadingZeroBytes; i++) {\n        hexStr = `00${hexStr}`;\n    }\n    if (minLength) {\n        const count = minLength * 2 - hexStr.length;\n        for (let i = 0; i < count; i += 2) {\n            hexStr = `00${hexStr}`;\n        }\n    }\n    return hexStr;\n}\nexports.c32decode = c32decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGlCQUFpQixHQUFHLFdBQVc7QUFDMUUsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQywwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2MzMmNoZWNrL2xpYi9lbmNvZGluZy5qcz82MzQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jMzJkZWNvZGUgPSBleHBvcnRzLmMzMm5vcm1hbGl6ZSA9IGV4cG9ydHMuYzMyZW5jb2RlID0gZXhwb3J0cy5jMzIgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5leHBvcnRzLmMzMiA9ICcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWic7XG5jb25zdCBoZXggPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG4vKipcbiAqIEVuY29kZSBhIGhleCBzdHJpbmcgYXMgYSBjMzIgc3RyaW5nLiAgTm90ZSB0aGF0IHRoZSBoZXggc3RyaW5nIGlzIGFzc3VtZWRcbiAqIHRvIGJlIGJpZy1lbmRpYW4gKGFuZCB0aGUgcmVzdWx0aW5nIGMzMiBzdHJpbmcgd2lsbCBiZSBhcyB3ZWxsKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dEhleCAtIHRoZSBpbnB1dCB0byBlbmNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5MZW5ndGggLSB0aGUgbWluaW11bSBsZW5ndGggb2YgdGhlIGMzMiBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjMzJjaGVjay1lbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXRhLCBhcyBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBjMzJlbmNvZGUoaW5wdXRIZXgsIG1pbkxlbmd0aCkge1xuICAgIC8vIG11c3QgYmUgaGV4XG4gICAgaWYgKCFpbnB1dEhleC5tYXRjaCgvXlswLTlhLWZBLUZdKiQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIGhleC1lbmNvZGVkIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoaW5wdXRIZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICBpbnB1dEhleCA9IGAwJHtpbnB1dEhleH1gO1xuICAgIH1cbiAgICBpbnB1dEhleCA9IGlucHV0SGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGlucHV0SGV4Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChjYXJyeSA8IDQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2RlID0gaGV4LmluZGV4T2YoaW5wdXRIZXhbaV0pID4+IGNhcnJ5O1xuICAgICAgICAgICAgbGV0IG5leHRDb2RlID0gMDtcbiAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbmV4dENvZGUgPSBoZXguaW5kZXhPZihpbnB1dEhleFtpIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FycnkgPSAwLCBuZXh0Qml0cyBpcyAxLCBjYXJyeSA9IDEsIG5leHRCaXRzIGlzIDJcbiAgICAgICAgICAgIGNvbnN0IG5leHRCaXRzID0gMSArIGNhcnJ5O1xuICAgICAgICAgICAgY29uc3QgbmV4dExvd0JpdHMgPSBuZXh0Q29kZSAlICgxIDw8IG5leHRCaXRzKSA8PCAoNSAtIG5leHRCaXRzKTtcbiAgICAgICAgICAgIGNvbnN0IGN1ckMzMkRpZ2l0ID0gZXhwb3J0cy5jMzJbY3VycmVudENvZGUgKyBuZXh0TG93Qml0c107XG4gICAgICAgICAgICBjYXJyeSA9IG5leHRCaXRzO1xuICAgICAgICAgICAgcmVzLnVuc2hpZnQoY3VyQzMyRGlnaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBDMzJsZWFkaW5nWmVyb3MgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZXNbaV0gIT09ICcwJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBDMzJsZWFkaW5nWmVyb3MrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXMgPSByZXMuc2xpY2UoQzMybGVhZGluZ1plcm9zKTtcbiAgICBjb25zdCB6ZXJvUHJlZml4ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKCgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKGlucHV0SGV4KSkubWF0Y2goL15cXHUwMDAwKi8pO1xuICAgIGNvbnN0IG51bUxlYWRpbmdaZXJvQnl0ZXNJbkhleCA9IHplcm9QcmVmaXggPyB6ZXJvUHJlZml4WzBdLmxlbmd0aCA6IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1MZWFkaW5nWmVyb0J5dGVzSW5IZXg7IGkrKykge1xuICAgICAgICByZXMudW5zaGlmdChleHBvcnRzLmMzMlswXSk7XG4gICAgfVxuICAgIGlmIChtaW5MZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBtaW5MZW5ndGggLSByZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHJlcy51bnNoaWZ0KGV4cG9ydHMuYzMyWzBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oJycpO1xufVxuZXhwb3J0cy5jMzJlbmNvZGUgPSBjMzJlbmNvZGU7XG4vKlxuICogTm9ybWFsaXplIGEgYzMyIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGMzMmlucHV0IC0gdGhlIGMzMi1lbmNvZGVkIGlucHV0IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGNhbm9uaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYzMyIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBjMzJub3JtYWxpemUoYzMyaW5wdXQpIHtcbiAgICAvLyBtdXN0IGJlIHVwcGVyLWNhc2VcbiAgICAvLyByZXBsYWNlIGFsbCBPJ3Mgd2l0aCAwJ3NcbiAgICAvLyByZXBsYWNlIGFsbCBJJ3MgYW5kIEwncyB3aXRoIDEnc1xuICAgIHJldHVybiBjMzJpbnB1dC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9MfEkvZywgJzEnKTtcbn1cbmV4cG9ydHMuYzMybm9ybWFsaXplID0gYzMybm9ybWFsaXplO1xuLypcbiAqIERlY29kZSBhIGMzMiBzdHJpbmcgYmFjayBpbnRvIGEgaGV4IHN0cmluZy4gIE5vdGUgdGhhdCB0aGUgYzMyIGlucHV0XG4gKiBzdHJpbmcgaXMgYXNzdW1lZCB0byBiZSBiaWctZW5kaWFuIChhbmQgdGhlIHJlc3VsdGluZyBoZXggc3RyaW5nIHdpbGxcbiAqIGJlIGFzIHdlbGwpLlxuICogQHBhcmFtIHtzdHJpbmd9IGMzMmlucHV0IC0gdGhlIGMzMi1lbmNvZGVkIGlucHV0IHRvIGRlY29kZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbkxlbmd0aCAtIHRoZSBtaW5pbXVtIGxlbmd0aCBvZiB0aGUgb3V0cHV0IGhleCBzdHJpbmcgKGluIGJ5dGVzKVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGhleC1lbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXRhLCBhcyBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBjMzJkZWNvZGUoYzMyaW5wdXQsIG1pbkxlbmd0aCkge1xuICAgIGMzMmlucHV0ID0gYzMybm9ybWFsaXplKGMzMmlucHV0KTtcbiAgICAvLyBtdXN0IHJlc3VsdCBpbiBhIGMzMiBzdHJpbmdcbiAgICBpZiAoIWMzMmlucHV0Lm1hdGNoKGBeWyR7ZXhwb3J0cy5jMzJ9XSokYCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBjMzItZW5jb2RlZCBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgemVyb1ByZWZpeCA9IGMzMmlucHV0Lm1hdGNoKGBeJHtleHBvcnRzLmMzMlswXX0qYCk7XG4gICAgY29uc3QgbnVtTGVhZGluZ1plcm9CeXRlcyA9IHplcm9QcmVmaXggPyB6ZXJvUHJlZml4WzBdLmxlbmd0aCA6IDA7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IGNhcnJ5Qml0cyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGMzMmlucHV0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChjYXJyeUJpdHMgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcy51bnNoaWZ0KGhleFtjYXJyeV0pO1xuICAgICAgICAgICAgY2FycnlCaXRzID0gMDtcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50Q29kZSA9IGV4cG9ydHMuYzMyLmluZGV4T2YoYzMyaW5wdXRbaV0pIDw8IGNhcnJ5Qml0cztcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY3VycmVudENvZGUgKyBjYXJyeTtcbiAgICAgICAgY29uc3QgY3VycmVudEhleERpZ2l0ID0gaGV4W2N1cnJlbnRWYWx1ZSAlIDE2XTtcbiAgICAgICAgY2FycnlCaXRzICs9IDE7XG4gICAgICAgIGNhcnJ5ID0gY3VycmVudFZhbHVlID4+IDQ7XG4gICAgICAgIGlmIChjYXJyeSA+IDEgPDwgY2FycnlCaXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhbmljIGVycm9yIGluIGRlY29kaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy51bnNoaWZ0KGN1cnJlbnRIZXhEaWdpdCk7XG4gICAgfVxuICAgIC8vIG9uZSBsYXN0IGNhcnJ5XG4gICAgcmVzLnVuc2hpZnQoaGV4W2NhcnJ5XSk7XG4gICAgaWYgKHJlcy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHJlcy51bnNoaWZ0KCcwJyk7XG4gICAgfVxuICAgIGxldCBoZXhMZWFkaW5nWmVyb3MgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZXNbaV0gIT09ICcwJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZXhMZWFkaW5nWmVyb3MrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXMgPSByZXMuc2xpY2UoaGV4TGVhZGluZ1plcm9zIC0gKGhleExlYWRpbmdaZXJvcyAlIDIpKTtcbiAgICBsZXQgaGV4U3RyID0gcmVzLmpvaW4oJycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTGVhZGluZ1plcm9CeXRlczsgaSsrKSB7XG4gICAgICAgIGhleFN0ciA9IGAwMCR7aGV4U3RyfWA7XG4gICAgfVxuICAgIGlmIChtaW5MZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBtaW5MZW5ndGggKiAyIC0gaGV4U3RyLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAyKSB7XG4gICAgICAgICAgICBoZXhTdHIgPSBgMDAke2hleFN0cn1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoZXhTdHI7XG59XG5leHBvcnRzLmMzMmRlY29kZSA9IGMzMmRlY29kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/c32check/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.b58ToC32 = exports.c32ToB58 = exports.versions = exports.c32normalize = exports.c32addressDecode = exports.c32address = exports.c32checkDecode = exports.c32checkEncode = exports.c32decode = exports.c32encode = void 0;\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/c32check/lib/encoding.js\");\nObject.defineProperty(exports, \"c32encode\", ({ enumerable: true, get: function () { return encoding_1.c32encode; } }));\nObject.defineProperty(exports, \"c32decode\", ({ enumerable: true, get: function () { return encoding_1.c32decode; } }));\nObject.defineProperty(exports, \"c32normalize\", ({ enumerable: true, get: function () { return encoding_1.c32normalize; } }));\nconst checksum_1 = __webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/c32check/lib/checksum.js\");\nObject.defineProperty(exports, \"c32checkEncode\", ({ enumerable: true, get: function () { return checksum_1.c32checkEncode; } }));\nObject.defineProperty(exports, \"c32checkDecode\", ({ enumerable: true, get: function () { return checksum_1.c32checkDecode; } }));\nconst address_1 = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/c32check/lib/address.js\");\nObject.defineProperty(exports, \"c32address\", ({ enumerable: true, get: function () { return address_1.c32address; } }));\nObject.defineProperty(exports, \"c32addressDecode\", ({ enumerable: true, get: function () { return address_1.c32addressDecode; } }));\nObject.defineProperty(exports, \"c32ToB58\", ({ enumerable: true, get: function () { return address_1.c32ToB58; } }));\nObject.defineProperty(exports, \"b58ToC32\", ({ enumerable: true, get: function () { return address_1.b58ToC32; } }));\nObject.defineProperty(exports, \"versions\", ({ enumerable: true, get: function () { return address_1.versions; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLHdCQUF3QixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUN2TixtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBWTtBQUN2Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDcEgsNkNBQTRDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3BILGdEQUErQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMxSCxtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBWTtBQUN2QyxrREFBaUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDOUgsa0RBQWlELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzlILGtCQUFrQixtQkFBTyxDQUFDLCtEQUFXO0FBQ3JDLDhDQUE2QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNySCxvREFBbUQsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDakksNENBQTJDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2pILDRDQUEyQyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNqSCw0Q0FBMkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYXZpbmd2YXVsdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9jMzJjaGVjay9saWIvaW5kZXguanM/YTk5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYjU4VG9DMzIgPSBleHBvcnRzLmMzMlRvQjU4ID0gZXhwb3J0cy52ZXJzaW9ucyA9IGV4cG9ydHMuYzMybm9ybWFsaXplID0gZXhwb3J0cy5jMzJhZGRyZXNzRGVjb2RlID0gZXhwb3J0cy5jMzJhZGRyZXNzID0gZXhwb3J0cy5jMzJjaGVja0RlY29kZSA9IGV4cG9ydHMuYzMyY2hlY2tFbmNvZGUgPSBleHBvcnRzLmMzMmRlY29kZSA9IGV4cG9ydHMuYzMyZW5jb2RlID0gdm9pZCAwO1xuY29uc3QgZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuL2VuY29kaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYzMyZW5jb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGluZ18xLmMzMmVuY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMmRlY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RpbmdfMS5jMzJkZWNvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJub3JtYWxpemVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kaW5nXzEuYzMybm9ybWFsaXplOyB9IH0pO1xuY29uc3QgY2hlY2tzdW1fMSA9IHJlcXVpcmUoXCIuL2NoZWNrc3VtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYzMyY2hlY2tFbmNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoZWNrc3VtXzEuYzMyY2hlY2tFbmNvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJjaGVja0RlY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hlY2tzdW1fMS5jMzJjaGVja0RlY29kZTsgfSB9KTtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJhZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzXzEuYzMyYWRkcmVzczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMmFkZHJlc3NEZWNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfMS5jMzJhZGRyZXNzRGVjb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYzMyVG9CNThcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfMS5jMzJUb0I1ODsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImI1OFRvQzMyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzXzEuYjU4VG9DMzI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc18xLnZlcnNpb25zOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/c32check/node_modules/base-x/src/index.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWSxTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhdmluZ3ZhdWx0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2MzMmNoZWNrL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzP2IwMzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKVxuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKVxuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpXG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpIC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpIC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IFVpbnQ4QXJyYXkuZnJvbShzb3VyY2UpXG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgcGJlZ2luID0gMFxuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aFxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrXG4gICAgICB6ZXJvZXMrK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMFxuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXVxuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwXG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwYmVnaW4rK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKytcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKVxuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKSB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKSB9XG4gICAgdmFyIHBzeiA9IDBcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgICAgICAgIC8vIEZpbmQgY29kZSBvZiBuZXh0IGNoYXJhY3RlclxuICAgICAgdmFyIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocHN6KVxuICAgICAgICAgICAgLy8gQmFzZSBtYXAgY2FuIG5vdCBiZSBpbmRleGVkIHVzaW5nIGNoYXIgY29kZVxuICAgICAgaWYgKGNoYXJDb2RlID4gMjU1KSB7IHJldHVybiB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgY2hhcmFjdGVyXG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtjaGFyQ29kZV1cbiAgICAgICAgICAgIC8vIEludmFsaWQgY2hhcmFjdGVyXG4gICAgICBpZiAoY2FycnkgPT09IDI1NSkgeyByZXR1cm4gfVxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDMgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDMgIT09IC0xKTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDBcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDI1NikgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYjI1Ni5cbiAgICB2YXIgaXQ0ID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrK1xuICAgIH1cbiAgICB2YXIgdmNoID0gbmV3IFVpbnQ4QXJyYXkoemVyb2VzICsgKHNpemUgLSBpdDQpKVxuICAgIHZhciBqID0gemVyb2VzXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXVxuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZylcbiAgICBpZiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2UnICsgQkFTRSArICcgY2hhcmFjdGVyJylcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js\n");

/***/ })

};
;